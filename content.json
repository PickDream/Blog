{"meta":{"title":"飞翔的傻瓜","subtitle":"菜鸟的试飞之旅","description":null,"author":"FlyingFool","url":"http://www.maoxin.site"},"pages":[{"title":"","date":"2018-07-28T14:32:22.235Z","updated":"2018-07-28T14:32:22.235Z","comments":true,"path":"about/index.html","permalink":"http://www.maoxin.site/about/index.html","excerpt":"","text":"天津理工大学软件工程16级学生 热爱计算机，底层与高层都挺喜欢的额，但是技艺不精，仍需努力！ 也希望广交朋友，互帮互助！ email:lumaoxin@aliyun.com"}],"posts":[{"title":"Hibernate-多对多映射关系","slug":"Hibernate-05","date":"2018-11-24T01:09:00.000Z","updated":"2018-11-24T01:44:48.037Z","comments":true,"path":"2018/11/24/Hibernate-05/","link":"","permalink":"http://www.maoxin.site/2018/11/24/Hibernate-05/","excerpt":"多对多关系毋庸置疑需要中间表的参与，关键在于，中间表是怎么配置产生的，多对多同时有双向和单项之分。下面通过商品的item以及分类category为例阐述多对多关系的映射以及复习数据库内、外连接,左、右连接的区别与联系。","text":"多对多关系毋庸置疑需要中间表的参与，关键在于，中间表是怎么配置产生的，多对多同时有双向和单项之分。下面通过商品的item以及分类category为例阐述多对多关系的映射以及复习数据库内、外连接,左、右连接的区别与联系。 单向多对多多对多关系必须要有中间的关联表，首先明确中间的关联表并不对应Java的一个新的类，而是配置生成。配置文件如下 12345678910111213141516&lt;class name=\"Categories\" table=\"categories\" schema=\"hibernate\"&gt; &lt;id name=\"cate_id\"&gt; &lt;column name=\"cate_id\" sql-type=\"int(11)\"/&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"name\"&gt; &lt;column name=\"name\" sql-type=\"varchar(255)\"/&gt; &lt;/property&gt; &lt;!--关键代码--&gt; &lt;set name=\"items\" table=\"categories_items\"&gt; &lt;key&gt; &lt;column name=\"C_ID\"/&gt; &lt;/key&gt; &lt;many-to-many class=\"Item\" column=\"I_ID\"/&gt; &lt;/set&gt;&lt;/class&gt; 可见，一个Set就将中间表的关系描述的很清楚了，首先定义了参照哪张表查（categories_items）,用这张表的哪个字段查(C_ID)，Set集合的获取对象的主键从哪个字段获取（I_ID）。 下面是一些执行代码 123456789101112131415161718192021Session session = sessionFactory.openSession();session.beginTransaction();Categories categories = new Categories();Categories categories2 = new Categories();categories.setName(\"C1\");categories2.setName(\"C2\");Item item = new Item();Item item2 = new Item();item.setItem_name(\"I1\");item2.setItem_name(\"I2\");categories.getItems().add(item);categories.getItems().add(item2);categories2.getItems().add(item);categories2.getItems().add(item2);session.save(categories);session.save(categories2);session.save(item);session.save(item2);session.getTransaction().commit(); 查询依然有我们熟悉的懒加载。 需要注意的是，对具有Set一端查询的时候适用了内连接（inner join） 双向多对多关于双向多对多只需要注意一下几点即可 在双向 n-n 关联的两边都需指定连接表的表名及外键列的列名. 两个集合元素 set 的 table 元素的值必须指定，而且必须相同。set元素的两个子元素：key 和 many-to-many 都必须指定 column 属性，其中，key 和 many-to-many 分别指定本持久化类和关联类在连接表中的外键列名，因此两边的 key 与 many-to-many 的column属性交叉相同。 对于双向 n-n 关联, 必须把其中一端的 inverse 设置为 true, 否则两端都维护关联关系可能会造成主键冲突 内连接、左外连接、右外连接、交叉连接 left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录inner join(等值连接) 只返回两个表中联结字段相等的行 交叉连接，这个没有具体参照，只要列出全部的关系，也就是笛卡尔积 有一张图诠释的很好：","categories":[{"name":"java","slug":"java","permalink":"http://www.maoxin.site/categories/java/"}],"tags":[{"name":"Hibernate框架","slug":"Hibernate框架","permalink":"http://www.maoxin.site/tags/Hibernate框架/"}]},{"title":"JVM启动流程","slug":"JavaVM-02","date":"2018-11-22T13:31:50.000Z","updated":"2018-11-24T01:46:33.234Z","comments":true,"path":"2018/11/22/JavaVM-02/","link":"","permalink":"http://www.maoxin.site/2018/11/22/JavaVM-02/","excerpt":"在这篇文章主要分析学习JVM的包括启动流程等等重要的知识点，不断更新","text":"在这篇文章主要分析学习JVM的包括启动流程等等重要的知识点，不断更新 Java启动流程PC寄存器 每一个线程拥有PC寄存器 在线程创建时创建 执行本地方法时该值是undefined 指向下一条指令的地址 方法区 保存装载的类信息 类型的常量池（JDK6时候，String等常量信息置于方法区，JDK7时候移动到了堆） 字段，方法信息 方法字节码 通常和永久区（Perm）关联在一起 Java堆 和程序开发密切相关 应用系统对象都保存在Java堆中 所有线程共享Java堆 对于分代GC来说，堆也是分带 GC主要工作的区间 eden -&gt;S0-&gt;S1-&gt;tenured Java栈 线程私有的 栈由一系列帧组成(Java栈也叫帧栈) 帧保存一个方法的局部变量，操作数栈，常量池指针 每次方法调用创建一个帧并且压栈 Java栈-局部变量表（包括函数的参数以及局部变量） 实例方法传入this Java栈-操作数栈（Java没有寄存器，所有参数传递使用操作数栈） 12345public static int add(int a,int b)&#123; int c = 0; c = a+b; return c;&#125; 对应","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.maoxin.site/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.maoxin.site/tags/JVM/"}]},{"title":"Hibernate-一对一关联关系","slug":"Hibernate-04","date":"2018-11-22T10:26:35.000Z","updated":"2018-11-22T12:09:56.240Z","comments":true,"path":"2018/11/22/Hibernate-04/","link":"","permalink":"http://www.maoxin.site/2018/11/22/Hibernate-04/","excerpt":"今天学习的是一对一映射关系，一对一映射关系分为两种 基于外键的一对一映射关系 基于主键的一对一映射关系 其中，基于外键的一对一映射关系的数据库视图上基本与单项多对一一样，而在javabean的角度上看都持有对方的引用。其中有许多需要注意的细节，基于主键的一对一映射关系需要再一个表中的主键加上外键约束。","text":"今天学习的是一对一映射关系，一对一映射关系分为两种 基于外键的一对一映射关系 基于主键的一对一映射关系 其中，基于外键的一对一映射关系的数据库视图上基本与单项多对一一样，而在javabean的角度上看都持有对方的引用。其中有许多需要注意的细节，基于主键的一对一映射关系需要再一个表中的主键加上外键约束。 下面的例子主要描述的是Leader与Department的关系，一个Leader只能领导一个部门，这种关系的数据表关系主要是如下的形式： 可以看出双方都持有对方的引用，而关系模型却与一对多的情况基本一样。下面开始总结两种映射关系 基于外键的1对1映射关系 都是其中一张表中有指向另外一张表主键的外键，这个外键如果不设置unique的话，那么就是典型的单向多对一的关系，因此，必须对外键加上unique约束，如何配置这个unique？如下： 12345678910111213&lt;hibernate-mapping package=\"One2One\"&gt; &lt;class name=\"Department\" table=\"department\" schema=\"hibernate\"&gt; &lt;id name=\"id\"&gt; &lt;column name=\"id\" sql-type=\"int(11)\"/&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"departmentName\"&gt; &lt;column name=\"department_name\" sql-type=\"varchar(255)\"/&gt; &lt;/property&gt; &lt;!--设置多对一关联，只不过将unique属性设置位true--&gt; &lt;many-to-one name=\"leader\" class=\"Leader\" column=\"leader_id\" unique=\"true\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 可见是在原来基础上的&lt;many-to-one&gt;下配置unique。这样，对于Department这张表，它知道自己是一对一关系，但是对于Leader这张表的操作，它自己从表的字段就无从得知了，这个时候，需要明确指明其关系。“告诉他”自己是和谁（哪张表）有怎样的关系，这就用到了&lt;one-to-one&gt;标签： 1234567891011121314&lt;hibernate-mapping package=\"One2One\"&gt; &lt;class name=\"Leader\" table=\"leader\" schema=\"hibernate\"&gt; &lt;id name=\"id\"&gt; &lt;column name=\"id\" sql-type=\"int(11)\"/&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"name\"&gt; &lt;column name=\"name\" sql-type=\"varchar(255)\"/&gt; &lt;/property&gt; &lt;!--关键在于property--&gt; &lt;one-to-one name=\"department\" class=\"Department\" property-ref=\"leader\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 如果不配置property-ref其整个一对一映射关系是错的，因为Leader不知道自己和Department是怎样建立关系的，只知道和谁，却不知道和哪个字段建立关系（默认是和主键建立关系的），这个时候需要property-ref来明确，这里的property-ref=&quot;leader&quot;这个leader指的是另外一张表中名为leader的字段，通过这样建立关系。 property-ref 属性指定使用被关联实体主键以外的字段作为关联字段 这样关系就明确了。 还有几个问题需要解释： 为什么从department一端去获取leader的时候可以进行懒加载，而leader却是直接获取到department？ 这主要是因为department持有leader的主键，反之却没有，因此需要左外链接来获取。 建立实体之间关系时发现，只要是关系（外键）都用实体类来联系 需要注意的是一边使用many-to-one一边使用one to one 基于主键的1对1关系什么是基于主键的一对一关系呢？就是说两张表的主键需要保持一致，这就需要其中一张表去建立一个主键约束。其关系如下图： 既然是主键作为外键势必对其中一张需要建立外键的表中建立关系，其SQL语句为 12345678910create table department ( id int(11) not null, department_name varchar(255), primary key (id) ) engine=InnoDBalter table department add constraint FKkp74p62nnqrxs8compagd3qkd foreign key (id) references leader (id) 双方的XML分别为： 12345678910111213141516&lt;hibernate-mapping package=\"One2One\"&gt; &lt;class name=\"Department\" table=\"department\" schema=\"hibernate\"&gt; &lt;id name=\"id\"&gt; &lt;column name=\"id\" sql-type=\"int(11)\"/&gt; &lt;!--这里对主键的生成策略有了不一样的约束--&gt; &lt;generator class=\"foreign\"&gt; &lt;param name=\"property\"&gt;leader&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name=\"departmentName\"&gt; &lt;column name=\"department_name\" sql-type=\"varchar(255)\"/&gt; &lt;/property&gt; &lt;!--注意这里使用了constrained=true--&gt; &lt;one-to-one name=\"leader\" class=\"Leader\" constrained=\"true\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; constrained(约束):指定为当前持久化类对应的数据库表的主键添加一个外键约束，引用被关联的对象(“对方”)所对应的数据库表主键","categories":[{"name":"java","slug":"java","permalink":"http://www.maoxin.site/categories/java/"}],"tags":[{"name":"Hibernate框架","slug":"Hibernate框架","permalink":"http://www.maoxin.site/tags/Hibernate框架/"}]},{"title":"Hibernate-多对一关联","slug":"Hibernate-03-1","date":"2018-11-21T11:30:38.000Z","updated":"2018-11-21T12:27:27.995Z","comments":true,"path":"2018/11/21/Hibernate-03-1/","link":"","permalink":"http://www.maoxin.site/2018/11/21/Hibernate-03-1/","excerpt":"今天自学Hibernate的多对一关联，整体来说，多对一关联分为单向多对一和双向多对一，这两种从数据库视图中完全没有区别，区别在于编码的数据访问层视图，单向多对一在多的那边的每一个实体持有”一“端这边的引用，获取可以直接获取，通过代理模式实现懒加载来提供一个看似“直接操作”的效果，而所谓双向，就是“一“这一端持有一个集合类型的引用，来描述多的一方，当然这个集合类型也是懒加载的，因此需要注意Set类型的引用必须是接口。当然这在数据访问层的不同是通过Hibernate的配置文件设置的。下面将会对一个具体的例子来总结。","text":"今天自学Hibernate的多对一关联，整体来说，多对一关联分为单向多对一和双向多对一，这两种从数据库视图中完全没有区别，区别在于编码的数据访问层视图，单向多对一在多的那边的每一个实体持有”一“端这边的引用，获取可以直接获取，通过代理模式实现懒加载来提供一个看似“直接操作”的效果，而所谓双向，就是“一“这一端持有一个集合类型的引用，来描述多的一方，当然这个集合类型也是懒加载的，因此需要注意Set类型的引用必须是接口。当然这在数据访问层的不同是通过Hibernate的配置文件设置的。下面将会对一个具体的例子来总结。 这里介绍的还是一个订单”orders(注意order是数据库关键字)“和”顾客customer“间的例子 单向一对一单向一对一中，主要是”多“这一端持有”一“这一端的引用，那么在其实体类就变成了： 123456//orders,忽略Getter&amp;Setterpublic class Order &#123; private int id; private String productName; private Customer customer;//引用&#125; 那么在其hbm.xml自然会去指明： 12345678910111213141516&lt;hibernate-mapping package=\"entity\"&gt; &lt;class name=\"Order\" table=\"orders\" schema=\"hibernate\"&gt; &lt;id name=\"id\"&gt; &lt;column name=\"id\" sql-type=\"int(11)\"/&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"productName\"&gt; &lt;column name=\"product_name\" sql-type=\"varchar(255)\"/&gt; &lt;/property&gt; &lt;!--一对多映射--&gt; &lt;!--本表的name指向外表的哪个column--&gt; &lt;many-to-one name=\"consumer\" class=\"Consumer\" column=\"consumer_id\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 可以看到，这里使用many-to-map,自己这一端是many，对的是one，这个标签整体的语义是 首先是一个多对一映射 自己这一端的类字段名是consumer 这个类字段名对应的类是Consumer 通过consumer_id字段值去找对应的实体 双向一对一双向一对多，这里的类添加了一个set类型的引用，需要注意的是这个set引用提前被初始化，以防止空指针异常这个错误: 1234567891011public class Consumer &#123; private int id; private String name; /** * 双向一对多 * 需要将集合初始化，防止发生空指针异常 * 注意声明接口类型，因为其返回的是Hibernate实现的集合类型 * */ private Set&lt;Order&gt; orders = new HashSet&lt;&gt;();&#125; 同样hbm.xml文件需要一些操作 1234567891011121314151617&lt;hibernate-mapping package=\"entity\"&gt; &lt;class name=\"Consumer\" table=\"consumer\" schema=\"hibernate\"&gt; &lt;id name=\"id\"&gt; &lt;column name=\"id\" sql-type=\"int(11)\"/&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"name\"&gt; &lt;column name=\"name\" sql-type=\"varchar(255)\"/&gt; &lt;/property&gt; &lt;!--双向一对多增加项目--&gt; &lt;!--指明本表的哪个字段（默认是ID）作为哪张表的外键，其类型是什么--&gt; &lt;set name=\"orders\" table=\"orders\" &gt; &lt;key column=\"consumer_id\"/&gt; &lt;one-to-many class=\"Order\"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 这里需要注意的是set标签其内容。注意其中包含的是one-to-many的标签，这样就可以获得对应多端的集合了，但是在此，务必要明白以下几个关键点： 是否只要将Order的Set集合赋值给一个新的Consumer实例，之后调用Session保存就可以都添加进去(不行，除非添加级联) 为什么先保存Order再保存Consumer发送的SQL个数的条数不一样？（调用了update方法，刚开始插入那几条外键为空） 为什么如下代码发送SQL如此啰嗦，如下： 1234567891011121314151617181920212223@Testpublic void testMany2OneSave()&#123; Session session =sessionFactory.openSession(); session.beginTransaction(); Consumer consumer = new Consumer(); consumer.setName(\"Maoxin\"); //这里多的一方建立与1的一方的关系 Order order1 = new Order(); order1.setProductName(\"YunDongDian\"); order1.setConsumer(consumer); Order order2 = new Order(); order2.setProductName(\"PS4\"); order2.setConsumer(consumer); //这里是consumer主动管理n的乙方 consumer.getOrders().add(order1); consumer.getOrders().add(order2); session.save(consumer); session.save(order1); session.save(order2); session.getTransaction().commit(); session.close();&#125; 发送的SQL为: 123456789101112131415161718192021222324252627282930313233343536Hibernate: insert into consumer (name) values (?)Hibernate: insert into orders (product_name, consumer_id) values (?, ?)Hibernate: insert into orders (product_name, consumer_id) values (?, ?)# 下面的update是什么意思？ Hibernate: update orders set consumer_id=? where id=?Hibernate: update orders set consumer_id=? where id=? 由于默认情况下是双方维护关联关系，也就是说1这一方也得去维护，这就导致了以上结果，详情在下面，最终应该使用 1234&lt;set name=\"orders\" table=\"orders\" inverse=\"true\"&gt; &lt;key column=\"consumer_id\"/&gt; &lt;one-to-many class=\"Order\"/&gt;&lt;/set&gt; 注意事项inverse属性 其是SET的属性 在hibernate中通过对 inverse 属性的来决定是由双向关联的哪一方来维护表和表之间的关系. inverse = false 的为主动方，inverse = true 的为被动方, 由主动方负责维护关联关系在没有设置 inverse=true 的情况下，父子两边都维护父子关系 在 1-n 关系中，将 n 方设为主控方将有助于性能改善(如果要国家元首记住全国人民的名字，不是太可能，但要让全国人民知道国家元首，就容易的多) 在 1-N 关系中，若将 1 方设为主控方会额外多出 update 语句。插入数据时无法同时插入外键列，因而无法为外键列添加非空约束 关于级联 在对象 – 关系映射文件中, 用于映射持久化类之间关联关系的元素, &lt;set&gt;, &lt;many-to-one&gt; 和 &lt;one-to-one&gt; 都有一个 cascade 属性, 它用于指定如何操纵与当前对象关联的其他对象. 级联的详情 order By属性 元素有一个 order-by 属性, 如果设置了该属性, 当 Hibernate 通过 select 语句到数据库中检索集合对象时, 利用 order by 子句进行排序","categories":[{"name":"java","slug":"java","permalink":"http://www.maoxin.site/categories/java/"}],"tags":[{"name":"Hibernate框架","slug":"Hibernate框架","permalink":"http://www.maoxin.site/tags/Hibernate框架/"}]},{"title":"Spring总结-AOP","slug":"Spring-Summary-1","date":"2018-11-20T02:08:48.000Z","updated":"2018-11-20T02:22:40.188Z","comments":true,"path":"2018/11/20/Spring-Summary-1/","link":"","permalink":"http://www.maoxin.site/2018/11/20/Spring-Summary-1/","excerpt":"AOP名词在Spring学习中已经听的不能再熟了，但是不能保证所有的概念都了然于胸，对于什么通知，增强，切面等概念含糊的不行，对于什么时候使用advice相关的标签，什么时候使用aspect相关的标签，他们有什么区别与联系？从这里起就开始总结，博文书写的过程就是加深理解的过程。","text":"AOP名词在Spring学习中已经听的不能再熟了，但是不能保证所有的概念都了然于胸，对于什么通知，增强，切面等概念含糊的不行，对于什么时候使用advice相关的标签，什么时候使用aspect相关的标签，他们有什么区别与联系？从这里起就开始总结，博文书写的过程就是加深理解的过程。 增强切面","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Spring框架学习","slug":"Spring框架学习","permalink":"http://www.maoxin.site/tags/Spring框架学习/"}]},{"title":"Hibernate配置项","slug":"Hibernate-03","date":"2018-11-19T02:27:32.000Z","updated":"2018-11-19T02:31:23.762Z","comments":true,"path":"2018/11/19/Hibernate-03/","link":"","permalink":"http://www.maoxin.site/2018/11/19/Hibernate-03/","excerpt":"记录一些常见的hibernate.cfg.xml的配置项，会随着后续学习不断更新。目前配置项内容包括 jdbc驱动 C3P0数据源 fetch与Batch的大小(Mysql不起作用) 其他例如数据库方言等等配置项目","text":"记录一些常见的hibernate.cfg.xml的配置项，会随着后续学习不断更新。目前配置项内容包括 jdbc驱动 C3P0数据源 fetch与Batch的大小(Mysql不起作用) 其他例如数据库方言等等配置项目 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--配置链接数据库的基本信息--&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://localhost:3306/Hibernate?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC&lt;/property&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"connection.password\"&gt;&lt;/property&gt; &lt;!--配置C3P0数据源--&gt; &lt;!--连接池最大连接数(大量并发)--&gt; &lt;property name=\"c3p0.max_size\"&gt;10&lt;/property&gt; &lt;!--连接池最小连接数(保持)--&gt; &lt;property name=\"c3p0.min_size\"&gt;5&lt;/property&gt; &lt;!--连接增长的步长--&gt; &lt;property name=\"c3p0.acquire_increment\"&gt;2&lt;/property&gt; &lt;!--idle 空闲，指的是多长时间检测是否超时--&gt; &lt;property name=\"c3p0.idle_test_period\"&gt;2000&lt;/property&gt; &lt;!--缓存Statment对象的数量--&gt; &lt;property name=\"c3p0.max_statements\"&gt;10&lt;/property&gt; &lt;!--定时检测多长时间没有使用过就会被销毁--&gt; &lt;property name=\"c3p0.timeout\"&gt;2000&lt;/property&gt; &lt;!--配置hibernate的基本信息--&gt; &lt;!--hibernate所使用的数据库方言--&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQL55Dialect&lt;/property&gt; &lt;!--执行时候是否在控制台打印SQL--&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!--是否对SQL进行格式化--&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!--指定自动生成数据表的策略--&gt; &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!--设定JDBC的statement读取数据库每次从数据库中取出的记录数--&gt; &lt;property name=\"jdbc.fetch_size\"&gt;100&lt;/property&gt; &lt;!--设置批量更新的批次的大小--&gt; &lt;property name=\"jdbc.batch_size\"&gt;30&lt;/property&gt; &lt;!--指明自动关联的.hbm.xml文件--&gt; &lt;mapping resource=\"entity/NewsEntity.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;","categories":[{"name":"java","slug":"java","permalink":"http://www.maoxin.site/categories/java/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.maoxin.site/tags/Hibernate/"}]},{"title":"Spring事务相关","slug":"Spring-06","date":"2018-11-15T03:47:13.000Z","updated":"2018-11-20T02:12:09.590Z","comments":true,"path":"2018/11/15/Spring-06/","link":"","permalink":"http://www.maoxin.site/2018/11/15/Spring-06/","excerpt":"该博文主要正对Spring提供的事务支持功能的总结，其主要包含以下内容： 事务的配置 事务的传播行为 事务的特性复习以及隔离级别的设置 事务属性的配置 事务如何使用XML方式进行配置","text":"该博文主要正对Spring提供的事务支持功能的总结，其主要包含以下内容： 事务的配置 事务的传播行为 事务的特性复习以及隔离级别的设置 事务属性的配置 事务如何使用XML方式进行配置","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Spring框架学习","slug":"Spring框架学习","permalink":"http://www.maoxin.site/tags/Spring框架学习/"}]},{"title":"使用注解的方式配置Bean","slug":"Spring-05","date":"2018-11-15T03:16:36.000Z","updated":"2018-11-15T03:52:17.576Z","comments":true,"path":"2018/11/15/Spring-05/","link":"","permalink":"http://www.maoxin.site/2018/11/15/Spring-05/","excerpt":"使用注解配置的方式,其是通过包扫描的方式获得哪些类需要装配，Spring启动的起点是一个配置文件，那么该配置文件必然指定了从哪里扫描，怎样去扫描，扫描那些对象被IOC容器所管理等等，下面主要针对基本的步骤进行总结。","text":"使用注解配置的方式,其是通过包扫描的方式获得哪些类需要装配，Spring启动的起点是一个配置文件，那么该配置文件必然指定了从哪里扫描，怎样去扫描，扫描那些对象被IOC容器所管理等等，下面主要针对基本的步骤进行总结。 扫描哪些组件？扫描的组件是由以下注解指定的，其都能被Spring的IOC容器所管理，不同的是其语义不同，如下： 注解 含义 @Component 基本注解, 标识了一个受 Spring 管理的组件 @Respository 标识持久层组件 @Service 标识持久层组件 @Controller 标识表现层组件 类被以上注解修饰即可被扫描到并装入IOC容器内进行管理 组件如何装配？我们之前通过XML方式来装配大致有如下几种方法： 直接定义其值（基本类型） 用ref引用来引用IOC容器管理的其他的对象 集合的装配 @Value注解@AutoWired 注解@Resource 与@ Inject组件如何被装配的？确定如何扫描？指定扫描什么位置？指明排除项目指明包含项目","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Spring框架学习","slug":"Spring框架学习","permalink":"http://www.maoxin.site/tags/Spring框架学习/"}]},{"title":"Hibernate-02","slug":"Hibernate-02","date":"2018-11-11T11:48:24.000Z","updated":"2018-11-11T11:48:24.471Z","comments":true,"path":"2018/11/11/Hibernate-02/","link":"","permalink":"http://www.maoxin.site/2018/11/11/Hibernate-02/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Spring-SPEL&Bean的生命周期&从工厂中装配Bean","slug":"Spring-04","date":"2018-11-11T02:30:32.000Z","updated":"2018-11-12T11:37:34.541Z","comments":true,"path":"2018/11/11/Spring-04/","link":"","permalink":"http://www.maoxin.site/2018/11/11/Spring-04/","excerpt":"今天主要关注以下内容： 如何给更好的给Bean的属性赋值，甚至将简单的赋值逻辑加入-&gt;SPEL 如何更细粒度的管理对象在IOC容器中的生命周期-&gt;初始化+销毁方法+初始化方法前后进行处理 通过工厂方法对Bean进行配置-&gt;静态工厂+实例工厂+FactoryBean方式","text":"今天主要关注以下内容： 如何给更好的给Bean的属性赋值，甚至将简单的赋值逻辑加入-&gt;SPEL 如何更细粒度的管理对象在IOC容器中的生命周期-&gt;初始化+销毁方法+初始化方法前后进行处理 通过工厂方法对Bean进行配置-&gt;静态工厂+实例工厂+FactoryBean方式 SPEL定义Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。其使用#{}作为界定符，所有在大括号内的字符都被认为是SpEL 功能字面量整数#{1}，浮点数#{89.7},科学计数法#{1e4}字符串#{&#39;Hello&#39;}或者#{&quot;Hello&quot;}，布尔值#{false} 引用对象、属性与方法引用其他对象#{objName},对象的属性#{objName.property},调用方法#{objName.function()},链式调用方法#{objName.toString().toUpperCase()} 运算加减乘除不在赘述，这里最关键的是调用静态方法或者字段:#{T(java.lang.Math).PI}比较运算符 &lt;,&gt;,==,&lt;=,&gt;=,lt,gt,eq,le,ge 例如#{counter.total le 100} 逻辑运算&amp;三目表达式&amp;正则逻辑运算：and,or,not,|#{!product.available} 三目表达形式:#{obj.name==&#39;maoxin&#39;?&#39;item1&#39;,&#39;item2&#39;} 正则表达式:#{admin.email matchs &#39;[a-zA-z0-9._%+=]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,4}&#39;} 生命周期首先在Bean的标签中可以配置两个属性，分别代表Bean的初始化方法以及销毁方法，例 1234&lt;bean id=\"1\" class=\"LifeCircle.SomeWhat\" init-method=\"init\" destroy-method=\"destory\"&gt; &lt;property name=\"value\" value=\"123\"&gt;&lt;/property&gt;&lt;/bean&gt; 通过对一下代码的单步执行得到生命周期的过程： 123456//在初始化的IOC容器的时候就执行了构造函数以及init方法ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans-lifecircle.xml\");//此时直接从容器中得到SomeWhat someWhat = (SomeWhat) applicationContext.getBean(\"1\");//在容器关闭的时候执行close方法applicationContext.close(); 大致总结下，实例的生命周期 容器初始化，执行构造方法以及指定的初始化方法 容器关闭得到时候，执行指定的销毁方法 在Spring，还可以对Bean的生命周期执行更加细粒度的管理，通过实现BeanPostProcessor 接口。 BeanPostProcessor接口1234567891011121314public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(beanName.toString()+beanName); System.out.println(\"postProcessAfter\"); return bean; &#125; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"postProcessBefore\"); return bean; &#125;&#125; 在XML中配置并且启用 1&lt;bean class=\"LifeCircle.MyBeanPostProcessor\"/&gt; 这样在IOC容器初始化的过程中就执行完了上述初始化 从工厂中配置Bean从静态方法中配置使用factory-method配合 静态工厂首先创建静态工厂 12345678910public final class CarFactory &#123; private static Map&lt;String,Car&gt; resp = new HashMap&lt;&gt;(); static &#123; resp.put(\"BMW\",new Car(\"BMW\",1)); resp.put(\"CCC\",new Car(\"CCC\",2)); &#125; public static Car getCar(String name)&#123; return resp.get(name); &#125;&#125; 通过以下方式创建： 123&lt;bean id=\"car1\" class=\"LifeCircle.CarFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg name=\"name\" value=\"BMW\"/&gt;&lt;/bean&gt; 实例工厂实例工厂首先要创建出这么一个工厂，之后在这个工厂进行配置Bean的操作 123456789101112//实例工厂public class InstanceCarFactory &#123; private Map&lt;String,Car&gt; cars = null; public InstanceCarFactory()&#123; cars = new HashMap&lt;&gt;(); cars.put(\"audi\",new Car(\"audi\",30)); &#125; public Car getCar(String name)&#123; return cars.get(name); &#125;&#125; 123456&lt;!--首先创建实例方法Bean--&gt;&lt;bean id=\"carFactory\" class=\"LifeCircle.InstanceCarFactory\"/&gt;&lt;!--再创建实例--&gt;&lt;bean id=\"car2\" factory-bean=\"carFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"audi\"/&gt;&lt;/bean&gt; Factory Bean形式 参阅http://book.51cto.com/art/201311/419081.htm","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Spring框架学习","slug":"Spring框架学习","permalink":"http://www.maoxin.site/tags/Spring框架学习/"}]},{"title":"hibernate起步","slug":"hibernate-01","date":"2018-11-10T09:06:13.000Z","updated":"2018-11-11T08:36:22.766Z","comments":true,"path":"2018/11/10/hibernate-01/","link":"","permalink":"http://www.maoxin.site/2018/11/10/hibernate-01/","excerpt":"之前也多多少少接触过Hibernate框架，只限于简单的使用，没有深入的去理解学习，这次从头开始，踏踏实实完成Hibernate的系统学习，起步部分主要完成如何配置环境，大致操作流程，一些注意点。","text":"之前也多多少少接触过Hibernate框架，只限于简单的使用，没有深入的去理解学习，这次从头开始，踏踏实实完成Hibernate的系统学习，起步部分主要完成如何配置环境，大致操作流程，一些注意点。 导入jar 从官方网站下载对应的jar包，导入压缩文件中lib/required的全部jar包 导入数据库驱动 配置总而言之，Hibernate的配置和MyBatis这样的持久层框架的使用可以说是很相似，首先有一个主的配置文件，完成框架属性的配置、数据库驱动的指定、连接池的配置等等。其次，在主的配置文件中也得引入对实体类与数据表的映射文件，是XML格式的。在之下的内容主要是借助与idea这样的IDE工具完成最基本项目的搭建。 idea中生成主配置文件 导包完成之后，在ide中项目文件夹中右键-&gt;add Frameworks Support-&gt; 选中Hibernate 应用之后打开project structure后转到Modules找到Hibernate点击加号添加主配置文件，成功之后在src下就创建了hibernate.cfg.xml 配置主配置文件 配置数据库信息 配置hibernate 信息 关联的映射信息 123456789101112131415161718192021222324&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--配置链接数据库的基本信息--&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://localhost:3306/Hibernate&lt;/property&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"connection.password\"&gt;???&lt;/property&gt; &lt;!--配置hibernate的基本信息--&gt; &lt;!--hibernate所使用的数据库方言--&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQL55Dialect&lt;/property&gt; &lt;!--执行时候是否在控制台打印SQL--&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!--是否对SQL进行格式化--&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!--指定自动生成数据表的策略--&gt; &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!--指明自动关联的.hbm.xml文件--&gt; &lt;mapping resource=\"entity/NewsEntity.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 之上配置了一些例如是否在控制台打印SQL的象，格式化SQL等等，需要关注的配置是hbm2ddl.auto： 该配置名的含义是Hibernate Mapping to Data Define Language(Hibernate 映射转数据定义语言)，其能够帮助我们完成从映射文件到生成数据库实体的过程，取值为 类型 作用 create 每次运行都会生成表 create-drop 除了创建SessionFactory创建生成表之外，关闭的时候删除 update 最常用，表结构不同将会输出 validate 初始化发现表结构的列不存在会抛出异常 逆向生成实体对象以及配置文件打开 Persistence-&gt;右键-&gt;Generate Persistence Mapping-&gt;By Database Schema 接下来就照提示操作了。 生成的Bean(只包含字段) 123456public class NewsEntity &#123; private int id; private String title; private String author; private Date date;&#125; 生成的关系映射 123456789101112131415161718&lt;hibernate-mapping&gt; &lt;class name=\"entity.NewsEntity\" table=\"news\" schema=\"hibernate\"&gt; &lt;id name=\"id\"&gt; &lt;column name=\"Id\" sql-type=\"int(11)\"/&gt; &lt;!--指明主键的生成方式，native:使用数据库本地的方式--&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"title\"&gt; &lt;column name=\"title\" sql-type=\"varchar(255)\" not-null=\"true\"/&gt; &lt;/property&gt; &lt;property name=\"author\"&gt; &lt;column name=\"author\" sql-type=\"varchar(255)\" not-null=\"true\"/&gt; &lt;/property&gt; &lt;property name=\"date\"&gt; &lt;column name=\"date\" sql-type=\"date\" not-null=\"true\"/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 总得来事其中描述了以下关键信息 数据库列名与字段名的关系 数据库字段的数据库类型（为了与Java类型进行自动转换） 字段其他属性 Hibernate 写入数据库流程 创建SessionFactory对象(读取配置文件) 创建Session对象 开启事务 执行操作 提交事务 关闭Session 关闭SessionFactory 其中关键点是创建SessionFactory,官方文档给出的创建方式(Hibernate5.0)，之后是对文档内容的翻译。自己翻译的， 1234567891011121314protected void setUp() throws Exception &#123; // 一个SessionFactory 在一个应用中启动一次 final StandardServiceRegistry registry = new StandardServiceRegistryBuilder() .configure() //依据hibernate.cfg.xml来配置 .build(); try &#123; sessionFactory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); &#125; catch (Exception e) &#123; // registry would be destroyed by the SessionFactory, but we had trouble building the SessionFactory // so destroy it manually. StandardServiceRegistryBuilder.destroy( registry ); &#125;&#125; 这个SetUp方法首先构建了一个org.hibernate.boot.registry.StandardServiceRegistry 实例将配置信息合并到一组工作服务中以供SessionFactory去使用。 使用StandardServiceRegistry我们创建的org.hibernate.boot.MetadataSources是我们告诉Hibernate关于我们领域模型的起点，由于我们是通过hibernate.cfg.xml去配置的，所以这里没有什么特别的需要关注 org.hibernate.boot.Metadata代表着一个完整的，部分验证过的领域模型视图，而SessionFactory也正是基于此的 在启动过程的最后一步是去构建一个SessionFactory,这个SessionFactory是一个线程安全的对象只实例化一次而服务整个应用 这个SessionFactory表现的像是一个org.hibernate.Session对象的工厂 在得到了Session之后，我们就可以进行简单的增删查改了 1234567891011//打开SessionSession session = sessionFactory.openSession();//开启事务session.beginTransaction();//保存对象实体session.save( new Event( \"Our very first event!\", new Date() ) );session.save( new Event( \"A follow up event\", new Date() ) );//提交事务session.getTransaction().commit();、//关闭Sessionsession.close();","categories":[{"name":"java","slug":"java","permalink":"http://www.maoxin.site/categories/java/"}],"tags":[{"name":"Hibernate框架","slug":"Hibernate框架","permalink":"http://www.maoxin.site/tags/Hibernate框架/"}]},{"title":"Spring-Bean的自动装配&关系&作用域&导入外部属性文件","slug":"Spring-03","date":"2018-11-10T01:46:54.000Z","updated":"2018-11-10T03:24:11.618Z","comments":true,"path":"2018/11/10/Spring-03/","link":"","permalink":"http://www.maoxin.site/2018/11/10/Spring-03/","excerpt":"第三天的内容主要继续了解配置beans的方方面面，包括以下内容： 自动装配(Auto Wire) Bean之间的关系(继承&amp;依赖) Bean的作用域(scope=singleton|prototype) 使用外部属性文件","text":"第三天的内容主要继续了解配置beans的方方面面，包括以下内容： 自动装配(Auto Wire) Bean之间的关系(继承&amp;依赖) Bean的作用域(scope=singleton|prototype) 使用外部属性文件 自动装配自动装配是虽不明确指明属性装配什么，但是通过Bean内部属性的名字或者类型自动装配的一种方式，其有三种，最常见的有两种 自动装配的方式装配的方式通过Bean标签的aurowire来指明的 By NameBy Name方式是通过Bean内部Setter的名字部分去找到id进行装配的，实例如下：123456@Datapublic class Person &#123; private String name; private Address address; private Car car1;&#125; 12345678&lt;bean id=\"address\" class=\"AutoWareTest.Address\" p:city=\"BeiJin\" p:street=\"Wangfujin\"/&gt;&lt;bean id=\"car\" class=\"AutoWareTest.Car\" p:brand=\"Audi\" p:price=\"300000\"/&gt;&lt;bean id=\"car1\" class=\"AutoWareTest.Car\" p:brand=\"NoBrand\" p:price=\"20000\"/&gt;&lt;bean id=\"person\" class=\"AutoWareTest.Person\" p:name=\"Tom\" autowire=\"byName\"/&gt; 注意上面设置了两个Car对象，id分别为car1，car，因此预测通过属性名car1应该得到的是car1的内容：运行结果如下 Person(name=Tom, address=Address(city=BeiJin, street=Wangfujin), car1=Car(brand=NoBrand, price=20000.0)) 符合预期 By TypeBy Type是通过Class类型来装配的，这也意味着在配置文件中不能有两个相同的作为属性的类配置 自动装配的缺点不够灵活 Bean之间的关系Bean之间的关系主要是：继承和依赖，被继承的父Bean可以充当模版，而交给子Bean去重写，当然也可以设置Bean的abstract属性为true，为抽象Bean，抽象Bean不可以被实例化，如果一个Bean的Class属性没有设置，则必须设置位抽象Bean,子Bean继承可以使用parent属性 依赖关系主要是在创建对象前指明自己需要依赖的Bean必须加载完成。而不代表设置了依赖自己就会在对应的属性中装载 继承123&lt;bean id=\"abstractAddreass\" class=\"AutoWareTest.Address\" abstract=\"true\" p:city=\"Beijin\"/&gt;&lt;bean id=\"address\" class=\"AutoWareTest.Address\" parent=\"abstractAddreass\" p:street=\"Wangfujin\" /&gt; 此时创建的Address对象的city自动有了city 依赖依赖通过append-on来设置依赖，前置依赖的Bean会在本Bean实例化之前创建好 Bean的作用域通过Bean的scope属性来设置 scope=”singleton” 默认值，是单例的 scope=”prototype” 可以创建多个 整合外部属性文件以整合c3p0连接池为例：不使用外部配置文件直接配置搭配bean中，每次修改配置必须打开spring配置文件。123456&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"?????\"/&gt; &lt;property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/struts?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC\"/&gt;&lt;/bean&gt; 将具体的配置放置在外部1234user=rootpassword=?????driverclass=com.mysql.cj.jdbc.Driverjdbcurl=jdbc:mysql://localhost:3306/struts?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC 使用&lt;context:property-placeholder&gt;1234567&lt;context:property-placeholder location=\"db.properties\"/&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"user\" value=\"$&#123;user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;property name=\"driverClass\" value=\"$&#123;driverclass&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbcurl&#125;\"/&gt;&lt;/bean&gt;","categories":[{"name":"java","slug":"java","permalink":"http://www.maoxin.site/categories/java/"}],"tags":[{"name":"Spring框架学习","slug":"Spring框架学习","permalink":"http://www.maoxin.site/tags/Spring框架学习/"}]},{"title":"Spring-属性注入","slug":"Spring-02","date":"2018-11-08T08:36:08.000Z","updated":"2018-11-08T11:10:51.071Z","comments":true,"path":"2018/11/08/Spring-02/","link":"","permalink":"http://www.maoxin.site/2018/11/08/Spring-02/","excerpt":"自学Spring框架第二天，今天主要是更加深入的学习了Spring Bean的配置方式（XML形式的）使用方式以及一些注意的点。简而言之就是如何配置一个Bean，属性如何去注入？引用类型如何去注入？集合属性如何去注入，以及Properties属性如何去注入等等。需要注意的是之下的实例代码为了简化使用了 lombok开源工具。","text":"自学Spring框架第二天，今天主要是更加深入的学习了Spring Bean的配置方式（XML形式的）使用方式以及一些注意的点。简而言之就是如何配置一个Bean，属性如何去注入？引用类型如何去注入？集合属性如何去注入，以及Properties属性如何去注入等等。需要注意的是之下的实例代码为了简化使用了 lombok开源工具。 普通属性注入方式下面总结的是一般的属性注入方式，普通类型以及引用类型，不包括集合类型，其分为三种，最后一种不常用，暂时没有总结。 属性名注入属性名注入的前提是对应Bean类属性值对应着setter方法，并且创建对象的方式必然通过无参构造方法，因此在Bean类必须保留无参构造方法。首先建立实体类 12345678910111213141516import lombok.Data;@Datapublic class Car &#123; private String brand; private String corp; private Double price; //无参构造器 public Car()&#123;&#125; public Car(String brand, String corp, Double price) &#123; this.brand = brand; this.corp = corp; this.price = price; &#125;&#125; 注入对应的XML: 123456789&lt;bean id=\"car1\" class=\"Car\"&gt; &lt;!--value在标签内部--&gt; &lt;property name=\"brand\" value=\"audi\"/&gt; &lt;!--value在标签外部--&gt; &lt;property name=\"price\"&gt; &lt;value&gt;2000&lt;/value&gt; &lt;/property&gt; &lt;property name=\"corp\" value=\"my\"/&gt;&lt;/bean&gt; 使用property标签注入，并且value字段可以放在外面也可以放在属性的位置上，由于是在XML中写对应的属性值，因此需要注意如果写特殊字符应该使用&lt;!CDATA[..]]&gt;的方式来引用，例如 123&lt;property name=\"brand\"&gt; &lt;value&gt;&lt;![CDATA[&lt;AUDI&gt;]]&gt;&lt;/value&gt;&lt;/property&gt; 最后的输出为： Car(brand=&lt;AUDI&gt;, corp=my, price=2000.0) 如果需要注入一个引用,使用ref来引用id即可注入,首先创建一个需要注入引用的类 12345import lombok.Data;public @Data class User &#123; private Car car; private String name;&#125; XML相关配置1234&lt;bean id=\"user\" class=\"User\"&gt; &lt;property name=\"car\" ref=\"car1\"/&gt; &lt;property name=\"name\" value=\"maoxin\"/&gt;&lt;/bean&gt; 打印输出： User(car=Car(brand=&lt;AUDI&gt;, corp=my, price=2000.0), name=maoxin) 如果不想引用的话，可以创建内部Bean： 12345678910&lt;bean id=\"user\" class=\"User\"&gt; &lt;property name=\"car\" &gt; &lt;bean class=\"Car\"&gt; &lt;property name=\"corp\" value=\"corp\"/&gt; &lt;property name=\"price\" value=\"200\"/&gt; &lt;property name=\"brand\" value=\"audi\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=\"name\" value=\"maoxin\"/&gt;&lt;/bean&gt; 打印输出： User(car=Car(brand=audi, corp=corp, price=200.0), name=maoxin) 构造方法注入构造方法注入方式关注的是构造函数，而识别构造函数的关键是参数的类型，这也是识别重载的关键，因此使用构造方法注入对应的标签有type属性，同时也有index属性来指明位置，这里列一个两者同时使用的例子。 12345&lt;bean id=\"new_car\" class=\"Car\"&gt; &lt;constructor-arg index=\"0\" type=\"java.lang.String\" value=\"brand\"/&gt; &lt;constructor-arg index=\"1\" type=\"java.lang.String\" value=\"corp\"/&gt; &lt;constructor-arg index=\"2\" type=\"java.lang.Double\" value=\"12.00\"/&gt;&lt;/bean&gt; 当然也可以其在注入引用类型的时候也可以使用ref也可以使用内部Beans 工厂方法注入待续.. 集合属性的赋值在Spring中对集合类型的赋值有一系列标签的支持，在这里将User类修改以做一下的Demo。 123456public @Data class User &#123; private Properties info; private Map&lt;Integer,String&gt; maps; private List&lt;Car&gt; cars; private String name;&#125; List填充cars 需要指定&lt;list&gt; 标签, 在标签里包含一些元素. 这些标签可以通过 &lt;value&gt; 指定简单的常量值, 通过&lt;ref&gt;指定对其他 Bean 的引用. 通过&lt;bean&gt; 指定内置 Bean 定义. 通过&lt;null/&gt; 指定空元素. 甚至可以内嵌其他集合. 12345678910111213&lt;bean id=\"new_user\" class=\"User\"&gt; &lt;property name=\"name\" value=\"maoxin\"/&gt; &lt;property name=\"cars\"&gt; &lt;list&gt; &lt;ref bean=\"car1\"/&gt; &lt;bean class=\"Car\"&gt; &lt;property name=\"brand\" value=\"A\"/&gt; &lt;property name=\"price\" value=\"20\"/&gt; &lt;property name=\"corp\" value=\"B\"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; MapMap的概念包含Entry、Key和Value，其均对应着标签或者属性 1234567&lt;property name=\"maps\"&gt; &lt;map&gt; &lt;entry key=\"1\" value=\"one\"/&gt; &lt;entry key=\"2\" value=\"two\"/&gt; &lt;entry key=\"3\" value=\"three\"/&gt; &lt;/map&gt;&lt;/property&gt; Prop1234567&lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"name\"&gt;maoxin&lt;/prop&gt; &lt;prop key=\"password\"&gt;xxx&lt;/prop&gt; &lt;prop key=\"xxx\"&gt;xxx&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 集合信息的外部配置之前集合的配置都是在内部实现了，现在配置独立的集合对象，使用util标签，其他都差不多 123&lt;util:list id=\"mycars\"&gt; &lt;ref bean=\"car1\"/&gt;&lt;/util:list&gt; Spring 的IOC容器简介在使用Spring读取Bean之前必须先实例化Spring IOC容器，而Spring 提供了两种类型的IOC容器的实现 Bean Factory IOC容器的基本实现，面向Spring本身 Application Context 提供了更多的高级特性，面向使用Spring框架的开发者 而ApplicationContext也有具体的实现，最常用的是ClassPathXmlApplicationContext以及FileSystemXmlApplicationContext","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Spring框架学习","slug":"Spring框架学习","permalink":"http://www.maoxin.site/tags/Spring框架学习/"}]},{"title":"Spring HelloWorld","slug":"Spring-01","date":"2018-11-07T01:03:27.000Z","updated":"2018-11-07T01:43:31.159Z","comments":true,"path":"2018/11/07/Spring-01/","link":"","permalink":"http://www.maoxin.site/2018/11/07/Spring-01/","excerpt":"自学Spring第一天，主要目的是使用Spring中的Beans完成依赖注入或者叫做控制反转，之后对所学的内容做一个总结。","text":"自学Spring第一天，主要目的是使用Spring中的Beans完成依赖注入或者叫做控制反转，之后对所学的内容做一个总结。 安装Spring与HelloWorld下载Spring 项目本身托管到Github上，官方首页有通往Github的链接，但是这里提供更为方便的方式去获取Spring相关的jar包https://repo.spring.io/webapp/#/home 将jar包添加到目录 其中commons-logging.jar需要另外下载 HelloWorld建立一个简单的Bean12345678910public class HelloWorld &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public void sayHello()&#123; System.out.println(\"Hello:\"+name); &#125;&#125; 配置Spring Bean容器配置文件12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloWorld\" class=\"HelloWorld\"&gt; &lt;property name=\"name\" value=\"Spring\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 需要注意的是IDEA添加的方式是src上右键-&gt;XMLConfigurationFile-&gt;SpringConfig 实现IOC12345678910public class Main &#123; public static void main(String[] args) &#123; //交给Spring完成，依赖于Spring的Beans容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"appclicationContext.xml\"); HelloWorld helloWorld = (HelloWorld) ctx.getBean(\"helloWorld\"); helloWorld.sayHello(); &#125;&#125; 对于依赖处理方式的演变分类接口与实现 这种方式虽用面向对象的处理方式，抽象出接口，并有其不同的实现类，但是导致依赖于其接口的业务类太过复杂,图中Report Service需要与三个组件打交道 工厂模式的引入 引入工厂模式，加入了中间层，由工厂去管理依赖，而Report直接依赖与工厂，这样大大简化了阶段一Report Service的职责，由工厂保证是否是单例等等，依赖变少，组织结构变得更加清晰 IOC方式的引入 由之前需要什么找工厂去“生产”到需要什么让管理器去注入，容器管理对象的完整声明周期。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Spring框架学习","slug":"Spring框架学习","permalink":"http://www.maoxin.site/tags/Spring框架学习/"}]},{"title":"CORS跨域问题的认识与解决","slug":"HTTP-02","date":"2018-11-04T07:01:00.000Z","updated":"2018-11-04T08:42:28.677Z","comments":true,"path":"2018/11/04/HTTP-02/","link":"","permalink":"http://www.maoxin.site/2018/11/04/HTTP-02/","excerpt":"之前曾经见过跨域问题的解决方式，一个是CORS，一个是JSONP，但是就是处于知其然，不知其所以然的阶段，因此在这里借助网上资料和Node.js来分析和解决如上问题","text":"之前曾经见过跨域问题的解决方式，一个是CORS，一个是JSONP，但是就是处于知其然，不知其所以然的阶段，因此在这里借助网上资料和Node.js来分析和解决如上问题 CORS除去一些常用标签的src，image以及link等属性是可以进行跨域的，一般的其他请求尤其是json请求是不能进行跨域的，否则会出现问题，按照如下方式初始化node.js代码，进行跨域测试： Server.js 12345678const http = require('http')http.createServer(function(request,response)&#123; console.log(\"get request form\",request.url) response.end(\"HelloWorld\")&#125;).listen(8888)console.log(\"Server listening on 8887\") Server2.js 1234567891011121314const http = require('http')const fs = require('fs')http.createServer(function(request,responce)&#123; console.log(\"Server2 request form\",request.url) const html = fs.readFileSync('test.html',\"utf-8\") responce.writeHead(200,&#123; 'Content-Type':'text/html' &#125;) responce.end(html)&#125;).listen(8889)console.log(\"Server 2 Listening...\") 在Server2.js中无论请求如何都会返回一个html页面，该页面主要包含如下请求代码 html中的js 123var xhr = new XMLHttpRequest();xhr.open('GET','http://127.0.0.1:8888/');xhr.send(); 向服务器2进行Http请求控制台信息如图所示 可见，其提示No Access-Control-Allow-Origin ,表示没有Access-Control-Allow-Origin头部信息，无法访问资源 我们修改服务器添加头信息为Access-Control-Allow-Origin:*在Server1中添加如下代码： 123response.writeHead(200,&#123; 'Access-Control-Allow-Origin':'*' &#125;) 之后就不会报错了，打开控制台的NetWork栏，可以查看到”HelloWorld”字符串 JSONP由于浏览器允许如文章开始描述的在标签内部访问，所以就可以实现跨域，这也是JSONP的原理，而只要服务器返回的信息满足json这样可以被js原生支持，客户端就会很容易的去处理，在这里我们模拟一种JSONP的方式返回信息 修改Server1的代码为： 1response.end('&#123;\"result\":2018&#125;') 查看浏览器NetWork，发现返回成功 CORS跨域的限制不是只要设置了Access-Control-Allow-Origin头部就可以随意跨域了 允许方法 GET HEAD POST 允许的Content-Type text/plain multipart/form-data application/x-www-form-urlencoded 请求头。。 预请求之上描述了CORS种种限制，如果想要使用自定义头或者其他Method，浏览器采用了预请求的方式，先发送一个Method=OPTION的请求，根据返回的头信息来判断请求是否合法，而服务器返回如下字段来判断1234'Access-Control-Allow-Origin':'*','Access-Control-Allow-Headers':'X-Test-Cors','Access-Control-Allow-Method':'POST,PUT,DElete','Access-Control-Max-Age':'1000'//代表1000s之内不用发送预请求 练习代码地址 https://gitee.com/lumaoxin/DemoHouse/tree/master/CORS","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.maoxin.site/categories/计算机网络/"}],"tags":[{"name":"HTTP协议","slug":"HTTP协议","permalink":"http://www.maoxin.site/tags/HTTP协议/"}]},{"title":"HTTP协议的三次握手","slug":"HTTP-01","date":"2018-11-04T06:36:31.000Z","updated":"2018-11-04T06:55:48.330Z","comments":true,"path":"2018/11/04/HTTP-01/","link":"","permalink":"http://www.maoxin.site/2018/11/04/HTTP-01/","excerpt":"HTTP协议是基于TCP的，一个TCP请求可以传送多个请求，在HTTP0.9/1.0中，连接建立，请求发送得到响应之后，HTTP链接就被关闭了。而在HTTP/1.1中链接会得到一定的保持（长链接),之所以会有这样的改进是因为创建链接的开销太大，需要三次握手（TCP的三次握手）","text":"HTTP协议是基于TCP的，一个TCP请求可以传送多个请求，在HTTP0.9/1.0中，连接建立，请求发送得到响应之后，HTTP链接就被关闭了。而在HTTP/1.1中链接会得到一定的保持（长链接),之所以会有这样的改进是因为创建链接的开销太大，需要三次握手（TCP的三次握手） 为什么需要三次握手？ Client发出请求，传递到服务器（此时客户端不知道Server能否联通） Server得到了请求，向Client发出一个确认，此时服务器不知道Client能否收到数据 客户端收到请求之后，知道Client和Server通信没问题，问题是Server不知道自己的信送到了没？所以Client再次发送一个确认包。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.maoxin.site/categories/计算机网络/"}],"tags":[{"name":"HTTP协议","slug":"HTTP协议","permalink":"http://www.maoxin.site/tags/HTTP协议/"}]},{"title":"7种方式去重构Java的Switch语句","slug":"design-1","date":"2018-10-27T03:18:25.000Z","updated":"2018-11-01T09:26:54.627Z","comments":true,"path":"2018/10/27/design-1/","link":"","permalink":"http://www.maoxin.site/2018/10/27/design-1/","excerpt":"自己翻译的，英语渣，其实看代码意思就都能理解，这里放上原网址","text":"自己翻译的，英语渣，其实看代码意思就都能理解，这里放上原网址 https://www.developer.com/java/data/seven-ways-to-refactor-java-switch-statements.html 1.通过Java的枚举实现策略模式一个典型的例子涉及到一个Java的枚举，并且在枚举的基础上有一个或者多个switch语句，让我们假设有如下简单的Java枚举，代表不同的运动员类型123public enum PlayerTypes &#123; TENNIS,FOOTBALL,SNOOKER&#125; 下面的switch语句用来创建不同类型的“运动员”12345678910111213141516public class PlayerCreator &#123; public Player createPlayer(PlayerTypes playerType)&#123; switch (playerType) &#123; case TENNIS: return new TennisPlayer(); case FOOTBALL: return new FootballPlayer(); case SNOOKER: return new SnookerPlayer(); default: throw new IllegalArgumentException(\"Invalid player type: \" + playerType); &#125; &#125;&#125; 想要创建网球运动员，就使用PlayerTypes.TENNIS:123PlayerCreator playerCreator = new PlayerCreator();Player tennisPlayer = playerCreator.createPlayer(PlayerTypes.TENNIS); 依赖使用常量特定方法实现的枚举但是，这里有一种更好的方式去将每个枚举常量本身和其行为联系在一起，这种方式被称为：具有常量特定方法实现的枚举类型（enum type with constant-specific method implementation）并且它在Joshua Bloch的《Effective Java 第二版》中被描述。遵循着这一思想，我们可以通过增加一个抽象的方法来丰富我们的playertypes枚举类，而对于枚举类中的每个值，我们提供一个实现，如下:123456789101112131415161718192021public enum PlayerTypes &#123; TENNIS &#123; @Override public Player createPlayer() &#123; return new TennisPlayer(); &#125;&#125;,FOOTBALL &#123; @Override public Player createPlayer() &#123; return new FootballPlayer(); &#125;&#125;,SNOOKER &#123; @Override public Player createPlayer() &#123; return new SnookerPlayer(); &#125; &#125;; public abstract Player createPlayer();&#125; 如果想要创建一个足球运动员,使用PlayersType.FOOTBLL12Player footballPlayer = PlayerTypes.valueOf(\"FOOTBALL\").createPlayer(); 2.实现命令模式现在，让我们写一个同样的switch逻辑，但是是基于字符串类型的，在Java 7及以上，我们是可以使用一个字符串对象放在switch语句中，毕竟，大多数的Java编译器将会针对这种实现方式生成比类似if-else-if链更加高效的字节码，当然，这并不是太坏:),但是，一个siwtch仍然使得类与类之间的关系错综复杂，并且缺点也是一样的1234567891011121314151617public class PlayerCreator &#123; public Player createPlayer(String playerType) &#123; switch (playerType) &#123; case \"TENNIS\": return new TennisPlayer(); case \"FOOTBALL\": return new FootballPlayer(); case \"SNOOKER\": return new SnookerPlayer(); default: throw new IllegalArgumentException (\"Invalid player type: \" + playerType); &#125; &#125;&#125; 创建一个网球运动员只需要一个“TENNIS”12PlayerCreator playerCreator = new PlayerCreator();Player tennisPlayer = playerCreator.createPlayer(\"TENNIS\"); 实现命令模式另外，我们可以依赖“命令”模式，我们可以通过两步来构建命令模式，首先，我们定义一个接口：123public interface Command &#123; Player create();&#125; 接着，我们为每个运动员类型类型提供对应该接口的具体实现12345678910111213141516171819202122232425262728293031323334353637public class CreatePlayerCommand &#123; private static final Map&lt;String, Command&gt; PLAYERS; static &#123; final Map&lt;String, Command&gt; players = new HashMap&lt;&gt;(); players.put(\"TENNIS\", new Command() &#123; @Override public Player create() &#123; return new TennisPlayer(); &#125; &#125;); players.put(\"FOOTBALL\", new Command() &#123; @Override public Player create() &#123; return new FootballPlayer(); &#125; &#125;); players.put(\"SNOOKER\", new Command() &#123; @Override public Player create() &#123; return new SnookerPlayer(); &#125; &#125;); PLAYERS = Collections.unmodifiableMap(players); &#125; public Player createPlayer(String playerType) &#123; Command command = PLAYERS.get(playerType); if (command == null) &#123; throw new IllegalArgumentException(\"Invalid player type: \" + playerType); &#125; return command.create(); &#125;&#125; 这样，创建一个斯诺克运动员12CreatePlayerCommand createCommand = new CreatePlayerCommand();Player snookerPlayer = createCommand.createPlayer(\"SNOOKER\"); 3.使用Java8以及之后版本的Supplier接口将Switch语句的内容转换为一个Map类型是一种常用方法，这个想法的关键是将每一个case分支作为Map的值并且使用case的条件作为key，在Java 8以及之后的版本，我们可以充分利用Supplier和构造器引用，因此，让我们创建一个Map通过使用类的名字和关键字new一个构造器的引用：123456789101112131415161718192021222324public class PlayerSupplier &#123; private static final Map&lt;String, Supplier&lt;Player&gt;&gt; PLAYER_SUPPLIER; static &#123; final Map&lt;String, Supplier&lt;Player&gt;&gt; players = new HashMap&lt;&gt;(); players.put(\"TENNIS\", TennisPlayer::new); players.put(\"FOOTBALL\", FootballPlayer::new); players.put(\"SNOOKER\", SnookerPlayer::new); PLAYER_SUPPLIER = Collections.unmodifiableMap(players); &#125; public Player supplyPlayer(String playerType) &#123; Supplier&lt;Player&gt; player = PLAYER_SUPPLIER.get(playerType); if (player == null) &#123; throw new IllegalArgumentException(\"Invalid player type: \" + playerType); &#125; return player.get(); &#125;&#125; 这样创建一个斯诺克运动员：12PlayerSupplier playerSupplier = new PlayerSupplier();Player snookerPlayer = playerSupplier.supplyPlayer(\"SNOOKER\"); 4.定义一个通用的函数式接口与第三点几乎相似的实现如下12345678910111213141516171819202122232425public final class ComputeTennisPlayerStatistics &#123; private ComputeTennisPlayerStatistics() &#123; throw new AssertionError(); &#125; public static String computeTrend(TennisPlayer tennisPlayer, Period period, String owner, String trend) &#123; switch (trend) &#123; case \"SERVE\": return Statistics.computeServeTrend(tennisPlayer, period, owner); case \"FOREHAND\": return Statistics.computeForehandTrend(tennisPlayer, period, owner); case \"BACKHAND\": return Statistics.computeBackhandTrend(tennisPlayer, period, owner); default: throw new IllegalArgumentException (\"Invalid trend attribute: \" + trend); &#125; &#125;&#125; 得到SERVE趋势(我们使用了伪参数，在这里他们并不相关):123String serveTrend = ComputeTennisPlayerStatistics.computeTrend(new TennisPlayer(), Period.ZERO, \"TENNIS MAGAZINE\", \"SERVE\"); 实现 TriFunction 接口这次，每个case语句执行一个接受三个参数的静态方法并且返回一个字符串类型，在这样的情况下，一个Supplier不能使用，因为我们有多于两个参数，我们不能使用BiFunction,在这里有一个方法将会通过我们定义自己的函数式接口，之后和我们之前使用Map一样1234567891011121314151617181920212223242526272829303132333435@FunctionalInterfacepublic interface TriFunction&lt;T, U, V, R&gt; &#123; R apply(T t, U u, V v);&#125;public final class FunctionalStatistics &#123; private FunctionalStatistics() &#123; throw new AssertionError(); &#125; private static final Map&lt;String, TriFunction&lt;TennisPlayer, Period, String, String&gt;&gt; STATISTICS = new HashMap&lt;&gt;(); static &#123; STATISTICS.put(\"SERVE\", Statistics::computeServeTrend); STATISTICS.put(\"FOREHAND\", Statistics::computeForehandTrend); STATISTICS.put(\"BACKHAND\", Statistics::computeBackhandTrend); &#125; public static String computeTrend(TennisPlayer tennisPlayer, Period period, String owner, String trend) &#123; TriFunction&lt;TennisPlayer, Period, String, String&gt; function = STATISTICS.get(trend); if (function == null) &#123; throw new IllegalArgumentException(\"Invalid trend type: \" + trend); &#125; return function.apply(tennisPlayer, period, owner); &#125;&#125; 得到 FOREHAND 趋势 (我们使用了伪参数，在这里他们并不相关):123String forehandTrend = FunctionalStatistics.computeTrend(new TennisPlayer(), Period.ZERO, \"SPORT TV\", \"FOREHAND\"); 5. 依赖抽象工厂在这个小结，我们将会遵循Robert C. Martin的代码整洁之道的相关内容，我们以一个可以通过抽象工厂设计模式来隐藏的switch开始1234567891011121314151617181920212223242526272829303132333435363738394041public class ClassicPlayer &#123; private final Type type; private final int delta; public ClassicPlayer(Type type, int delta) &#123; this.type = type; this.delta = delta; &#125; public Type getType() &#123; return type; &#125; public int getDelta() &#123; return delta; &#125;&#125;public class Statistics &#123; public int playerEndurance(ClassicPlayer player) &#123; int delta = player.getDelta(); switch (player.getType()) &#123; case TENNIS: return ComputeEnduranceAlgorithm.basicEndurance(delta) + ComputeEnduranceAlgorithm.hardEndurance(delta); case FOOTBALL: return ComputeEnduranceAlgorithm.hardEndurance(delta) * ComputeEnduranceAlgorithm.factorEndurance(delta); case SNOOKER: return ComputeEnduranceAlgorithm.basicEndurance(delta); default: throw new IllegalArgumentException (\"Invalid player type: \" + player.getType()); &#125; &#125;&#125; 计算一个网球运动员的耐力如下：1234Statistics statistics = new Statistics();ClassicPlayer player = new ClassicPlayer(Type.TENNIS, 54);int tennisPlayerEndurance = statistics.playerEndurance(player); 当然，这是一个混乱的实现，想象一下你需要去添加另外一个方法去计算一个运动员的反应速度，这将需要另外一个switch语句，也许你将在每个case分支中嵌套更多的if并且重命名之前的方法名类似playerStatistics,每次一个新的方法将被增加，代码就需要进行相应的调整 实现抽象工厂模式我们可以重写这个代码通过使用多态性性并且和一个抽象工厂方法的实线，首先，我们删除ClasssicPlayer类并且创建一个抽象类player如下：12345678910111213141516171819202122public abstract class Player &#123; private final Type type; private final int delta; public Player(Type type, int delta) &#123; this.type = type; this.delta = delta; &#125; public Type getType() &#123; return type; &#125; public int getDelta() &#123; return delta; &#125; public abstract int playerEndurance(); // More similar methods&#125; 现在我们可以实现一个足球,网球，和斯诺克等运动员类，比如，一个斯诺克运动员类如下：123456789101112public class SnookerPlayer extends Player &#123; public SnookerPlayer(Type type, int delta) &#123; super(type, delta); &#125; @Override public int playerEndurance() &#123; return ComputeEnduranceAlgorithm.basicEndurance (this.getDelta()); &#125;&#125; 更进一步，我们创建一个运动员工厂(AbstractPlayerFactory)接口：123public interface AbstractPlayerFactory &#123; public Player createPlayer(Type type, int delta);&#125; 最终，我们将switch的实现埋在这个接口的实现12345678910111213141516171819public class PlayerFactory implements AbstractPlayerFactory &#123; @Override public Player createPlayer(Type type, int delta) &#123; switch (type) &#123; case TENNIS: return new TennisPlayer(type, delta); case FOOTBALL: return new FootballPlayer(type, delta); case SNOOKER: return new SnookerPlayer(type, delta); default: throw new IllegalArgumentException(\"Invalid player type: \" + type); &#125; &#125;&#125; 计算一个斯诺克运动员的耐力123PlayerFactory playerFactory = new PlayerFactory();Player snookerPlayer = playerFactory.createPlayer(Type.SNOOKER, 8);int snookerPlayerEndurance = snookerPlayer.playerEndurance(); 或者，我们可以直接初始化一个正确的Player类，而完全不使用Switch12SnookerPlayer snookerPlayer = new SnookerPlayer(7);int snookerPlayerEndurance = snookerPlayer.playerEndurance(); 6.实现状态模式让我们假设我们有如下两个相互依存的switch12345678910111213141516171819202122232425public class ClassicPlayer &#123; private int state; public void register() &#123; switch (state) &#123; case 0: state = 1; System.out.println(\"Registering ...\"); break; default: System.out.println(\"Aready Registered ...\"); &#125; &#125; public void unregister() &#123; switch (state) &#123; case 1: state = 0; System.out.println(\"Un-registering ...\"); break; default: System.out.println(\"Aready Unregistered ...\"); &#125; &#125;&#125; 简而言之，在这个例子中，我们只有两个相互依存的switch结构，并且我们可以调用他们按照如下方式:12345ClassicPlayer classicPlayer = new ClassicPlayer();classicPlayer.register();classicPlayer.unregister();// Causes \"Already Unregistered ...\" messageclassicPlayer.unregister(); 实现状态模式跟进一步，让我们应用状态模式去消除这些switch语句，我们首先创建一个接口为我们的状态定义一些方法（动作）接口，registerandunregister: 1234public interface PlayerState &#123; void register(); void unregister();&#125; 接下来，我们定义一个Player类来实现PlayerState接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Player implements PlayerState &#123; private PlayerState registered; private PlayerState unregistered; private PlayerState state; public Player() &#123; this.registered = new PlayerRegister(this); this.unregistered = new PlayerUnregister(this); this.state = this.unregistered; &#125; @Override public void register() &#123; state.register(); &#125; @Override public void unregister() &#123; state.unregister(); &#125; //以下为Registered、unregistered、state的getter和setter public PlayerState getRegistered() &#123; return registered; &#125; public void setRegistered(PlayerState registered) &#123; this.registered = registered; &#125; public PlayerState getUnregistered() &#123; return unregistered; &#125; public void setUnregistered(PlayerState unregistered) &#123; this.unregistered = unregistered; &#125; public PlayerState getState() &#123; return state; &#125; public void setState(PlayerState state) &#123; this.state = state; &#125;&#125; PlayerRegister和PlayerUnregister的代码列举在下面 1234567891011121314151617181920212223242526272829303132333435363738394041public class PlayerRegister implements PlayerState &#123; private final Player player; public PlayerRegister(Player player) &#123; this.player = player; &#125; @Override public void register() &#123; System.out.println(\"Already Registered ...\"); &#125; @Override public void unregister() &#123; System.out.println(\"Unregistering ...\"); player.setState(player.getUnregistered()); &#125;&#125;public class PlayerUnregister implements PlayerState &#123; private final Player player; public PlayerUnregister(Player player) &#123; this.player = player; &#125; @Override public void register() &#123; System.out.println(\"Registering ...\"); player.setState(player.getRegistered()); &#125; @Override public void unregister() &#123; System.out.println(\"Already Unregistered ...\"); &#125;&#125; 现在，我们可以创建一个Player并且完成如下状态的切换 12345Player player = new Player();player.register();player.unregister();// Causes an \"Already Unregistered ...\" messageplayer.unregister(); 7. 通过Predicate来实现在最后一个例子中，让我们假设在switch语句中的每个case包含多个if分支，如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PlayerCreator &#123; public Player createPlayer(String playerType, int rank) &#123; switch (playerType) &#123; case \"TENNIS\": if (rank == 1) &#123; return new TennisPlayer(\"Rafael Nadal\"); &#125; if (rank &gt; 1 &amp;&amp; rank &lt; 5) &#123; return new TennisPlayer(\"Roger Federer\"); &#125; if (rank &gt;= 5 &amp;&amp; rank &lt;= 10) &#123; return new TennisPlayer(\"Andy Murray\"); &#125; case \"FOOTBALL\": if (rank == 1 || rank == 2) &#123; return new FootballPlayer(\"Lionel Messi\"); &#125; if (rank &gt; 2 &amp;&amp; rank &lt;= 10) &#123; return new FootballPlayer(\"Cristiano Ronaldo\"); &#125; case \"SNOOKER\": if (rank == 1) &#123; return new SnookerPlayer(\"Ronnie O'Sullivan\"); &#125; if (rank == 2) &#123; return new SnookerPlayer(\"Mark Selby\"); &#125; if (rank &gt; 3 &amp;&amp; rank &lt; 7) &#123; return new SnookerPlayer(\"John Higgins\"); &#125; if (rank &gt;= 7 &amp;&amp; rank &lt;= 10) &#123; return new SnookerPlayer(\"Neil Robertson\"); &#125; default: throw new IllegalArgumentException (\"Invalid player type: \" + playerType); &#125; &#125;&#125; 获得一个输出: Tennis player: Andy Murray: 12PlayerCreator playerCreator = new PlayerCreator();Player tennisPlayer = playerCreator.createPlayer(\"TENNIS\", 5); 如果我们假设if语句可以被视作是Predicate&lt;Integer&gt;我们可以重写这个工具类，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public final class PlayerSupplier &#123; private PlayerSupplier() &#123; throw new AssertionError(); &#125; private static final Map&lt;String, Map&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt;&gt; PLAYER_CREATOR; static &#123; final Map&lt;String, Map&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt;&gt; playerCreator = new HashMap&lt;&gt;(); final Map&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt; tennisPlayers = new HashMap&lt;&gt;(); tennisPlayers.put(rank -&gt; rank == 1, () -&gt; new TennisPlayer(\"Rafael Nadal\")); tennisPlayers.put(rank -&gt; rank &gt; 1 &amp;&amp; rank &lt; 5, () -&gt; new TennisPlayer(\"Roger Federer\")); tennisPlayers.put(rank -&gt; rank &gt;= 5 &amp;&amp; rank &lt;= 10, () -&gt; new TennisPlayer(\"Andy Murray\")); final Map&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt; footballPlayers = new HashMap&lt;&gt;(); footballPlayers.put(rank -&gt; rank == 1 || rank == 2,()-&gt; new TennisPlayer(\"Lionel Messsi\")); footballPlayers.put(rank -&gt; rank &gt; 2 &amp;&amp; rank &lt;= 10,()-&gt; new TennisPlayer(\"Cristiano Ronaldo\")); final Map&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt; snookerPlayers = new HashMap&lt;&gt;(); snookerPlayers.put(rank -&gt; rank == 1, () -&gt; new TennisPlayer(\"Ronnie O'Sullivan\")); snookerPlayers.put(rank -&gt; rank == 2, () -&gt; new TennisPlayer(\"Mark Selby\")); snookerPlayers.put(rank -&gt; rank &gt; 3 &amp;&amp; rank &lt; 7, () -&gt; new TennisPlayer(\"John Higgins\")); snookerPlayers.put(rank -&gt; rank &gt;= 7 &amp;&amp; rank &lt;= 10, () -&gt; new TennisPlayer(\"Neil Robertson\")); playerCreator.put(\"TENNIS\", tennisPlayers); playerCreator.put(\"FOOTBALL\", footballPlayers); playerCreator.put(\"SNOOKER\", snookerPlayers); PLAYER_CREATOR = Collections.unmodifiableMap(playerCreator); &#125; public static final Player supplyPlayer(String playerType, int rank) &#123; if (rank &lt; 1 || rank &gt; 10) &#123; throw new IllegalArgumentException(\"Invalid rank: \" + rank); &#125; if (!PLAYER_CREATOR.containsKey(playerType)) &#123; throw new IllegalArgumentException(\"Invalid player type: \" + playerType); &#125; Map&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt; players = PLAYER_CREATOR.get(playerType); for (Entry&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt; entry : players.entrySet()) &#123; if (entry.getKey().test(rank)) &#123; return entry.getValue().get(); &#125; &#125; throw new IllegalStateException(\"The players map is corrupted\"); &#125;&#125; 如下的使用方式可以获取到 Football player: Cristiano Ronaldo 1Player footballPlayer = PlayerSupplier.supplyPlayer(\"FOOTBALL\", 6); 其他方法可以使用枚举来构成，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public enum PlayerTypes &#123; TENNIS(Collections.unmodifiableList(Arrays.asList( () -&gt; new TennisPlayer(\"Rafael Nadal\"), () -&gt; new TennisPlayer(\"Roger Federer\"), () -&gt; new TennisPlayer(\"Andy Murray\")) ), Collections.unmodifiableList(Arrays.asList( rank -&gt; rank == 1, rank -&gt; rank &gt; 1 &amp;&amp; rank &lt; 5, rank -&gt; rank &gt;= 5 &amp;&amp; rank &lt;= 10)) ), FOOTBALL(Collections.unmodifiableList(Arrays.asList( () -&gt; new FootballPlayer(\"Lionel Messi\"), () -&gt; new FootballPlayer(\"Cristiano Ronaldo\")) ), Collections.unmodifiableList(Arrays.asList( rank -&gt; rank == 1 || rank == 2, rank -&gt; rank &gt; 2 &amp;&amp; rank &lt;= 10)) ), SNOOKER(Collections.unmodifiableList(Arrays.asList( () -&gt; new SnookerPlayer(\"Ronnie O'Sullivan\"), () -&gt; new SnookerPlayer(\"Mark Selby\"), () -&gt; new SnookerPlayer(\"John Higgins\"), () -&gt; new SnookerPlayer(\"Neil Robertson\")) ), Collections.unmodifiableList(Arrays.asList( rank -&gt; rank == 1, rank -&gt; rank == 2, rank -&gt; rank &gt; 3 &amp;&amp; rank &lt; 7, rank -&gt; rank &gt;= 7 &amp;&amp; rank &lt;= 10)) ); private final List&lt;Supplier&lt;Player&gt;&gt; names; private final List&lt;Predicate&lt;Integer&gt;&gt; conditions; private PlayerTypes(List&lt;Supplier&lt;Player&gt;&gt; names, List&lt;Predicate&lt;Integer&gt;&gt; conditions) &#123; this.names = names; this.conditions = conditions; &#125; public static final Player supplyPlayer(String playerType, int rank) &#123; if (rank &lt; 1 || rank &gt; 10) &#123; throw new IllegalArgumentException(\"Invalid rank: \" + rank); &#125; List&lt;Predicate&lt;Integer&gt;&gt; selectors = PlayerTypes.valueOf(playerType).conditions; for (int i = 0; i &lt; selectors.size(); i++) &#123; if (selectors.get(i).test(rank)) &#123; return PlayerTypes.valueOf(playerType) .names.get(i).get(); &#125; &#125; throw new IllegalStateException(\"The enum is corrupted\"); &#125;&#125; 得到如下输出:Snooker player: Neil Robertson: 1Player snookerPlayer = PlayerTypes.supplyPlayer(\"SNOOKER\", 10); 总结在这篇文章中，你看到了七种方法去解决switch结构，如下 用枚举的形式实现策略模式 实现命令模式 使用Java8 之后的 Supplier 定义一个通用的函数式接口 使用抽象工厂 实现状态模式 通过Predicate 个人总结几种方式都离不开表驱动，如何构成这张表，第一个枚举形式是将枚举值本身构成了表 命令模式是将表项抽象了一个接口”命令“来放到Map中构成表 之后包括Java8的函数式接口等等只是表的填充方式不同 抽象工厂还是以Switch来实现的，这个表只不过被抽象层压在下面，抽象工厂接口提供了工厂的统一访问方式，而具体类去实现这个接口，由工厂类去实现管理 状态模式适用于状态之间关系相互依赖，相对复杂，将依赖项揪出来，将依赖项的状态独立出来，依赖项影响的方法作为接口交给具体类去实现 最后一个通过Predicate感觉略有鸡肋。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.maoxin.site/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.maoxin.site/tags/设计模式/"}]},{"title":"NIO-Selector","slug":"NIO-02","date":"2018-10-13T11:50:28.000Z","updated":"2018-10-15T13:55:19.474Z","comments":true,"path":"2018/10/13/NIO-02/","link":"","permalink":"http://www.maoxin.site/2018/10/13/NIO-02/","excerpt":"","text":"此博客是对知乎海纳文章的理解与总结 引入多路复用的原因 服务器与客户端通信时，原来的场景需要大量的服务线程，连接时间很短，数据量发送很小，大量的服务线程使得竞争加剧，大量的开销会严重影响OS的效率 IO多路复用，可以解决线程切换的问题，可以同在很少的线程中管理多路IO 不是说IO多路复用效率一定高，要看具体场景，如果是两个对等机器之间建立了TCP连接，并且通过TCP连接来发送一个大文件，有大量的数据传输。在这种场景中，阻塞式的写法简单高效。 另外加深理解，需要明白一台服务器能创建的线程数是十分有限的，在Java中创建线程，一个线程默认就会预留1M的空间，那么1G的内存也不过只能支持1000个线程创建而已。Linux中的Poll什么是poll?poll系统调用让操作系统管理多个链接，监视其发生的事件，并 参考资料: https://zhuanlan.zhihu.com/p/27419141 海纳问题与实现: select poll epoll https://blog.csdn.net/davidsguo008/article/details/73556811","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/tags/Java/"}]},{"title":"NIO-Buffer","slug":"NIO-01","date":"2018-10-13T11:44:38.000Z","updated":"2018-11-04T08:57:09.766Z","comments":true,"path":"2018/10/13/NIO-01/","link":"","permalink":"http://www.maoxin.site/2018/10/13/NIO-01/","excerpt":"BufferBuffer实现了一个缓存区读写区域，通过四个”指针”的灵活运用，完成在缓冲区内部的读写变换","text":"BufferBuffer实现了一个缓存区读写区域，通过四个”指针”的灵活运用，完成在缓冲区内部的读写变换这四个指针分别是: Capacity 容量，在创建时就定下的，代指缓冲区容量 Limit 限制，指的是在读写两个操作中缓存区能操作的上界 Position 代指下一个要读写元素的位置 mark 一个标记，用于恢复到上一次读写位置从上面的描述很容易看出，Limit与position是有两个不同的语义的，在不同操作的情况下，其指向的位置必须做出改变： 在写操作时，position指向的是下一个要写的位置，limit与capacity相等，表示能写的极限 在读操作时，position会置为0,limit表示最多能读到的位置Buffer的操作存取数据put123456789101112//hb是字节数组的实体，ix函数用于计算偏移public ByteBuffer put(byte x) &#123; hb[ix(nextPutIndex())] = x; return this;&#125;//返回下标final int nextPutIndex() &#123; // package-private if (position &gt;= limit) throw new BufferOverflowException(); return position++;&#125; get123456789public byte get() &#123; return hb[ix(nextGetIndex())];&#125;final int nextGetIndex() &#123; // package-private if (position &gt;= limit) throw new BufferUnderflowException(); return position++;&#125; 调整指针位置的方法position12345678910public final Buffer position(int newPosition) &#123; //检查参数正确性 if ((newPosition &gt; limit) || (newPosition &lt; 0)) throw new IllegalArgumentException(); //设定新参数 position = newPosition; //如果标记在修改的位置之后则重置标记 if (mark &gt; position) mark = -1; return this;&#125; limit123456789//同理public final Buffer limit(int newLimit) &#123; if ((newLimit &gt; capacity) || (newLimit &lt; 0)) throw new IllegalArgumentException(); limit = newLimit; if (position &gt; limit) position = limit; if (mark &gt; limit) mark = -1; return this;&#125; filp 读写转换123456public final Buffer flip() &#123; limit = position; position = 0; mark = -1; return this;&#125; 注意，连续调用flip就会使得buffer的limit变成0，既不能读也不能写 mark与reset1234567891011public final Buffer mark() &#123; mark = position; return this;&#125;public final Buffer reset() &#123; int m = mark; if (m &lt; 0) throw new InvalidMarkException(); position = m; return this;&#125; 其他功能实现方法在Buffer抽象类中 clear 恢复到写模式，重新写123456public final Buffer clear() &#123; position = 0; limit = capacity; mark = -1; return this;&#125; rewind 重绕-不修改limit的值12345public final Buffer rewind() &#123; position = 0; mark = -1; return this;&#125; remaining1234//得到缓冲区剩下的字节数public final int remaining() &#123; return limit - position;&#125; isRemaining123public final boolean hasRemaining() &#123; return position &lt; limit;&#125; 堆外内存简而言之，分配一块Java不老动的内存区域，当在保存大量的数据我们只是用于IO操作或者说暂时不去处理的时候，GC操作的到来将这么大一块区域搬来搬去，是很耗时而没有意义的，当然，解决的方式就是分配一块堆外内存，这块区域JVM对其进行引用计数，如果没有引用了才进行回收 Zero-Copy 0拷贝","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"NIO","slug":"NIO","permalink":"http://www.maoxin.site/tags/NIO/"}]},{"title":"ES6异步编程","slug":"js-08","date":"2018-10-06T03:18:57.000Z","updated":"2018-10-06T06:39:34.474Z","comments":true,"path":"2018/10/06/js-08/","link":"","permalink":"http://www.maoxin.site/2018/10/06/js-08/","excerpt":"","text":"","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/tags/JavaScript/"}]},{"title":"ucore Lab1","slug":"ucore-Lab1","date":"2018-10-03T14:46:42.000Z","updated":"2018-11-01T09:33:51.294Z","comments":true,"path":"2018/10/03/ucore-Lab1/","link":"","permalink":"http://www.maoxin.site/2018/10/03/ucore-Lab1/","excerpt":"操作系统实验报告","text":"操作系统实验报告 实验1: bootloader的启动练习1要求： 操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果) 一个被认为是符合规范的硬盘主引导扇区的特征是什么？实验过程: 在构建过程中使用make V=来查看具体执行过程，具体执行过程如下 123456789101112131415161718192021222324252627282930# 以下均为将各个文件编译为目标文件+ cc kern/init/init.c //编译 init.c+ kern/libs/readline.c //编译 readline.c+ cc kern/libs/stdio.c //编译 stdio.c+ cc kern/debug/kdebug.c//编译 kdebug.c + cc kern/debug/kmonitor.c //编译 kmonitor+ cc kern/debug/panic.c//编译 panic.c+ cc kern/driver/clock.c //编译 clock.c+ cc kern/driver/console.c //编译 console.c+ cc kern/driver/intr.c//编译 intr.c+ cc kern/driver/picirq.c //编译 picirq.c+ cc kern/trap/trap.c //编译 trap.c+ cc kern/trap/trapentry.S //编译 trapentry.S+ cc kern/trap/vectors.S //编译 vector.S+ cc kern/mm/pmm.c//编译 pmm.c+ cc libs/printfmt.c // printgmt.c+ cc libs/string.c //编译 string.c+ ld bin/kernel//接下来用ld合并目标文件(object) 和 库文件(archive),生成kernel程序+ cc boot/bootasm.S //编译 bootasm.S+ cc boot/bootmain.c //编译 bootmain.c+ cc tools/sign.c //编译 sign.c# 以上执行过程均附加了gcc参数如下,以第一行init.c为例gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o# gcc -I 指明包含路径名称 -fno-builtin表明不使用内建函数 -Wall开启所有警告 -ggdb生成GDB调试信息 -gstabs此选项以stabs格式声称调试信息,但是不包括gdb调试信息，-m32生成32位机器的汇编代码 -nostdincgcc编译的时候不要在标准系统目录中找头文件 -fnostack-protector 不启用溢出检测机制 + ld bin/bootblock //链接生成block文件//最后将bootloader放入虚拟硬盘ucore.img中去。dd if=/dev/zero of=bin/ucore.img count=10000dd if=bin/bootblock of=bin/ucore.img conv=notruncdd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc# 这里用到了dd命令，if是输入of是输出count是块大小，关于conv参数可以参考 https://www.cnblogs.com/dkblog/archive/2009/09/18/1980715.html https://blog.csdn.net/u011616400/article/details/41575745 ,其作用睡觉哦不截断输出文件 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？ 查看tools/sign.c文件如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;int main(int argc, char *argv[]) &#123; struct stat st; //检查输入参数 if (argc != 3) &#123; fprintf(stderr, \"Usage: &lt;input filename&gt; &lt;output filename&gt;\\n\"); return -1; &#125; //stat函数传入文件名和结构体对象可以返回一个结构体信息，检测是否是吧 if (stat(argv[1], &amp;st) != 0) &#123; fprintf(stderr, \"Error opening file '%s': %s\\n\", argv[1], strerror(errno)); return -1; &#125; //输出长度 printf(\"'%s' size: %lld bytes\\n\", argv[1], (long long)st.st_size); //检测是否超过510个字节 if (st.st_size &gt; 510) &#123; fprintf(stderr, \"%lld &gt;&gt; 510!!\\n\", (long long)st.st_size); return -1; &#125; //建立缓冲区，将缓冲区置0 char buf[512]; memset(buf, 0, sizeof(buf)); //读取文件，填充缓冲区 FILE *ifp = fopen(argv[1], \"rb\"); int size = fread(buf, 1, st.st_size, ifp); //判断文件大小是否如文件信息所述 if (size != st.st_size) &#123; fprintf(stderr, \"read '%s' error, size is %d.\\n\", argv[1], size); return -1; &#125; //关闭流 fclose(ifp); //写入标识 buf[510] = 0x55; buf[511] = 0xAA; //打开新文件，写出 FILE *ofp = fopen(argv[2], \"wb+\"); size = fwrite(buf, 1, 512, ofp); //再次检测大小是否符合要求 if (size != 512) &#123; fprintf(stderr, \"write '%s' error, size is %d.\\n\", argv[2], size); return -1; &#125; fclose(ofp); printf(\"build 512 bytes boot sector: '%s' success!\\n\", argv[2]); return 0;&#125; 练习2要求：使用qemu执行并调试lab1中的软件。（要求在报告中简要写出练习过程） 准备工作123456V=@BINDIR=binlab1-mon: $(UCOREIMG)$(V)$(TERMINAL) -e \"$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $&lt; -serial null\"$(V)sleep 2$(V)$(TERMINAL) -e \"gdb -q -x tools/lab1init\" 第一行参数表 -S 在启动时不启动 CPU， 需要在 monitor 中输入 ‘c’，才能让qemu继续模拟工作 -s 等待gdb连接到端口1234 -d 输出日志到 qemu -hda 指明使用file作为硬盘0镜像 -serial dev 重定向虚拟串口到主机设备dev中 第三行参数表 -x 指明预设命令文件,预设文件如下123456file bin/kernel #加载符号信息 target remote :1234 #与qemu进行链接set architecture i8086 #设置处理器架构b *0x7c00 #在0x7c00设置断点continue #继续x /2i $pc #显示PC之后的两条指令 使用GDB命令完成以下工作: 查看PC之后的10行命令x/10i $pc 查看具体位置的内存数据x/ 查看GDTR寄存器的值 断点b *0x7c0a 打印所有寄存器info register，也可以是i r 在开启保护模式后设置架构set architecture i386 单步源代码的下一行，不进入函数next 单步一条机器指令，不进入函数nexti 单步到下一个不同的源代码行,进入函数step 单步到一条机器指令，进入函数stepi从CPU加电执行的第一条指令开始，单步跟踪BIOS的执行由于开机时处于实模式，开机的时候CS:IP=0xf000:fff0因此应该查看这里的指令 之后执行一系列BIOS操作最够将控制权转交给0x7c00的bootloader部分 练习3 分析bootloader进入保护模式的过程步骤(关键步骤前加*) 准备基本的GDT表项以供使用进入保护模式之后使用 初始化寄存器 *检测并发送A20开启信号来开启A20 *通过修改CR0寄存器的保护模式使能位进入保护模式 *用保护模式的寻址机制跳转到初始化保护寄存器的代码段(protcseg)长跳转指令进入 *初始化堆栈部分一便于C语言程序的调用堆栈区域是从0–start(0x7c00)代码阅读代码注释练习4：分析bootloader加载ELF格式的OS的过程。bootloader在前面可以看到，分为两部分，一部分是汇编代码写的，主要完成进入保护模式并初始化寄存器，第二部分是C代码写的，主要完成加载ELF格式的内核文件到内存中，这里就涉及到原生的C并不能完成的任务，例如读取硬盘扇区，在这里使用的是GCC内联汇编来完成基本功能被C代码使用的。读取硬盘部分读取扇区(readsect)的操作可以分为如下几部分 等待磁盘准备好 (whitdisk(void)) 发出读取磁盘的命令 (向硬盘的IO端口输出读取信息) 等待磁盘准备好 (whitdisk(void)) 将磁盘扇区的数据读到指定的内存中去 0号磁盘的IO端口详细信息:1F0H 0号硬盘数据寄存器1F1H 0号硬盘错误寄存器(读时),0号硬盘Features寄存器(写时)1F2H 0号硬盘数据扇区计数1F3H 0号硬盘扇区数1F4H 0号硬盘柱面(低字节)1F5H 0号硬盘柱面(高字节)1F6H 0号磁盘驱动器/磁头寄存器1F7H 0号硬盘状态寄存器(读时)，0号硬盘命令寄存器(写时) 读取硬盘的详细阅读代码注释 装载ELF格式内核在这里需要简单的了解ELF文件布局如下 使用objdump -h查看ELF文件信息，可以查看在相关节的信息 链接地址(Virtual Memory Address)和加载地址(Load Memory Address):程序在链接的时候会确定链接地址，这个地址是逻辑上的，代码中绝对的跳转都按照此基准进行，而加载地址是事实加载的地址。123456789101112131415161718192021222324252627282930313233343536/* bootmain - bootloader的入口 */voidbootmain(void) &#123; // 将文件的前4KB读取内存 readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0); // 检测加载进内存的内核模块是否是ELF文件 if (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123; goto bad; &#125; struct proghdr *ph, *eph; // 通过结构体的偏移找到程序头表的入口，并加载程序段(ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff); // 通过指针的偏移,找到程序头表结束的地址 eph = ph + ELFHDR-&gt;e_phnum; //开始对程序头表包含的具体的信息进行遍历处理 for (; ph &lt; eph; ph ++) &#123; //用readreg这个函数将文件的每一个段都读到内存中由程序头表的相应位置 //由于kernel 程序的链接地址太高，而实际内存没有那么大的情况下，实际地址就是&amp;0xFFFFFF的结果(Mark，这个还不是太懂) readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); &#125; // 调用elf文件格式指明的程序入口点地址，转交控制权 // note: 不会返回 ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();/*加载失败跳转到这里*/bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); /* 无限循环 */ while (1);&#125; 实现函数调用堆栈跟踪函数 （需要编程）一个函数调用的大致步骤分为以下阶段，由于调用约定多样，这里只总结大致步骤 参数的传入，可以push参数，也可以传入具体的寄存器 call 将返回地址压入堆栈中，ESP-4(32位)，此时ESP指向的是保存返回值的地址 push %ebp 将上一个堆栈的栈底指针传入，ESP再次-4 mov %esp,%ebp 设置新的栈底 提升栈空间，用于函数操作 保护现场，具体是保存将要修改的寄存器 其他初始化工作 执行函数核心内容 恢复现场 pop %ebp 恢复堆栈 ret依据上述过程易得： 如果函数传入参数是通过在call之前压入参数来做到了，那么其参数地址是ebp+8+4*(n+1),n=1,2,3… 函数的返回地址是ebp+4 ebp指示的位置是上一个函数调用esp的位置，ebp内保存的内容是原来ebp的值","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.maoxin.site/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.maoxin.site/tags/操作系统/"}]},{"title":"ECMAScript 6","slug":"js-07","date":"2018-09-27T08:18:56.000Z","updated":"2018-11-01T09:32:32.358Z","comments":true,"path":"2018/09/27/js-07/","link":"","permalink":"http://www.maoxin.site/2018/09/27/js-07/","excerpt":"","text":"历史与概念Evergreen Browsers长期浏览器，支持最新标准 Microsoft Edge Firefox Chrome Opera Safari环境搭建 node npm js的包管理工具 babel 针对ES标准的转译器，将新版本的语法转换为老版本shim&amp;polyfill 提供API来在旧的基础之上支持类似的新标准的功能 polyfill 更贴近标准，扩展原生对象来提供几乎一样的新标准支持语法let 与 const let和const不可以重复声明 let和const都在块级作用域有效 箭头函数1234567891011121314151617181920212223242526//定义(function(a)&#123;return a*2&#125;)(a)=&gt;&#123;return a*2&#125;(a)=&gt;a*2a =&gt; a*2//返回值//返回对象，注意｛｝的语义可能冲突const funObj = name =&gt;&#123;&#123;name,age:27&#125;&#125;//不能作为构造函数const A =()=&gt;&#123;&#125;new A()//this指向问题const obj = &#123; a:()=&gt;&#123; console.info(this.c); &#125;, b:function()&#123; console.info(this.c) &#125; c:123&#125;;obj.a();//undefinedobj.b();//123 箭头函数只能替换函数表达式，不能替换函数声明，因为它是匿名的 不能赋值常量作为构造函数 this指向是在定义时决定的而不是之前普通函数调用时定义的，this取决于父执行上下文的thisModule 12345//module Aexport default function moduleMethod()&#123;&#125;//moduleimport method form './moduleA'method(); 引入多个函数123456789//module Aexport function methodA()&#123;&#125;export function methodB()&#123;&#125;//module Bimport &#123;methodA,methodB&#125; from './moduleA'methodA()//orimport * as util from \"./moduleA\"util.methodA() ClassES5中的方法推荐挂载到原型中，在ES6可以直接申明123456789101112131415161718//ES5function Teacher(options)&#123; var options = options ||&#123;&#125;; this.name = options.name ||'stefan'&#125;Teacher.prototype.getName = function()&#123; return this.name;&#125;//ES6class Teacher1&#123; constructor()&#123; this.name = \"stefan\" &#125; getName()&#123; return this.name; &#125;&#125;var teacher1 = new Teacher1(); 深入理解类1234567891011console.info(typeof Teacher1)//functionconsole.info(Teacher1.prototype.constructor==Teacher1)//trueObject.assign(Teacher1.prototype,&#123; getName()&#123; return this.name; &#125;&#125;)//区别console.info(Object.keys(Teacher.prototype));//['getName']console.info(Object.keys(Teacher1.prototype))//[]//说明ES6是不可枚举的 继承extends关键字12345678class PangTeacher extends Teacher&#123; constructor(...args)&#123; //子类没有自己的this对象，通过继承父类的this对象进行扩充的 super(...args); this.weight = 180; &#125;&#125;new PangTeacher(); ES6高级特性解构赋值解构赋值(Destructuring Assignment)，学习Python1234567891011121314151617var [a,b,c] = [1,2,3];console.info(a,b,c);//1 2 3var[a,,b]=[1,2,3];console.info(a,b)//1 3//-------------------------var o = &#123;a:1,b:2&#125;;var &#123;a,b&#125;= o;console.info(a,b);//1.2//-------------------------var o = &#123;a:1,b:2&#125;;var &#123;b,a&#125;=o;console.info(a,b);//1,2//-------------------------function test(&#123;a,b,c&#125;)&#123; return a+b+c;&#125;console.info(test(&#123;a:3,b:4,c:1&#125;)) 解构赋值很方便的将声明和传参结合在了一起 … Spread Elements &amp; Properties12345let x = 1;let y = 2;let spread = [3,4];let n = [x,y,...spread];console.log(n)//[1,2,3,4] 12345let x = 1;let y =2;let spread = &#123;a:3,b:4&#125;;let n = &#123;x,y,...spread&#125;;console.log(n);//&#123;x:1,y:2,a:3,b:4&#125; 12345function spreadFunc(a,b,c)&#123; console.info(a+b+c);&#125;let args = [1,2,3];spreadFunc(...args) Rest Element &amp; Properties12345678910111213let [a,b,...rest] = [10,20,30,40,50]console.log(a)console.log(b)console.log(rest)//[30,40,50]//-----------------let&#123;x,y,..rest&#125; = &#123;x:1,y:2,a:3,b:4&#125;;console.log(x);console.log(y);console.log(rest);//&#123;a:3,b:4&#125;//------------------function restFunc(a,...args)&#123;&#125; Template针对字符串拼接12345678910//ES5var name = 'stefan'console.info('My name is'+ name+'.');//这里第一个\\是转义，最后一个\\是换行链接字符串console.info('My name is'+ name+'.\\n\\I love this world')//ES6console.info(`My name is $&#123;name&#125;.`);console.info(`My name is $&#123;name&#125;。I love this world.`); Symbol1console.info(Symbol('a')==Symbol('a'))//false Map&amp;Set1234var set = new Set([1,2,3,3,4]);console.info([...set])//[1,2,3,4]set.add(5)console.info([...set])//[1,2,3,4,5] 123456var a = new Map([ ['a',1], ['b',2]])console.info(a.get('a'),a.get('b'));a.set('c',3) Generator &amp; IteratorGenerator 函数是一个状态机，封装了多个内部状态12345678910111213141516171819202122232425262728293031//使用function* 标明是一个Generatorfunction* fibonacci()&#123; let v1 = 0; let v2 = 1; while(true)&#123; //进行求斐波那契数列的迭代 [v1,v2] = [v2,v1+v2]; // let reset = yield v1; // if(reset)&#123; v1 = 0; v2 = 1; &#125; &#125;&#125;//调用迭代器函数，返回一个对象，带有next方法let a = fibonacci();console.log(typeof a)//调用对象的next方法返回一个对象带有value属性和done属性,next语义会生成下一个值//value属性代表的是每次执行到yield的状态值//down属性代表的是迭代是否结束console.info('1',a.next());console.info('1111',a.next());//如果不取值，就不会生产值console.info('2',a.next().value);console.info('3',a.next().value);console.info('4',a.next().value);console.info('5',a.next().value);//next传入的值会返回到yield 执行之后的返回值console.info('6',a.next(true).value); 迭代器迭代器希望提供一致的迭代方式，那么对于不同对象，我们需要指明的是 迭代的下一个对象是什么？ 迭代什么时候结束正是因为有了迭代器，ES6可以使用统一的访问机制for …of循环来遍历 123456789101112131415function makeIterator(array)&#123; var nextIndex = 0; return&#123; next:function()&#123; return nextIndex&lt;array.length? &#123;value:array[nextIndex++],done:false&#125;: &#123;value:undefined,done:true&#125; &#125; &#125;;&#125;var it = makeIterator(['a','b'])console.log(it.next())//&#123; value: 'a', done: false &#125;console.log(it.next())//&#123; value: 'b', done: false &#125;console.log(it.next())//&#123; value: undefined, done: true &#125; 一种数据结构只要部署了Iterator接口，我们就称为这种数据结构是”可遍历的” 一个数据几个只要具有Symbol.iterator属性，就认为是”可遍历的”(iterable)123456789101112131415let counter = 0;const obj = &#123; a:1, b:2, //实现接口 [Symbol.iterator]:()=&gt;(&#123; next:()=&gt;(&#123; value:1, done:counter++&gt;3 &#125;) &#125;)&#125;;for(let j of obj)&#123; console.info('obj',j);&#125; 与Generator函数除了状态机，还是一个便利器对象的生成函数12345678910111213class OddDouble&#123; constructor(list)&#123; this.list = list; &#125; *[Symble.iterator]()&#123; for(let item of this.list)&#123; yield item%2?item*2:item; &#125; &#125;&#125;for(let i of new OddDouble([1,2,3,4,5]))&#123; console.log(i);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/tags/JavaScript/"}]},{"title":"面向对象的JavaScript","slug":"js-6","date":"2018-09-26T03:19:20.000Z","updated":"2018-11-01T09:32:26.107Z","comments":true,"path":"2018/09/26/js-6/","link":"","permalink":"http://www.maoxin.site/2018/09/26/js-6/","excerpt":"","text":"定义对象属性一般方法123person.a = 1;person[\"a\"]=1;person = &#123;a:1&#125; 高级方法需要明确一下几个概念： 数据属性: Configurable:表示能否通过delete属性而重新定义属性 enumerable:表示能否通过foreach循环来获得属性 writable:表名属性是否可以修改 value: 定义初始值12345678var person = &#123;&#125;;Object.defineProperty(person,\"name\",&#123; writable:false, value:\"Nicholas\"&#125;)console.info(person.name);person.name = \"Greg\";console.info(person.name); 访问器属性: 访问器属性相比于数据属性没有writable和value，新增了get和set属性,一般对私有属性进行get/set方法1234567891011121314151617var book = &#123; _year:2004, edition:1&#125;;Object.defineProperty(book,\"year\",&#123; get:function()&#123; return this._year; &#125; set:function(newValue)&#123; if(newValue&gt;2004)&#123; this._year = newValue; this.edition+=newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition);//2 创建私有的访问器属性之后设置具体的值经过get/set方法为数据的访问增加了一个中间层，在中间层内部增加类似监听器的东西可以实现“观察者模式”,例如MVVM框架所能做到的对对象属性的修改能及时反馈到对应的界面上。 创建对象-工厂模式12345678910function createPerson(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125; return o;&#125; 创建对象-构造函数12345678function Person(name,age,job)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"Nicholas\",29,\"Software Engineer\"); new 构造函数的执行步骤 在内存中创建一个对象 将作用域指向这个对象 执行构造函数的代码 将该对象的引用返回创建对象-原型模式123456789101112function Person()&#123;&#125;Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.sayhello = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName();//\"Nicholas\"var person2 = new Person();person2.sayName();//\"Nicholas\" 首先prototype是一个指针，指向这个对象 hasOwnProperty()检测来自实例的属性，而不是来自原型 delete Person1.name删除实例属性 in 关键字判断原型和实例中是否有 for in遍历时无差别对待原型属性和实例属性 认识构造函数和原型的问题 首先，构造函数每次执行相当于创建一个全新的对象，每一个实例都有自己的属性和方法，这样在效率上消耗太高 原型的缺点在于如果修改了一个属性值，其他所有属性值都变了。创建对象-组合将属性值放到实例属性中，将方法写到原型中去。1234567891011function Person(name,age,job)&#123; this.name = name; this.age = age; this.friends = [\"shelby\",\"Court\"];&#125;Person.prototype = &#123; constructor: Person, sayName:function()&#123; alert(this.name); &#125;&#125; 继承123456789101112131415161718192021222324252627//定义SuperType的构造方法function SuperType()&#123; this.colors = [\"red\",\"blue\",\"green\"]&#125;//定义Supertype的原型方法SuperType.prototype.getSuperValue = function()&#123; return this.proprety;&#125;//定义子类的构造方法function SubType()&#123;&#125;//指明继承关系SubType.prototype = new SuperType();//添加子类方法SubType.prototype.getSubValue = function()&#123; return this.subProperty;&#125;;//重写父类方法SubType.prototype.getSubValue = function()&#123; return false;&#125;//定义子类的原型方法var instance1 = new SubType();instance1.colors.push(\"black\");var instance2 = new SubType();console.info(instance2.colors);//[ 'red', 'blue', 'green', 'black' ] 发现一个问题，通过原型链继承的数据对象是在原型中的，这个会最大的问题就是数据成员的共享，当然在特定的条件下可以利用该特点。12345678910111213//继承独立的数据成员的方法function SuperType()&#123; this.colors = [\"red\",\"blue\",\"green\"];&#125;function SubType()&#123; //将构造函数的数据成员强制绑定到本地 SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(\"black\");console.info(instance1.colors)//var instance2 = new SubType();console.info(instance2.colors) 两种方法的折中，组合继承 将想要继承的独立的数据成员使用构造函数继承方式 将函数成员或者共享的数据成员使用原型链继承12345678910111213141516171819202122232425262728293031323334353637//创建构造函数function SuperType(name)&#123; this.name = name; this.colors = [\"red\",\"blue\",\"green\"];&#125;SuperType.prototype.sayName = function()&#123; console.info(this.name)&#125;function SubType(name,age)&#123; //设置继承父类的数据成员作为自己的独立的 SuperType.call(this,name); this.age = age;&#125;//可以说下面的三行代码都是完善继承关系的步骤//指明prototype是从supertype()，使得subType具有了继承的层次,但是这里父类中有冗余的字段,优化步骤写在[2]中//[1]SubType.prototype = new SuperType();//[2]上面代码的优化版本，通过定义空方法来function F()&#123;&#125;F.prototype = SuperType.prototype;SubType.prototype = new F();//添加SuperType的构造函数为SubtypeSubType.prototype.constructor = SubType;//再添加函数成员到原型中SubType.prototype.sayAge = function()&#123; console.info(this.age)&#125;var instance1 = new SubType(\"Nicholas\",29);instance1.color.push(\"black\")console.info(instance1.colors)instance1.sayName();instance1.sayAge();var instance2 = new SubType(\"Greg\",27);console.info(instance1.colors)instance1.sayName();instance1.sayAge(); JavaScript语言的二义性动态的语言许多看似简单的东西有丰富的用法，这个需要注意，这也往往是其坑所在","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/tags/JavaScript/"}]},{"title":"JSON与AJAX和跨域通信","slug":"Server-01","date":"2018-09-24T16:27:19.000Z","updated":"2018-09-24T16:29:04.807Z","comments":true,"path":"2018/09/25/Server-01/","link":"","permalink":"http://www.maoxin.site/2018/09/25/Server-01/","excerpt":"","text":"JSON表示值的类型 不能表示Undefined Null,Boolean,number,String 对象 数组JSON 规范 JSON是一种规范，是一种组织数据的格式 JSON字符串不能用单引号 JSON的属性必须是一个字符串表示12345678910//wrong in json, but right in javascript&#123; name:\"Maoxin\", age:29&#125;//right in json&#123; \"name\":\"Maoxin\", \"age\":29 &#125; JSON 序列化1234567891011121314151617181920212223242526272829//javascript object -&gt; JSON Stringvar book = &#123; title:\"C++ Learn\", authors:[ \"Nicholas C. Zakas\" ], year:2011, edition:3&#125;var jsonText = JSON.stringify(book)//get attributes which we need to stringifyvar need = JSON.stringfy(book,[\"title\",\"edition\"])//&#123;\"title\":\"C++ Learn\",\"edition\":3&#125;//execute function according to attributevar jsonText = JSON.stringify(book,function(key,value)&#123; switch(key)&#123; case \"authors\": return value.join(\",\") case \"year\": return value; case \"edition\": return undefined; default: return value; &#125;&#125;)//deliver the number of space to get a formated stringvar jsonText = JSON.stringify(book,null,4); 可以在对象中添加toJSON的属性来控制格式化那些东西JSON解析123456789101112var book = &#123; title:\"Javascript\", releaseDate: new Date(2011,11,1);&#125;var jsonText = JSON.stringify(book)var bookCopy = JSON.parse(jsonText,function(key,value)&#123; if(key==\"releaseDate\")&#123; return new Date(value); &#125;else&#123; return value; &#125;&#125;); AJAXXMLHttpRequest 基本123456var xhr = new XMLHttpRequest();// 第三个参数是是否是异步的xhr.open(\"get\",\"example.php\",false);//注意调用的时候，不会真正的指向请求，而是准备发送，用send发送//如果是GET请求，将body设置为null即可xhr.send(null); XMLHttpRequest - 填充属性 responseText如果返回的是文本将返回结果挂载在这里 responseXML 返回的是XML status 状态码&gt;=200时候代表能够正确返回，当status=304通知浏览器本地缓存还可以使用 statusText 以下为同步情况：123456//同步情况if((chr.status&gt;=200&amp;&amp;chr.status&lt;300)||xhr.status==304)&#123; alert(xhr.responseText);&#125;else&#123; alert(\"error info: \"+xhr.status);&#125; 以下为异步情况：采用注册事件的方式12345678//在open和send之前xhr.onreadystatechange=function()&#123; if((chr.status&gt;=200&amp;&amp;chr.status&lt;300)||xhr.status==304)&#123; alert(xhr.responseText); &#125;else&#123; alert(\"error info: \"+xhr.status); &#125;&#125; 在这里需要明确readState的变化过程 0 未初始化 1 启动 2 发送 3 接收 4 完成abort 终止使请求提前终止AJAX XMLHttpRequest Header Accept: 浏览器能处理的内容类型 Accept-Charset：浏览器能显示的字符串 Accept-Encoding: 浏览器能够处理的压缩编码 Accept-Language:浏览器当前设置的语言 Connection：浏览器与服务器之间的连接的类型 Cookie:不解释 Host:发出请求页面所在的域 Referer:发送请求的页面URL，注意这个词是拼写错了，将错就错,referrer是正确的 User-Agent：浏览器用户代理字符串12345xhr.setRequestHeader(\"MyHeader\",\"MyValue\")//Demo 模拟表单发送xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");var form = document.getElementById(\"user-info\");xhr.send(serialize(form)); 表单处理1234567//Axhr.send(serialize(form));//Bvar form = document.getElementById(\"user-info\");var formData = new FormData(form);formData.append(\"name\",\"Maoxin\");xhr.send(formData); 进度事件 onload 响应完成触发 onprocess 接受过程中触发的事件123456xhr.onprogress = function(event)&#123; var divStatus = document.getElementById(\"status\"); if(event.lengthComputable)&#123; divStatus.innerHTML = \"Received\" +event.position+\"of\"+event.totalSize+\"bytes\"; &#125;&#125; 跨域通信CORSJSONP","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.maoxin.site/categories/操作系统/"}],"tags":[{"name":"Server杂项","slug":"Server杂项","permalink":"http://www.maoxin.site/tags/Server杂项/"}]},{"title":"蛋疼的JavaScript(五)引用类型","slug":"js-5","date":"2018-09-23T01:53:40.000Z","updated":"2018-11-01T09:32:18.194Z","comments":true,"path":"2018/09/23/js-5/","link":"","permalink":"http://www.maoxin.site/2018/09/23/js-5/","excerpt":"","text":"配置式构造对象常用的传入参数在不能满足成员是动态的时候的情况1234567function setObject(name,age,school)&#123; return&#123; name:name, age:age, school:school &#125;&#125; 可以使用配置式的来满足动态需求123function setObject(configure)&#123; return configure&#125; 列表的简单操作栈方法和队列方法123456789101112131415var a = [1,2,3];a.push(4); //4加入末尾console.info(a)a.unshift(0) //0加入队首console.info(a)a.pop() //4从尾部弹出console.info(a)a.shift() //0从队首弹出console.info(a)a.unshift(7) //7加入在首部console.info(a)a.unshift(8) //8加入到首部console.info(a)a.shift() //从首部弹出console.info(a) 注意JavaScript不是说队列或者栈方法将整体看作一个队列，而是说通过以上方法来实现栈和队列的操作。 排序 倒置:reverse() 排序:sort()1234var a=[2,1,3,7,5,4,6];a.sort(function(prev,next)&#123; return prec - next;&#125;) 迭代器 foreach方法，传入两个参数，一个是元素的值，一个是下标 1234var a = [1,2,3];a.foreach(function(obj,index)&#123; console.info(obj,index)&#125;) filter方法，传入一个参数，元素值，返回数组是经过过滤为true的新的数据集 map方法，map是将迭代的元素都经过一次操作，最终返回一个新数组 123456var a = [1,2,3]var b = a.map(function(c)&#123; return c*2;&#125;)console.info(b)//[2,4,6] reduce方法 先上代码123456var a = [1,2,3];var b = a.reduce(function(c,d)&#123; return c+d;&#125;,0);console.log(b);//6 就这样完成了数组相加,首先reduce接受两个参数，一个是回调，这个回调负责将问题规模减小，第二个值是初始值，而回调接受两个参数，一个是初始值，一个是当前值，将初始值与当前值相加之后返回到作为初始值继续操作。下面的代码很容易猜到就是1012345var a = [1,2,3];var b = a.reduce(function(c,d)&#123; return c+d;&#125;,4);console.log(b); 下面这个利用reduce完成map方法的功能12345var a = [1,2,3]var b = a.reduce(function(c,d)&#123; c.push(d*2); return c;&#125;,[]) 函数arguments 函数命名在递归程序的耦合1234function fib(num)&#123; if(num&lt;=1) return 1; return num + arguments.callee(num-1);&#125; 可见这个callee是在该函数中被调用的方法,caller是调用者的方法，注意在严格模式下无法访问 this表征函数当前作用域，详情见之前的this总结 call&amp;apply其都是说让函数在特定的，apply和call的区别在于call传入的是单个参数，apply是传入的数组1234567891011result = 0;var o = &#123; result:0&#125;function sum(a,b)&#123; this.result = (+a + +b);&#125;sum.call(o,'1','2')console.info(o.result);//3sum.apply(o,['1','3'])console.info(o.result)//4","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/tags/JavaScript/"}]},{"title":"蛋疼的JavaScript(四) 语句与函数","slug":"JS-04","date":"2018-09-19T02:58:37.000Z","updated":"2018-11-01T09:32:09.307Z","comments":true,"path":"2018/09/19/JS-04/","link":"","permalink":"http://www.maoxin.site/2018/09/19/JS-04/","excerpt":"","text":"JavaScript中的()的语意 作为函数调用运算符 函数参数占位符号 强制运算符，返回结果 只要以上明白了，下面就很好理解了1234567(function()&#123;&#125;())(function()&#123;&#125;)() 由于函数是一个作用域块，所以能够做到变量的隐藏。 void()运算符与()的第三个语意相反，是求值但是不返回 值传递 在堆中的对象在函数参数传递的时候是传递指针的值，所以能够做到共享 但是如果在栈中的值得拷贝就需要注意没有修改原值。 arguments 在严格模式下(严格模式下在函数前使用&quot;use strict&quot;;) arguments与传入的形参是没有联系的，修改arguments下的值是不会反映到形参的变化的 在非严格模式下，有联系 JS没有函数重载，使用arguments可以模拟重载 arguments不是数组，想要转换为数组可以使用数组原型对应的方法：1[].slice.call(arguments,0)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/tags/JavaScript/"}]},{"title":"蛋疼的JavaScript(三)数据类型&运算符","slug":"js-03","date":"2018-09-18T14:45:49.000Z","updated":"2018-11-01T09:32:01.309Z","comments":true,"path":"2018/09/18/js-03/","link":"","permalink":"http://www.maoxin.site/2018/09/18/js-03/","excerpt":"","text":"typeof 探测类型 type探测的类型是基本的数据类型，对于对象，他分不清是哪种object（除了function）,也就是说它深入不到构造方法级别的类型检测，这也是与instanceof的区别 在控制台下有个好处可以很具体的看到返回的类型都是string的 类型转换从常见的几种转换入手： 布尔类型的转换 数字类型的强制类型转换 注意其可以做数值的进制转换 转换为字符串 运算符一元+如果后面是字符串那么就变为数字 快捷转换为字符串1var b = 1+\"\"; 逻辑运算符:布尔类型的强制转换 两个逻辑非可以将其他类型转换为布尔类型 1234console.info(!!\"\")//falseconsole.info(!\"\")//trueconsole.info(![])//falseconsole.info(![1])//false 完成代码的精，利用短路特性 12var a = 1;true &amp;&amp; (a=2);//加括号是运算符优先级的问题 用于给一个默认值 1234//默认5分function score(s)&#123; return s || 5;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/tags/JavaScript/"}]},{"title":"HTML5_1","slug":"HTML5-1","date":"2018-09-18T14:20:50.000Z","updated":"2018-11-01T09:30:02.002Z","comments":true,"path":"2018/09/18/HTML5-1/","link":"","permalink":"http://www.maoxin.site/2018/09/18/HTML5-1/","excerpt":"HTML5新增的语义化元素","text":"HTML5新增的语义化元素 HTML的最佳实践 选择标记元素要有代表性，不要老是&lt;div&gt;&lt;/div&gt; 不要忘记文档类型申明 不要忘记字符编码申明，在&lt;head&gt;元素中应该有&lt;meta charset=&#39;UTF=8&#39;&gt; 不要使用HTML5不再支持的标记，如&lt;center&gt;,&lt;font&gt;,&lt;basefont&gt;,&lt;big&gt; 不要使用HTML5不再支持的Tag属性 如table、img等标记的align和border属性，能用CSS就用CSS","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.maoxin.site/tags/前端/"}]},{"title":"WindowsAPI常用概念&结构体&工具函数（一）","slug":"WindowsAPI_01","date":"2018-09-16T09:09:15.000Z","updated":"2018-09-16T15:28:39.855Z","comments":true,"path":"2018/09/16/WindowsAPI_01/","link":"","permalink":"http://www.maoxin.site/2018/09/16/WindowsAPI_01/","excerpt":"","text":"概念进程与线程的关系 进程更像是一个空间上的概念，而线程是真正的代码执行过程，利用进程的的资源，所以在Windows调用CreateProcess来创建一个进程的时候返回的_PROCESS_INFOMATION结构体包含了进程标识和线程标识两方面的信息 进程在执行过程中可能创建多个新的进程。创建进程成为称为父进程，而新的进程称之为子进程，构成的是一个“进程树”的结构ID与句柄 在windows下内核对象的种类很多，物理是文件、进程、线程、事件、管道、互斥锁、信号量等等都是都是内核对象的，具体可以查阅MSDN文档关于CloseHandle函数的解释：点击前往 在内核中管理这些对象是通过内核对象ID的来维护的，能够通过ID来指向内核区具体的数据结构，不会将地址直接暴露给应用层。 句柄表是进程所拥有的，每个进程都有一个句柄表来维护这个进程所创建&amp;打开的内核对象 之前提到了进程树，子进程是可以共享父进程的资源（内核对象），共享的方式是继承，在创建进程的时候可以选择继承进程句柄和线程句柄 内核对象在内核中的ID是一定的，但是句柄中的值是不一定的，就好比两个进程同时打开同一个对象，在进程中记录的句柄表同一个的对象对应的句柄是不一样的，但是ID是一样的。 每个内核对象都有对应的表示标明是否可以被继承内核对象的生命周期内核对象都有个计数器，计数器计数的值代表的是被引用的次数，一般的内核对象只需要 内核对象计数器为0 就可以关闭，但是对于Thread以及Process内核对象情况有些特殊它要满足： 内核对象计数器为０ 执行流程结束 相关结构体STARTUPINFO从名字也可以看出，StartUpInfo保存着一些启动的信息 _PROCESS_INFOMATION进程结构体类型，具体的内容如下123456typedef struct _PROCESS_INFORMATION &#123; HANDLE hProcess;//进程句柄 HANDLE hThread;//线程句柄 DWORD dwProcessId;//进程ID DWORD dwThreadId;//线程ID&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; SECURITY_ATTRIBUTES12345typedef struct _SECURITY_ATTRIBUTES &#123; DWORD nLength;//结构体长度 LPVOID lpSecurityDescriptor;//指向安全描述符，指明当前对象的用户权限信息等等，默认与父进程相同 BOOL bInheritHandle;//当前内核对象是否允许继承&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES; 如果在创建内核对象的时候不想继承，那么传入该项结构体的值只需要填写NULL即可文档地址 工具函数GetStartupInfo()获取当前进程的初始化信息，由父进程负责填充相关的STARTUPINFO结构体12STARTUPINFO si;GetStartupInfo(&amp;si) 由于我们即使填写了部分内容也不会都作用到最终的进程创建，我们常规的初始化步骤是：123STARTUPINFO si;ZeroMemory(&amp;si,sizeod(si))si.cb = sizeof(si) CloseHandle()将内核对象计数器的值减一 GetStdHandle()文档地址 WaitForSingleObject()","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.maoxin.site/tags/操作系统/"}]},{"title":"C中sizeof的实现","slug":"C-1","date":"2018-09-14T14:46:52.000Z","updated":"2018-11-01T09:29:03.181Z","comments":true,"path":"2018/09/14/C-1/","link":"","permalink":"http://www.maoxin.site/2018/09/14/C-1/","excerpt":"C语言中Sizeof的实现今天群里面提了一个问题，sizeof这个功能是怎么实现的，自己一时半会儿也没有思路，上网找了找实现，发现非常的巧妙，总结如下：","text":"C语言中Sizeof的实现今天群里面提了一个问题，sizeof这个功能是怎么实现的，自己一时半会儿也没有思路，上网找了找实现，发现非常的巧妙，总结如下： sizeof不是一个函数，是一个宏 对于非数组的实现1#defne _sizeof(T) ( (size_t)((T*)0 + 1)) 首先将对应类型转换为指针地址，通过指针加一地址自动移动位置之后确定位置 数组类型的实现1#define array_sizeof(T) ( (size_t)(&amp;T+1) - (size_t)(&amp;T) ) 假设传入的是一个1int arr[10] = &#123;0&#125; 求地址操作会返回一个类型为int[10]*的指针，那么它一次移动的位数就是一个int[10]的长度 总结 其都是通过指针移位的步长来解决的 对具体类型，用具体类型的指针 对于数组，用指向数组的指针","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://www.maoxin.site/categories/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://www.maoxin.site/tags/C/"}]},{"title":"Type类型","slug":"Type类型","date":"2018-09-12T14:43:19.000Z","updated":"2018-09-17T15:07:00.293Z","comments":true,"path":"2018/09/12/Type类型/","link":"","permalink":"http://www.maoxin.site/2018/09/12/Type类型/","excerpt":"","text":"从泛型到Type类型接口众所周知，Java的泛型都是通过类型擦除来完成的，也就是说当Javac编译之后，所以的泛型参数都被打回原型，而之所以使用类型擦除实现泛型的原因主要是为了向下兼容。那么这样会有如下的问题： Java不能描述通过参数化之后的泛型类型，里面怎么参数化的一概不知 但是在有些场景我们需要对传入的具体的参数化类型进行检测处理，之前的类型系统都依赖与Class本身描述信息，现在Java需要能够描述泛型的参数化过程，通过参数化泛型产生的新类型无非不过是基本的Class类型的组合,Java最后引入了Type接口以及一些子类来统一引入泛型之后的类型系统。 Type是怎样统一Java的类型系统的以下为个人的理解 在泛型之前，Java类型除了原生类型都可以使用Class来描述，在泛型之后，新增了许多“新”的类型： 参数化泛型类的类型，如Collection&lt;T&gt; 参数化泛型类型构成的数组类型，如Animal&lt;T&gt;[] 泛型参数构成的类型（泛型方法），如&lt;E&gt;void method(E e){}中的E e又或者是ArrayList&lt;E&gt;中的E 通配符表达的类型，如void printColl(ArrayList&lt;? extends Number&gt;al)中的? extends Number上面四种类型和Class为了统一都实现了Type接口Type类型的关系Parameterizedtype1234567package java.lang.reflect;import java.lang.reflect.MalformedParameterizedTypeException;import java.lang.reflect.Type;public interface ParameterizedType extends Type &#123; Type[] getActualTypeArguments(); Type getRawType(); Type getOwnerType(); 由于对于参数化泛型类对象中的泛型是可以嵌套的，所以需要注意返回的是除去一个嵌套之后的Type子类型。 对于ArrayList&lt;ArrayList&gt; al,执行该方法去掉&lt;&gt;返回的是ArrayList所以还是参数化类型。如果再执行一次返回的就是Class类型 对于传入的不是具体如ArrayList返回的就是TypeVariable 对于ArrayList&lt;? extends Number&gt;返回的是? extends Number 是WildcardType 对于ArrayList&lt;E[]&gt;返回E[]是GenericArrayType getRawType()简单的说就是得到&lt;&gt;前的原始类型 getOwnerType();得到类型的所有者类型，例如Map.Entry就是Map的所有者类型 getActualTypeArguments()12345678910111213//代码来自https://segmentfault.com/q/1010000000655631public static void main(String[] args)&#123; Method method = new GenericDemo().getClass().getMethod(\"applyMethod\",Map.Entry.class); Type[] types = method.getGenericParameterTypes(); ParameterizedType pType = (ParameterizedType)types[0]; //返回所有者类型，打印结果是interface java.util.Map System.out.println(pType.getOwnerType());&#125;public static &lt;T,U&gt; void applyMethod(Map.Entry&lt;T,U&gt; mapEntry)&#123;&#125; 认识具体的Type类型以及相关方法### 代码实例参考资料 java Type详解 Java类型中ParameterizedType，GenericArrayType，TypeVariabl，WildcardType详解","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/tags/Java/"}]},{"title":"Git 学习","slug":"Git","date":"2018-09-10T13:55:26.000Z","updated":"2018-11-01T09:29:49.903Z","comments":true,"path":"2018/09/10/Git/","link":"","permalink":"http://www.maoxin.site/2018/09/10/Git/","excerpt":"GIT精简教程简单记录","text":"GIT精简教程简单记录 集中式和分布式集中式类似CVS必须联网工作，这样对带宽有要求，在网络环境下缺陷显著。而分布式管理系统没有“中央服务器”之称，每个人的电脑是一个完整的版本库。“单点失败”的问题可以被解决，每个人在自己的电脑上修改了文件，相互之间将各自的修改推送给对方即可其他要点： CVS是最早开源的集中式版本控制系统，本身有缺陷，同样是开源且免费的SVN修正CVS稳定性问题，是目前使用最多的集中式版本控制系统 安装之后的配置12git config --global user.name \"maoxin\"git config --global user.email \"lumaoxin@aliyun.com\" 其中–global 表示所以的git仓库都使用该配置 创建版本库在文件夹内部使用git init命令将当前文件夹变为git仓库，这时会创建隐藏目录.git 添加文件到仓库首先需要明确，所有的版本控制系统，只能跟踪文本文件的改动，而二进制文件的改动不能被跟踪1git add readme.txt 没有消息就是最好的消息， 提交文件到仓库1git commit -m \"wrote a readme file\" 使用commit来提交 -m之后是本次提交的说明 可以add多个文件之后一次性commit管理版本使用git log来查看版本的变更，提交的信息1git log 这样会输入大量多行信息，如果想要精简信息，就需要：1git log --pretty=online 在信息会看到commitid是一串16进制值，这主要是git生成的Hash码，这样可以有效防止冲突 在git中HEAD表示当前版本，上一个是HEAD^,再上一个是HEAD^^,上100个版本是HEAD~100回退版本使用git reset来完成回退1git reset --hard HEAD^ 这个时候再去看log已经找不到来自属于“未来”的信息了，要想回到未来，就需要使用commitid去寻找，没有必要写全1git reset --hard 1094a 而如何找到版本号，可以使用git reflog来查看每一次记录的命令1git reflog 工作区和暂存区的概念由于对于git这样的分布式版本管理工具，在本机有Master库，我们做的每一次修改如果都作为Master库的修改的话是不应该的，应该是我们先做一定的修改，确定后提交给Master库。那么在commit之前保存修改信息就是非常需要的，在git中使用stage，暂存区的概念。而我们再未add到暂存区之前对文件所做的所有操作，都是到“工作区”我们通过以下命令来查看暂存区的状态：1git status 管理修改git管理的是修改而不是文件，修改之后首先得add进storge中才会被之后的commit提交。 撤销修改当修改的文件已经被add进缓存区中，可以使用1git checkout -- readme.txt 这个时候是从撤销了该文件在暂存区的记录，同时注意它还会将在暂存取的记录还原到工作区 总之以上命令相当于将文件恢复到add或者commit之前但是如果已经提交到暂存区，上面得到修改方式就不灵了，只能回到add之后的状态我们可以使用一下命令将暂存区的修改撤销掉1git reset HEAD readme.txt 之后再丢弃工作区的修改即可1git checkout -- readme.txt 删除文件文件的删除本身也是修改，我们再add到git之后在工作区删除文件之后，用git status命令也可以找到本次的修改,使用如下的git rm来从版本库中删除1git rm test.txt 之后再去commit1git commit 如果删除错了，可以时候check来回到commit之前的状态1git checkout -- test.txt SSH加密认证原理对称加密：加密解密用同一个密钥，使用同一套加密算法，只是密钥不同（只要在网上传输这个密钥就是不安全的） RSA 非对称加密：这里不探讨非对称加密的原理，但是非对称加密有如下有意思的特点： 用私钥加密的数据，只有对应的公钥才能够解密 用公钥加密的数据，只有对应的私钥才能解密 只要互相公布自己的公钥，即可完成双方信息的加密传输 例如：B向A发送数据，A公布自己的公钥，B拿着公钥加密数据，传输到A之后A拿自己的私钥去解密。反之亦然， 稍微详细的过程如下： 首先A、B双方，在通信前构建专属于自己的密钥对，假设分别是公钥A，私钥A，公钥B，私钥B； A将自己的公钥A暴露给B，B通过私钥B和公钥A经过一定的运算产生出本地的密钥B； 同样，B将自己的公钥B暴露给A，A通过私钥A和公钥B经过一定的运算产生出本地的密钥A； 最后，这个算法有意思的一点就是，密钥A和密钥B是一致的，这样A、B双方就拥有了一个属于双方的“秘密”口令 非对称加密+对称加密 RSA非对称加密速度很慢，每次都要采用非对称加密的方式传输太浪费资源，而对称加密速度比RSA快上数百倍，不如将对称加密密钥通过RSA传输之后通过对称加密方式。 中间人劫持问题 对于非对称加密，B要向A发送加密之后的信息首先要获取A的公钥，A在发送的时候被截取之后被中间人替换为中间人的公钥，这时，B就会拿着中间人的公钥去加密数据，再返回中间人，中间人用自己的私钥去解密，之后再用A的公钥加密。这种方式叫做中间人劫持 问题的解决策略：CA 数字签名与证书（略） SSH简介 简单说，SSH（Secure Shell）是一种非对称加密与对称加密算法相结合的安全网络协议，用于计算机通信加密。一个SSH会话的建立过程分为两个阶段：第一阶段，双方沟通并同意建立一个加密连接通道以供后续信息传输用；第二阶段，对请求接入的用户进行身份验证以确定服务器端是否要给该用户开放访问权限。 SSH步骤 首先通过非对称加密来建立一条加密通道，通过得知双方的公钥和私钥可以获得这一特殊的密钥来加密数据 SSH密钥对的验证过程起始于上一部分加密通道建立之后，其具体执行步骤如下：客户端发送自己的密钥ID给服务器端，服务器在自己的authorized_keys文件中检查是否有此ID的公钥。如果有，则服务器生成一个随机数，用该公钥加密之后，服务器将加密后的随机数发给客户端。客户端用私钥解密该随机数，然后在本地为随机数做MD5哈希，客户端将该MD5哈希发给服务器端，服务器端为一开始自己生成的随机数也做一个MD5哈希，然后用通讯通道“公共的密钥”将该哈希加密，再跟客户端发来的内容进行对比。如果双方内容一致，则通过验证，开放访问权限给客户端 简单来说，服务器端用公钥加密信息，客户端用私钥解密信息以证明自己持有私钥。 参考： CSDN博客 啊塔-SSH加密认证原理 刘欣 《码农翻身》-机械工业出版社 使用远程仓库创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C \"youremail@example.com\" 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 添加到远程库 首先在github中创建远程库 在本地仓库中链接 1$ git remote add orgin git@github.com:XXXX/XXXX.git 这样设置远程库的名字就是origin 推送到远程库 1$ git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从远程库拉取使用git clone克隆本地库 1$ git clone git@github.com:xxx/xxx.git 参考廖雪峰老师的GIT教程 https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374027586935cf69c53637d8458c9aec27dd546a6cd6000","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.maoxin.site/categories/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.maoxin.site/tags/Git/"}]},{"title":"蛋疼的JavaScript(二)this","slug":"js2","date":"2018-09-10T13:14:30.000Z","updated":"2018-11-01T09:31:37.587Z","comments":true,"path":"2018/09/10/js2/","link":"","permalink":"http://www.maoxin.site/2018/09/10/js2/","excerpt":"烦人的thisJavaScript的表现与之前学的任何传统的语言都不一样，这个就很烦人，这几天把这个坑扫除了","text":"烦人的thisJavaScript的表现与之前学的任何传统的语言都不一样，这个就很烦人，这几天把这个坑扫除了 this到底指向什么总的来说，总结下，this其实取决于调用者的上下文环境，好比直接调用函数，是在全局作用域下的，就是直接this就是Window1234function fn()&#123; console.log(this)&#125;fn()//Window 而如果将作为对象中的属性，objA.objB.fun（）这个时候this就是objB12345678function fn()&#123; console.log(this)&#125;objA=&#123; a:123, myfun:fun&#125;objA.fun()//objA 同样的道理可以延伸到对象的事件，注册事件其实就是将对应对象的上下文环境中的某个属性例如click绑定一个函数，这样的话，函数内部的this就是调用者本身123document.querySelector(\"#btn\").onclick = function()&#123; console.log(this)&#125;//&lt;input type=\"button\"/&gt; 需要注意的是，理解什么是上下文环境，千万不要把上下文环境错认为就是所谓的作用域12345678910111213function fnChain_1() &#123; console.log(this) fnChain_2()&#125;function fnChain_2() &#123; console.log(this) fnChain_3()&#125;function fnChain_3() &#123; console.log(this)&#125;fnChain_1()//三个都是Window 上面实例代码是错误理解上下问环境的典范 new 操作符创建时的this首先看一个简单的函数12345function foo()&#123; console.log(this)&#125;foo()//Windownew foo()//foo 在这里需要校正的观念是这里不存在类似其他语言的new调用构造函数，而是使用了“构造调用”，使用构造调用的方式来创建一个新的对象new操作符执行的步骤如下： 首先创建一个新的对象 这个新对象执行[[原型]]链接 新对象会被绑定到执行函数调用的this简而言之，new操作的this有点类似其他语言的this下面是实例代码：1234567function foo(a) &#123; this.a = a;&#125;var a = new foo(2)var b = new foo(1)console.log(a)//foo&#123;a:2&#125;console.log(b)//foo&#123;a:1&#125; ES6的thisES6引入了箭头函数，这时this的表现与我们之前接触的又不一样了，具体不同点如下: 普通的函数的this取决于调用上下文 而ES6里面的this是继承父执行上下文的this实例代码如下：1234567891011121314151617181920212223242526272829//代码来自于https://blog.csdn.net/qq_38563845/article/details/78145814var name = \"window\";var obj = &#123; name: 'obj', //普通函数 one: function()&#123; console.log(this.name) &#125;, //箭头函数 two: ()=&gt; &#123; console.log(this.name) &#125;, //普通函数中的箭头函数 three: function()&#123; (()=&gt;&#123; console.log(this.name) &#125;)() &#125;, //多层箭头函数 four: ()=&gt; &#123; (()=&gt;&#123; console.log(this.name) &#125;)() &#125;&#125;obj.one(); //obj obj.two(); //window obj.three(); //objobj.four() //window 下面分析我们的想法来个例子：12345678910function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this); &#125;; &#125;; &#125;;&#125;foo()()()()//Window 如果将上面的代码改为：12foo().call(&#123;a:\"HelloWorld\"&#125;)()()()//&#123;a:\"HelloWorld\"&#125; 至于call是干什么的，接下来来解释 主动修改this？call&amp;apply&amp;bindcall 和 apply 的效果都是一样的，只是参数不同，他们显式的修改要执行函数的this指向，如果将这种指向被一个函数包起来，那么这个绑定就被不会被解绑了，例如这个12345678var obj = &#123; a:2&#125;function retValue()&#123; return function()&#123; return this.a &#125;.call(obj)//2&#125; 而apply就是有了参数12345//简单bind函数的实现，argument是参数列表function bind(fn, obj) &#123;return function() &#123; return fn.apply( obj, arguments );&#125;; 在 ES5 中提供了内置的方法 Function.prototype.bind，它的用法如下12345678910function foo(something) &#123; console.log( this.a, something ); return this.a + something;&#125;var obj = &#123; a:2&#125;;var bar = foo.bind( obj );var b = bar( 3 ); // 2 3console.log( b ); // 5 bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/tags/JavaScript/"}]},{"title":"JDBC设计思想","slug":"JDBC设计思想","date":"2018-08-29T03:29:33.000Z","updated":"2018-11-01T09:31:10.100Z","comments":true,"path":"2018/08/29/JDBC设计思想/","link":"","permalink":"http://www.maoxin.site/2018/08/29/JDBC设计思想/","excerpt":"更有利于了解JDBC建立链接过程的API","text":"更有利于了解JDBC建立链接过程的API 设计思想从《码农翻身》，作者：刘欣 一书中了解JDBC的设计思想： 首先，为了统一各大数据库不同数据库的具体实现，应该加一个抽象层，统一出一个一致的访问方式，利用接口规范方法，各大数据库厂商实现接口，这个问题可以解决。但是也引入了一个新的问题，这个问题就是在代码中要使用接口首先得声明具体实现，这就出现了违背了面向接口编程，是面向实现编程。 12Connection conn = new MySqlConnectionImpl(info)；//如果数据库厂商除了一个新的版本并且修改了名字是，MySqlConnectionJDBC4Impl,以上代码就无法编译通过 解决上面的问题就是再增加一个抽象层，类比我们计算机的外界设备的接口都是相同的，例如USB，但对不同的实现例如U盘，键盘只需安装不同的驱动即可，这样抽象出了一个驱动层，而JDBC吸收了这样的思想，抽象出一个Driver层。这个Driver层是一个简单工厂，其具体实现可以类比如下： 123456789101112public class Driver&#123; public static Connection getConnection(String dbType,Properties info)&#123; if(\"mysql\".equals(dbType))&#123; return new MySqlConnectionImpl(info); &#125; if(\"oracle\".equals(dbType))&#123; return new OracleConnectionImpl(info); &#125; //.... throw new RuntimeException(\"unsupported db type:\"+dbType); &#125;&#125; 这样其实是将原来的问题提升了个层次，在原来的代码中是不需要修改了，但是需要着重修改工厂方法中的具体实现，是相当于将问题转移。到目前为止我们是可以通过一下的方式来获取驱动： 1Connection conn = Driver.getConnection(\"mysql\",info); 正如上面所说，问题转移到了Driver这个静态工厂中，如果这个Driver是JDK提供的，那么就无法修改，除了修改又增加了一个问题。最后的解决方法是使用配置文件的方式，用配置文件这样“数据驱动”方式可以有效解决这样一个问题。但是这样的方式为用户暴露了太多东西，本身也是比较Low的，下面引入一种“工厂方法”的设计模式。 工厂方法与简单工厂最大的区别就是，工厂本身也变成了接口，将简单工厂中创建具体对象的责任通过厂商实现Driver接口来分配到各大厂商的JDBC实现类中去了，连创建都交给了数据库厂商的驱动中实现，这样对于我们自己写的程序就很少了，只需要使用类加载器加载驱动之后创建实例强转成Driver了类似与以下代码： 123456789public interface Driver&#123; public Connection getConnection(Properties info);&#125;public class MySqlDriver implements Driver&#123; public Connection getConnection(Properties info)&#123; return new MySqlConnection(info); &#125;&#125;//... 创建过程： 123Class&lt;?&gt;clz = Class.forName(\"com.coderising.mysql.MySqlDriver\");Driver driver = (Driver)clz.newInstace();Connection conn = driver.getConnection(info); 上面的代码已经相当于把职责分清楚了，数据库厂商负责Driver的具体实现，已经可以做到不用修改源代码了。这个时候唯一的问题就是将反射创建以及强转的过程暴露给开发者了，想办法再将反射隐藏操作隐藏起来，将Driver隐藏起来。这个时候就需要一个类来完成，通过这个类能够得到具体的Connection，而些Connection能来自不同的数据库厂商，因此它能够管理众多的数据库驱动。而数据库驱动本身也应该到这样一个类中注册。实现代码如下： 12345678910111213141516171819public DriverManager&#123; List&lt;Driver&gt; lists = new ArrayList&lt;Driver&gt;(); public static void register(Driver driver)&#123; if(!registeredDrivers.contains(driver))&#123; registeredDrivers.add(driver); &#125; &#125; public static Connection getConnection(String url,String user,String password)&#123; Properties info = new Properties(); info.put(\"user\",user); info.put(\"password\",password); for(Driver driver:registeredDrivers)&#123; Connection conn = driver.getConnection(url,info); if(conn!=null) return conn; &#125; throw new RuntimeException(\"can't create a connection\"); &#125;&#125; 过程回顾JDBC如何从面向实现编程到完全的面向接口编程的。 在出现面向实现编程的问题时，首先使用简单工厂这样一个抽象层使得通具体实现的解耦 在简单工厂需要频繁在代码中修改的时候使用数据驱动的方式使得修改的内容与类解耦 这样各大厂商的Connection的创建是由第三方来维护的，没有体现职责分明，就需要使用工厂方法，由JDBC定义接口Driver，将创建Connection的方法交给具体厂商实现。 上面已经可以解耦了，但是为了屏蔽反射细节，就使用DriverManager来统一管理驱动","categories":[],"tags":[{"name":"jdbc","slug":"jdbc","permalink":"http://www.maoxin.site/tags/jdbc/"}]},{"title":"从Java泛型谈起","slug":"从Java泛型谈起","date":"2018-08-29T03:19:39.000Z","updated":"2018-08-29T13:22:38.841Z","comments":true,"path":"2018/08/29/从Java泛型谈起/","link":"","permalink":"http://www.maoxin.site/2018/08/29/从Java泛型谈起/","excerpt":"","text":"泛型的好处在泛型出现之前，要想实现一个类型通用的实现必须要使用Object，而Object本身就是所有对象的父类，这就难免会由于类型检查的缺乏而影响程序本身。这些规范完全依赖于程序员的自律。这个时候如果既能保留C++泛型能创建通用代码的特性，又能对类型做到一定的检查就好了，而Java泛型应运而生，需要注意的是，Java语言是本身能够实现通用代码的编写的，而现在只需要对类型做一些限制，这和C++的泛型的思想有很大的不同，这就导致了Java的泛型采用了类型擦除的思路。 类型擦除与C++语言每次根据传入类型生成代码的“膨胀”法不同，Java使用了类型擦除机制来实现泛型，本质上还是Object，只不过就是增加了编译器检查，正因为如此，可以总结如下两个特性： 所写的泛型代码在最后都被擦除成Object 泛型可以不写强制转换的原因是编译的时候编译器加了自动的转型 精确的泛型泛型类与泛型方法总之就是一个&lt;T&gt;里面填写具体的泛型参数的表示,在类上申明就是泛型类，在方法上申明就是泛型方法。 12345678910//泛型类public class AbstractDao&lt;T&gt;&#123; &#125;//泛型方法public class Tools&#123; public static &lt;T&gt; T copyOf(T ori)&#123; //... &#125;&#125; 当一个类被实例化参数话之后，T全部变成了具体的类型 再加点限制: super &amp; extends泛型类或者泛型方法中的泛型逻辑需要利用一些特殊的类，例如需要某接口实现的方法等等，这个时候需要对这样一个具体的类进行限制，这种限制分为两种，上界和下界 extends 例子 1public static &lt;T extends Comparable&gt; void sort(T[] array); extends指定了上界，传入的元素会检查是否是Comparable的子类 super super指定上界。 精确泛型满足不了的场景这写情况发生再泛型参数赋值的情景。 我们上面讨论的都是精确的泛型，“精确的泛型”是我根据自己理解来描述的，它满足不了不需要精确泛型的应用场景：下面用码农翻身公众号的例子来说明： 当泛型遇到了继承的场景 12345678910public void print(ArrayList&lt;Fruit&gt; list)&#123; for(Fruit e:list)&#123; System.out.println(e); &#125;&#125;ArrayList&lt;Apple&gt; list = new ArrayList&lt;Apple&gt;();list.add(new Apple());list.add(new Apple());print(list)//编译错误 为什么会出现这个问题，说到底就是传入的参数类型不符，我们想要去做到一个不精确的匹配，为了达到这个目的，Java引入了通配符? 通配符Java引入的通配符来满足不精确匹配的场景，刚才由于List&lt;Fruit&gt;和List&lt;Apple&gt;是两个完全不同的类型，因此编译失败，两个不同的类型是不能直接赋值的，虽然里面的成分有继承关系。为了解决这个问题，引入了通配符，通配符就表示这个泛型实例的类型是未知的，那么，完成下面的赋值操作就是再正常不过的了： 12List&lt;?&gt; list = new ArrayList&lt;Integer&gt;();List&lt;?&gt; list = new ArrayList&lt;Double&gt;(); ? 的使用简单的说，？的使用场景 extends &amp; super https://segmentfault.com/a/1190000008423240#articleHeader0 泛型方法 https://www.cnblogs.com/shadowdoor/p/6817346.html http://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html https://blog.csdn.net/u010884123/article/details/78189395","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/tags/Java/"}]},{"title":"保护模式笔记","slug":"ProtectMod","date":"2018-08-17T02:01:16.000Z","updated":"2018-08-28T09:42:27.873Z","comments":true,"path":"2018/08/17/ProtectMod/","link":"","permalink":"http://www.maoxin.site/2018/08/17/ProtectMod/","excerpt":"","text":"段寄存器1mov dword ptr ds:[0x123456],eax ds就是段寄存器，真正读写的地址是：ds.base + 0x123456 其中段寄存器有8个 ES（）CS（）SS（）DS（）FS（）GS（）LDTR（）TR（Task Register） 段寄存器的结构32位的段寄存器一共96位，16位可见，80位不可见（12个字节） 123456struct SegMent&#123; WORD Selector;//16位的Selector（2字节）[可见部分] WORD Attribute;//16位Attribute 属性，标识可读可写可执行（2字节） DWORD Base;//32位Base 偏移地址（4字节） DWORD Limit;//32位Limit 段允许的地址偏移（4字节）&#125; 上面是用结构体来描述段寄存器的内容。 段寄存器的读写READ 段寄存器读取的时候只能读可见部分，16位，因此读的时候只能读16位 1MOV AX,ES WRITE 段寄存器写入的时候是要写96位 1MOV DS,AX 那么一个问题浮出水面，段寄存器赋值的时候可以写入96位，但是传递给的是一个16位的寄存器，那么另外的80位从哪里得到呢？ GDT 表和 LDT表GDT是全局描述符表，LDT是局部描述符表，要想填写完整段寄存器，需要拿着一个索引到GDT表或者LDT表去查找、这个索引就在传递的16位寄存器的数据当中。而这16位的数据对应到段寄存器的部分是段选择子。 段选择子 段选择子分为三部分，一个是Index，一个是Table Indicator 还有一个是请求特权级别RPL Index 13位，起到索引的作用，从GDT表或者LDT表中查找数据 索引查找的规则是将索引值乘以8再加上GDT或者LDT表的基地址，就是要加载的段描述符位置，也相当于2进制左移三位再加上基地址。 Table Indicator 表指示器 用来选择是从哪张表去选取 RPL 请求特权级别 其有两位，表示了0,1,2,3四种CPU特权访问级别 其代表这 001B= 0000-0000-0001-1011 段描述符段描述符是64位的数据，占据了8个字节，下面是其结构： 首先有个大致的印象，首先发现其Base属性和Limit被割裂到不同的部分，这主要是CPU寄存器升级为了向下兼容才形成的这样的情况。回顾段寄存器结构， Base一共32位，在段描述符描述完整 Limit一共32位，而在段描述符中只描述16+4=20位 其他部分充当段属性，应当是16位，在段描述符中描述完整，8位到第23位，23+1-8=16 以上并不能构成整个80位的除去段选择子的剩下部分，这是我们的问题，留在下面解决。 P位和G位P（Segment present） 位是表示段是否有效的位，当其=1代表有效，加载段描述首先要判断的就是P位是否标识该段描述符有效 G （Granularity） n. 间隔 ，它代表的是Limit描述数值的单位，如果G=0，那么单位就是字节，Limit在段描述符保存的值一共12位，因此Limit此时的最大范围是： (0000 0000-000F FFFF)如果G位位1，那么其是4KB，2^12，那么此时的范围是 (0000 0FFF-FFFF FFF) S位和Type域S (Descriptor type)位是一个描述段类型的位，当其=0的时候代表的是系统段描述符，当其=1的时候是代码段或者数据段的描述符，具体的信息由type域给出。 当S=1，代指的是代码段或者数据段，其Type域的值为： 简要描述下，第11位决定到底是代码段还是数据段，当位数据段的时候，第11位是0，此时 标识 解释 A 表示是否访问(Access)过 为1代表访问过 W 表示是否可写是，为1代表可写 E 为0向上拓展，为1向下拓展 所谓向上扩展还是向下扩展针对的是Limit限制的是向下一定范围能访问还是除了向下一部分范围不能访问。 如何快速判断一个段描述符描述的是代码段和数据段？就要熟悉其二进制表示： 12345678/*DPL 不是全0就是全1/32----24/23------20/19-----16/15---12/11-8/7--0//--BASE--/G|DB|0|AVL/--Limit--/P|DPL|S/TYPE/BASE/-------------------------------1 00 1----------/只需要看倒数第三第四位就可以迅速判断*/ 如果是代码段的话，要明确其含义是不同的： 标识 含义 A 是否访问过 R 是否可读 C 一致代码段还是非一致代码段=1表示一致，=0表示非一致 至于一致和非一致代码段代表的是是否可以越权访问，具体的区别在下面学习。 至于系统段描述符，先将其表格列举如下： D/B位D/B位代表的是(Default operation size)决定CPU的寻址方式,0代表的是16位寻址，该段也是16位段，1代表的是32位寻址，该段也是32位段，其寻址方式要对应。 段权限检查段权限检查是相对比较难理解的一部分，段权限的检查发生在段寄存器的变化，确定段寄存器是否能加载一个段描述符。 首先要知道的是CPU的保护模式之所以称之为保护是其有分级的制度，CPU一共4个不同的级别 CPU的特权级有四个，分别为0,1,2,3 windows 和 Linux操作系统都只使用了两个环，就是3环和0环，3环是应用程序的权限级别，而0环是系统内核的级别 那么如何查看当前程序跑在哪一环呢？这就需要查看CPL（Current Privilege Level）当前特权级别。 CS和SS段的段选择子中的RPL就是CPL（CPU不同的特权级都有其特定的栈） DPL在段描述符中，描述的是访问该段需要的最低权限 RPL描述的是我在能访问到DPL的前提下，我需要用怎样的权限去访问段 数据段的段权限检查CPL&lt;=DPL并且RPL&lt;=DPL 需要注意的是,段描述符分为三大类，代码段和系统段的权限检查和数据段的方式 代码的跨段执行首先代码的跳转，本身就依赖于段内跳转JMP，段间跳转JMP FAR，段内调用CALL，段间调用CALL FAR，段内返回RET，段间返回RETF，中断INT,中断返回IRETED； 代码的跨段执行，必然伴随着同时修改段寄存器以及EIP的值，同时修改CS和EIP的指令是： JMP FAR,CALL FAR,RETF,INT,IRETED则是同时修改寄存器和EIP的值 代码的段间跳转 1JMP 0x20:0x004183D7;操作数一共6个字节，前面两个段选择子，后面是偏移 执行步骤： 段选择子的拆分 0x20对应0000 0000 0010 0000 由于TI=0 所以查找GDT表 Index=4 找到对应的段描述符需要将Index*8+GDT表的基地址 判断段描述符的类型，四种情况是可以跳转的： 代码段 调用门 TSS任务段 任务门 权限检查，判断代码段的Type域内标明的是一致性代码段还是非一致性代码段 如果是非一致代码段，要求CPL==DPL,RPL&lt;=DPL 如果是一致性质代码段,要求CPL&gt;=DPL,当前特权级级别可以比一致代码段要求的要低的，专门给低权限来用的，完成所谓的共享的功能。 加载段描述符 通过上面权限检查之后，CPU会讲段描述符加载到CS段寄存器 代码执行 CPU将CS.BASE+OFFSET的值写入到EIP然后执行对应的代码段，段间跳转执行完毕 一致代码段和非一致代码段 对于一致代码段：也就是共享的段 特权级高的程序不允许访问特权级低的数据，核心态不允许访问用户态的数据 特权级低的程序可以访问到特权级高的数据，但是特权级不会改变：用户态还是用户态 C=0表示一致，C=1表示非一致 对于普通代码段：也就是非一致代码段 只允许同级访问 绝对禁止不同级别的访问：核心态不是用户态 直接对代码段进行JMP或者CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变，如果想要提升CPL的权限，只能通过调用门 简而言之，一致代码段高权限访问不了低权限的数据，低权限可以访问高权限的数据，但是RPL不会发生变化，非一致代码段很严格的1对1，只允许同级访问 长调用CALL FAR要比JMP FAR 复杂，因为JMP不影响堆栈，但是CALL会同时影响堆栈和EIP 情况一：跨段不提权 跨段不提权表示的是段要切换，而访问的代码段对应的段描述符所对应的DPL和当前的CPL是一样的，那么这个时候相比不同的，在段内的CALL指令不同的是其还需要在栈中保存一个原来代码段的段描述符CS 堆栈段先压入调用者CS，再压入返回地址。返回的时候注意使用RETF 情况二：跨段并提权 长调用跨段并提权，关键的变化在于提权，在切换CPU特权级别的时候注意，堆栈段也要发生变化，也就是说，要用新的堆栈（每一个特权级对应一个堆栈），现在总结一下，在 CALL CS:EIP这样的指令中，要在新的特权级的堆栈中保存以下内容：返回地址，原来的堆栈段描述符，原来的代码段描述符，调用者的ESP，这样就表现的原来的ESP毫无影响。 为什么说EIP是废弃的？ 对于跨权限调用的时候是要提权的，而提权的时候需要通过一个门，门内信息有一个段选择子，指向真正要跳转的段，门内信息还有真正的偏移，因此，对于CALL CS:EIP来说，其CS有用，EIP没有用，是废弃的，大致过程如下： CALL CS:EIP -&gt; 门描述符（偏移信息+段选择子）-&gt;高权限代码段描述符-&gt;段信息 总结 跨段调用的时候，一旦有权限切换，就会切换堆栈 CS的权限一旦改变，SS的权限也要随着改变，CS和SS的等级必须一样 JMP FAR只能跳转到同级非一致代码段，但是CALL FAR可以通过调用门提权，提升CPL的权限 SS与ESP从哪儿来，参见TSS段 调用门调用门执行流程 指令格式 CALL CS:EIP(EIP是废弃的) 执行步骤 根据CS的值，查GDT表，找到对应的段描述符，这个描述符是调用门 在调用门描述符中存储另一个代码段的段选择子 选择子指向的段的BASE+选择子内部包含的偏移地址=真正要执行的地址 首先调用门P=1，要想“敲门”DPL=11，第12位S=0，暂时不讨论门描述符的参数问题，Param Count = 0，而除了选择子，其也包含了32位的偏移。 0000EC00-00080000 8:1000 带有参数的调用门 注意，首先要使用有参数的调用门的时候参数必须要自己先压栈的（压入三环的堆栈） 先来观察下老师给的实例代码观察下： 可以看出在通过调用门提权之前，首先PUSH进三环堆栈3个参数，之后进行调用，在执行到裸函数的函数体内已经得到了提权，之后进行了两个相对陌生的指令： pushad,pushfd 查询相关资料: pushad: 将所有的32位通用寄存器压入堆栈 pusha:将所有的16位通用寄存器压入堆栈 pushfd:然后将32位标志寄存器EFLAGS压入堆栈 pushf::将的16位标志寄存器EFLAGS压入堆栈 popad:将所有的32位通用寄存器取出堆栈 popa:将所有的16位通用寄存器取出堆栈 popfd:将32位标志寄存器EFLAGS取出堆栈 popf:将16位标志寄存器EFLAGS取出堆栈 pushad push进去的寄存器按照顺序为EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX pushfd push进去的寄存器是32位标志寄存器 执行玩pushad和pushfd之后的esp下降了4*9=36 -&gt;0x24 调用门总结 当通过门，权限不变的时候，只会push两个值。CS，返回地址新的CS的值由调用门觉得 当通过门，权限改变的时候，会PUSH四个值。SS，ESP.CS返回地址 新的CS的值由调用门决定。新的SS和ESP由TSS提供 通过门调用的时候，要执行哪行代码由调用门决定，但使用RETF返回的时候，由堆栈中压入的值决定，这就是说，进门的时候只能按照指定路线走，出门的时候可以翻墙（可以想去哪就去哪） 中断门与陷阱门Windows没有使用调用门，但是使用了中断门，在windowsAPI当中使用中断门进入0环（现在新的CPU使用快速调用），中断的时候其实相当于在对于汇编就是0xCC(int 3)int 3就是用来执行中断门。中断门查询的表不是GDT表而是IDT表，是中断描述符，与GDT不同的是，IDT都是系统段描述符，并且第一个描述符不是都是0。 同样，LDT的地址可以通过以下的windbg命令来查看 12kd&gt; r ldtrkd&gt; r ldtl IDT表有三种描述符： 中断门描述符 任务门描述符 陷阱门描述符 其中中断门的结构如下： 陷阱门 陷阱门基本上和中断门差不多，关键就在中断门通过修改标志寄存器的IF位来屏蔽中断，而陷阱门不屏蔽 任务段在调用门，中断门与陷阱门中，一旦出现权限的切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须切换。切换的时候，会有新的ESP和SS(CS是由中断门或者调用门)这两个值从哪里来呢？这些都保存到TSS(Task Stage Segment)任务状态段中，TSS是在内存当中的。 里面保存了所有的通用寄存器以及标志寄存器ELF，以及CR3寄存器（在后面会接触到）以及不同的CPU权限等级对应的SS段选择子的值以及对应的ESP的值。 TSS注意事项 不要把TSS与“任务切换”联系在一起 TSS的意义就在于可以同时换掉“一堆”寄存器 TSS一共有104字节 CPU如何找到TSS TSS段描述符 当type的二进制是1001 = 9 的时候，是段描述符，没有加载到段寄存器当中 当type的二进制是1011 = B 的时候，也是段描述符，表示加载到了段寄存器当中 TR寄存器的读写 当TSS段描述符加载到TR寄存器 指令：LTR 说明： 用LTR指令去装载的话，仅仅是改变TR寄存器的值（96位），并不会改变TSS LTR指令只能在系统层调用（是特权指令） 加载后TSS 段描述符的状态位会发生变化（Type从9变为b） 读TR寄存器 指令 STR 说明：如果用STR去读的话，只读了TR的16位 也就是其选择子 分页","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.maoxin.site/categories/操作系统/"}],"tags":[{"name":"保护模式","slug":"保护模式","permalink":"http://www.maoxin.site/tags/保护模式/"}]},{"title":"struts2杂记（一）入门","slug":"struts2-1","date":"2018-08-16T10:21:20.000Z","updated":"2018-09-25T00:57:17.178Z","comments":true,"path":"2018/08/16/struts2-1/","link":"","permalink":"http://www.maoxin.site/2018/08/16/struts2-1/","excerpt":"","text":"Struts2 配置文件常量配置一些默认配置在导入的struts2-core.jar下有org.apache.struts2包下的default.properties文件，里面包含了一些配置，这些配置包含编码，请求扩展名，想要相应的修改就通过在struts.xml设置常量的方式 1&lt;constant name=\"struts.name.extension\" value=\"action,do,html\"&gt;&lt;/constant&gt; result子结点result子节点通过name与具体的execute方法返回值比对来完成控制器的功能，其中有隐含的type属性代表响应的类型，该默认值在struts-default中被指明： 1234567891011121314151617&lt;!--struts-default.xml--&gt;&lt;package name=\"struts-default\" abstract=\"true\" strict-method-invocation=\"true\"&gt; &lt;result-types&gt; &lt;result-type name=\"chain\" class=\"com.opensymphony.xwork2.ActionChainResult\"/&gt; &lt;result-type name=\"dispatcher\" class=\"org.apache.struts2.result.ServletDispatcherResult\" default=\"true\"/&gt; &lt;result-type name=\"freemarker\" class=\"org.apache.struts2.views.freemarker.FreemarkerResult\"/&gt; &lt;result-type name=\"httpheader\" class=\"org.apache.struts2.result.HttpHeaderResult\"/&gt; &lt;result-type name=\"redirect\" class=\"org.apache.struts2.result.ServletRedirectResult\"/&gt; &lt;result-type name=\"redirectAction\" class=\"org.apache.struts2.result.ServletActionRedirectResult\"/&gt; &lt;result-type name=\"stream\" class=\"org.apache.struts2.result.StreamResult\"/&gt; &lt;result-type name=\"velocity\" class=\"org.apache.struts2.result.VelocityResult\"/&gt; &lt;result-type name=\"xslt\" class=\"org.apache.struts2.views.xslt.XSLTResult\"/&gt; &lt;result-type name=\"plainText\" class=\"org.apache.struts2.result.PlainTextResult\" /&gt; &lt;result-type name=\"postback\" class=\"org.apache.struts2.result.PostbackResult\" /&gt; &lt;/result-types&gt; &lt;!--省略其他的内容--&gt;&lt;/package&gt; 下面对其中常用的几项做一个总结： dispatcher(默认):转发 redirect:重定向 redirectAction:重定向到一个Action 1234&lt;result type=\"redirectAction\"&gt; &lt;param name=\"actionName\"&gt;TestAction&lt;/param&gt; &lt;param name=\"namespace\"&gt;/maoxin&lt;/param&gt;&lt;/result&gt; 其指向的包定义为： 12345&lt;package name=\"testPackage\" namespace=\"/maoxin\" extends=\"struts-defult\"&gt; &lt;action name=\"testAction\" class=\"site.maoxin.TestAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 当眼重定向到Action也可以不用这个type 1&lt;result name=\"index\" type=\"redirect\"&gt;/maoxin/testAction.action&lt;/result&gt; chain:转发到一个Action 与之上同理，但是需要注意不能通过dispacter的方式转发到一个Action 通配符映射通配符映射是一种方便的写result标签的方式。 通配符映射规则 精确的将会覆盖不精确的，就是说明确指定的和通配符方式冲突的时候精确的会有效 指定的动作不存在，Struts将会尝试讲这个URI与任何一个包含通配符*的动作名进行匹配 被通配符匹配到的URI字符串可以用｛1｝,{2}来引用 {0}匹配整个URI 在Struts找到的带有通配符的匹配不止一个，则按照先后顺序进行匹配 *可以匹配0个或者多个字符，但是不包括/字符，如果想把/字符包含在内，就需要使用**，如果想要对某个字符进行转义，则需要使用 \\ 例子 1234&lt;action name=\"UserAction-*\" class=\"site.maoxin.UserAction\" method=\"&#123;1&#125;\"&gt; &lt;result name=\"&#123;1&#125;-success\"&gt;/success.jsp&lt;/result&gt; &lt;result name=\"&#123;1&#125;-failed\"&gt;/failed.jsp&lt;/result&gt;&lt;/action&gt; 1234567891011121314&lt;package name=\"test\" namespace=\"/test\" extends=\"struts-default\"&gt; &lt;action name=\"User_add\" class=\"site.maoxin.UserAction\" method=\"add\"&gt; &lt;result&gt;/User.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"User_Delete\" class=\"site,maoxin.UserAction\" method=\"delete\"&gt; &lt;result&gt;/User.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"Book_add\" class=\"site.maoxin.BookAction\" method=\"add\"&gt; &lt;result&gt;/Book.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"Book_delete\" class=\"site.maoxin.BookAction\" method=\"delete\"&gt; &lt;result&gt;/Book.action&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 上面的类型可以通过通配符映射转换为： 12345&lt;package name=\"test\" namespace=\"/test\" extends=\"struts-default\"&gt; &lt;action name=\"*_*\" class=\"site.maoxin.&#123;1&#125;Action\" method=\"&#123;2&#125;\"&gt; &lt;result&gt;/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 动态方法调用方式 首先需要打开动态方法调用： 1&lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"&gt;&lt;/constant&gt; 完成对Action的配置 123&lt;action name=\"test\" class=\"site.maoxin.Test\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt;&lt;/action&gt; 默认执行的就是execute方法，当在请求参数后面加上!后面跟上方法名就可以 Action类能够处理Struts2的请求的类，通过在struts2配置文件映射的方式来完成请求与相应action之间的关系 同一个Action可以有多个响应方法 Action类不同于Servlet，Servlet在内存中标只有一份拷贝，而Action一次请求创建一次 Action 类处理Web资源Web资源也就是：HttpServletRequest，HttpSession，ServletContext等等 与Servlet API解耦的方式所谓解耦就是不直接依赖，Struts2提供了以下方式来处理Web资源，解耦方式的缺点是： 一套新的，Struts2指定的操作方式 功能不够齐全，不如原生方式强大 下面是两种解耦的方式： 使用 Action Context方法 ActionContext对象是在请求经过过滤器的时候生成的，每一个ActionContext通过ThreadLocal容器里面获得的，其中提供了对应的方法来获取。而这一切都是在org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter 过滤器中完成转换并且装入的。 获取传入的request参数 12ActionContext ac = ActionContext.getContext();HttpParameters hps = ac.getParameters(); 其中HttpParameters是实现了Map&lt;String,Parameter&gt;，所以用Map的方式访问，将具体的参数值封装到Parameter这一对象中。通过Parameters.getValues来获取String[]属性的值。 获取并设置HttpServletContext域对象 12Map&lt;String,Object&gt;contextMap =ac.getApplication();contextMap.put(\"UserCount\",1); 获取并设置HttpServletSession 域对象 12Map&lt;String,Object&gt;sessionMap = ac.getSession();sessionMap.put(\"UserName\", \"Maoxin\"); Session有一个关闭Session的问题，要操作这个域对象失效就需要提供这个方法，由于其主体还是个Map的功能，所以推断getSession返回的是一个重新实现的Map，里面包含使得Session失效的方法，运行时进行调试，可以看出其本身返回的是SessionMap,查看对应的源代码： 12345678910111213public class SessionMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Serializable&#123; //... public void invalidate() &#123; if (session == null) &#123; return; &#125; synchronized (session.getId().intern()) &#123; session.invalidate(); session = null; entries = null; &#125; &#125;&#125; 设置request域属性的值 需要注意的是ActionContext没有直接提供对应的方法，而之上的所有域对象本身也都是从ActionContext的构造方法内部的构造函数中传入的context对象得到的，而这个对象是OgnlMap类型，里面还有很多对象，因此，如果试图想要获取request域对象的值的话，可以通过： 12Map&lt;String,Object&gt; requestMap = (Map&lt;String, Object&gt;) ac.get(\"request\");requestMap.put(\"requestDispatcher\", \"转发的数据\"); 实现对应的Aware接口 相对来说比较麻烦： 首先要实现具体的接口，比如想对Application对象做操作，就要实现ApplicationAware对象接口 其次要在类中设置要注入对象的引用（依赖注入） 设置引用的getter和setter方法 如何选用 若Action对象包含多个Action方法，多个Action方法使用域对象的Map或者Parameters，则建议使用Aware接口的方式 与Servlet API 耦合的方式使用ServletActionContext 获取Request对象 1ServletActionContext.getRequest() 获取HttpSession对象getRequest().getSession() 获取ServletContext对象getServletContext() 实现ServletXxxAware的方式 道理同上 默认的Action类：ActionSupport12public class ActionSupport implements Action, Validateable, ValidationAware, TextProvider, LocaleProvider, Serializable &#123;&#125; 所谓默认的Action类，其实就是result标签不绑定具体class指向的具体的类，这个具体的类同样在默认继承的包struts-default.xml下被指明，具体如下: 1&lt;default-class-ref class=\"com.opensymphony.xwork2.ActionSupport\" /&gt; 打开ActionSupport类查看定义首先实现了众多接口，第一个接口是Action 12345678public interface Action &#123; public static final String SUCCESS = \"success\"; public static final String NONE = \"none\"; public static final String ERROR = \"error\"; public static final String INPUT = \"input\"; public static final String LOGIN = \"login\"; public String execute() throws Exception;&#125; Validateable 需要手动实现验证 ValidateAware TextProvider LocaleProvider","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/tags/Java/"}]},{"title":"ClassLoader总结","slug":"ClassLoader总结","date":"2018-08-05T13:06:58.000Z","updated":"2018-11-01T09:29:16.590Z","comments":true,"path":"2018/08/05/ClassLoader总结/","link":"","permalink":"http://www.maoxin.site/2018/08/05/ClassLoader总结/","excerpt":"在学习过程中，一次又一次的遇到类加载器的问题，一次又一次的重新去看，感觉有必要对ClassLoader的知识做一个详细的总结，以便于之后能熟练运用ClassLoader。","text":"在学习过程中，一次又一次的遇到类加载器的问题，一次又一次的重新去看，感觉有必要对ClassLoader的知识做一个详细的总结，以便于之后能熟练运用ClassLoader。 ClassLoader是什么类加载器，.class文件描述的具体信息在加载到JVM之后才能被运行和使用，加载这些文件到虚拟机的过程就是类加载的过程。JAVA本身相较于其他语言的灵活性与Java本身可以在运行期动态加载息息相关。 类的生命周期 类加载过程 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 类使用过程 使用（Using） 卸载（unloading） 注意： 类的解析阶段的顺序可能不按照上面自上而下的顺序，在某些情况下是在类的初始化之后开始 类加载器的作用 完成类加载过程中实线类加载的动作 类加载器和一个类本身一同确定一个类的唯一性 判断Class类对象是否相等，主要包括： Class类对象的equals()方法 对象与Class类之间的instanceof关键字或者是isInstance()方法 Class对象的isAssignableForm()方法（PS：Assignable 可分配的） 1234567891011121314151617181920212223242526272829303132333435//深入理解Java虚拟机代码清单7-7package demo;import java.io.IOException;import java.io.InputStream;public class ClassLoaderTest &#123; public static void main(String[] args)throws Exception &#123; ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt;loadClass(String name) throws ClassNotFoundException&#123; try &#123; String fileName = name.substring(name.lastIndexOf(\".\")+1) +\".class\"; InputStream is = getClass().getResourceAsStream(fileName); if(is==null) &#123; return super.loadClass(name); &#125; byte[]b = new byte[is.available()]; is.read(b); return defineClass(name,b,0,b.length); &#125;catch(IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myLoader.loadClass(\"demo.ClassLoaderTest\").newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof demo.ClassLoaderTest); &#125;/**运行结果：*class demo.ClassLoaderTest*false*/ 上面代码注意的点是其重写的loadClass方法不满足双亲委派模型，所以能够出现不同的不同加载器加载的同名Class Java的ClassLoader 分类 从Java虚拟机的角度而言，只存在两种ClassLoader 启动类加载器（BootStrap ClassLoader） 使用C++实现，是Java虚拟机的一部分 在Java程序中获取不到，会返回为null 其他的类加载器 独立于Java虚拟机之外 继承子抽象类java.lang.ClassLoader 用Java语言描述 从开发人员角度 启动类加载器（BootStrap ClassLoader） 负责加载%JAVA_HOME%\\lib目录中的，或者被-Xbootclasspath指定的路径 可以通过System.getProperty(&quot;sun.boot.class.path&quot;)查看路径 扩展类加载器（Extension ClassLoader） 由sun.misc.Launcher$ExtClassLoader实现 负责加载%JAVA_HOME%\\lib\\ext目录的类库 可以通过System.getProperty(&quot;java.ext.dirs&quot;)查看 可以通过参数制定路径 应用程序类加载器（Application ClassLoader） 由sun.misc.Launcher$AppClassLoader实现 负责加载用户路径上制定的类库 可以通过System.getProperty(&quot;java.class.path&quot;)查看 1234567891011121314151617//查看具体的路径package demo;import java.io.File;import java.util.StringTokenizer;public class Test &#123; public static void main(String[] args) &#123; String paths = System.getProperty(\"java.class.path\"); if(paths!=null) &#123; StringTokenizer st = new StringTokenizer(paths, File.pathSeparator); int count = st.countTokens(); for(int i=0;i&lt;count;i++) System.out.println(st.nextToken()); &#125; &#125;&#125; 双亲委派模型双亲委派模型并不难，用文字解释就是： 如果一个类加载器其收到类加载请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器返回自己无法完成这个加载请求的时候，子类才加载。–《深入理解Java虚拟机》 上面的解释很标准，但是需要注意不是一拿到一个类加载请求就去加载，而是先在缓存中查看是否已经加载过了。 上述这些操作，在ClassLoader的loadClass()方法中定义，查看源码 1234567891011121314151617181920212223242526272829303132333435363738394041protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 首先，检测是否已经加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false); &#125; else &#123; //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //父加载器没有找到，则调用findclass c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; //调用resolveClass() resolveClass(c); &#125; return c; &#125; &#125; 为什么使用双亲委派？ 上面谈到，对JVM而言只有两种类加载器，一个是BootStrap ClassLoader，一个是Java自定义的，首先之所以分成两个正是满足Java语言在运行是时动态加载的需求。 如果不使用双亲委派机制，重要的基础类被恶意修改再加载到JVM引起混淆引发安全问题 违反双亲委派模型首先需要明白，双亲委派模型的缺陷：（感谢知识星球（码农翻身）球友的解释） 补充知识：类加载器的命名空间 子能看见父，父却不能看见子，这就是双亲委派的弊端，当前类引用了其他类，当前类的类加载器就负责就在加载那些引用类 例如JDBC的DriverManager，这个类是由根加载器加载的，它里面需要调用厂商的实现类（mysql），但是mysql的jar包不在rt.jar 所在的目录里，一般都是放在项目的lib文件夹里面，根据JVM的加载规则根就没办法去加载mysql的驱动，压根就看不见实现类 在Thread类有个成员叫做classLoader，在sun.misc.Launcher类中设置该成员，其中Ext和AppClassLoader都是在这个类初始化的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Launcher &#123; private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() &#123; return launcher; &#125; private ClassLoader loader; public Launcher() &#123; // Create the extension class loader ClassLoader extcl; try &#123; extcl = ExtClassLoader.getExtClassLoader(); &#125; catch (IOException e) &#123; throw new InternalError( \"Could not create extension class loader\", e); &#125; // Now create the class loader to use to launch the application try &#123; loader = AppClassLoader.getAppClassLoader(extcl); &#125; catch (IOException e) &#123; throw new InternalError( \"Could not create application class loader\", e); &#125; //设置AppClassLoader为线程上下文类加载器 Thread.currentThread().setContextClassLoader(loader); &#125; /* * Returns the class loader used to launch the main application. */ public ClassLoader getClassLoader() &#123; return loader; &#125; /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader &#123;&#125;/** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader &#123;&#125; 杂项 loadClass(String className,boolean isInitialized)的第二个参数设置为false可以提高类加载的性能 类加载器的应用注意事项： 如果想维持双亲委派模型，我们就不应该去覆盖loadClass()方法,如果仅仅是想写自己的加载逻辑，应该覆盖findClass()完成记载逻辑，这样就可以保证双亲委派,到最后调用defineClass()完成相关的操作。 双亲委派模型 1234567891011121314151617package demo;public class ClassLoaderA extends ClassLoader &#123; public ClassLoaderA() &#123; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; //自己的findClass逻辑，如果自己的发生异常就交给默认的findClass去处理 //try &#123; // return defineClass(b, off, len); //&#125;catch(..) &#123; //&#125; return super.findClass(name); &#125;&#125; 违反双亲委派模型 见第一个代码片段 加载一个指定包下的所有类 12345678910111213141516//ClassHalper,代码源于《架构探险-从零开始写JavaWeb框架》//类原型public class ClassUtil &#123; //ClassUtil需要的类加载器 public static ClassLoader getClassLoader()&#123; //... &#125; //利用该函数加载package下面的Class文件 public static Class&lt;?&gt; loadClass(String className,boolean isInitailized)&#123; //... &#125; //获取Package下所有的Class文件并加载到Set中去 public static Set&lt;Class&lt;?&gt;&gt; getClassSet(String packageName)&#123; //... &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//具体实现package demo;import java.io.File;import java.io.FileFilter;import java.net.URI;import java.net.URL;import java.util.Enumeration;import java.util.HashSet;import java.util.Set;public class ClassUtil &#123; public static ClassLoader getClassLoader() &#123; return Thread.currentThread().getContextClassLoader(); &#125; //使用Class.forName的形式来加载类 public static Class&lt;?&gt; loadClass(String className,boolean isInitailized)&#123; Class&lt;?&gt; cls; try &#123; cls = Class.forName(className,isInitailized,getClassLoader()); &#125;catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; return cls; &#125; public static Set&lt;Class&lt;?&gt;&gt; getClassSet(String packageName)&#123; Set&lt;Class&lt;?&gt;&gt; classSet = new HashSet&lt;Class&lt;?&gt;&gt;(); try &#123; Enumeration&lt;URL&gt; urls = getClassLoader().getResources(packageName.replace('.', '/')); while(urls.hasMoreElements()) &#123; URL url = urls.nextElement(); if(url!=null) &#123; String protocal = url.getProtocol(); //如果协议名称是file的时候就将%20转义为空格 if(protocal.equals(\"file\"))&#123; String packagePath = url.getPath().replaceAll(\"%20\",\"\"); //调用真正执行递归添加类的方法 addClass(classSet,packagePath,packageName); //如果协议名称是jar的时候就用jar特有的方式读取 &#125;else if(protocal.equals(\"jar\")) &#123; //... &#125; &#125; &#125; &#125;catch (Exception e) &#123; System.out.println(\"get class set failure\"); throw new RuntimeException(e); &#125; return classSet; &#125; //执行根据包下路径 private static void addClass(Set&lt;Class&lt;?&gt;&gt; classSet,String packagePath,String packageName) &#123; File[] files = new File(packagePath).listFiles(new FileFilter() &#123; @Override public boolean accept(File file) &#123; //如果是目录，或者是以class为末尾的文件就返回true return (file.isFile()&amp;&amp;file.getName().endsWith(\".class\")||file.isDirectory()); &#125; &#125;); for(File file:files) &#123; //如果是一个文件，就直接做处理将XXX.class的名字解析出来,组合成全类名之后加载 String fileName = file.getName(); if(file.isFile()) &#123; String className = fileName.substring(0, fileName.lastIndexOf(\".\")); doAddClass(classSet,className); &#125;else &#123; //如果是一个目录就进一步组合成进一步目录 String subPackagePath = fileName; subPackagePath = packagePath+\"/\"+subPackagePath; //这个时候的全类名就深入了一步 String subPackageName = packageName+\".\"+fileName; //递归的进行添加 addClass(classSet,subPackagePath,subPackageName); &#125; &#125; &#125; //添加到具体的Set中去 private static void doAddClass(Set&lt;Class&lt;?&gt;&gt; classSet,String className) &#123; Class&lt;?&gt; cls = loadClass(className,false); classSet.add(cls); &#125;&#125; 类文件的加密与解密 12 对ClassLoader的学习暂时到这里，后续会不断的补充。 参考文章 https://blog.csdn.net/briblue/article/details/54973413 超详细java中的ClassLoader详解 https://blog.csdn.net/zhangzeyuaaa/article/details/42499839 全盘负责和双亲委托 《码农翻身》 刘欣 电子工业出版社","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/tags/Java/"},{"name":"ClassLoader","slug":"ClassLoader","permalink":"http://www.maoxin.site/tags/ClassLoader/"}]},{"title":"蛋疼的JavaScript(一)：作用域与闭包","slug":"js-1","date":"2018-08-01T06:55:37.000Z","updated":"2018-11-01T09:31:15.380Z","comments":true,"path":"2018/08/01/js-1/","link":"","permalink":"http://www.maoxin.site/2018/08/01/js-1/","excerpt":"在使用JavaScript的时候各种奇葩的结果真的让人头大，于是系统的学习一下JavaScript的一些知识。深入了解下JavaScript。（注：以下均为浅尝则止）","text":"在使用JavaScript的时候各种奇葩的结果真的让人头大，于是系统的学习一下JavaScript的一些知识。深入了解下JavaScript。（注：以下均为浅尝则止） JavaScript 的坑创建变量的时候，我们一般用： 1var a = 2; JS引擎在看到上述代码的时候会做两步操作 创建符号a对应的内存空间（解释阶段） 将基本类型2放置到a对应的内存空间当中（执行阶段） 也就是说var 带有声明变量的作用，如果有以下代码: 1a=2; JS解释器先发现了符号a，试图去找a的内存地址在哪，没有找到，它不会返回给程序员什么错误，而是自作主张在顶层作用域内创建了a的符号，再执行a=2的操作，其他语言不是这样的，不了解这个过程使用JS就是噩梦的开始。。(处理不好就会导致符号的泄漏) 注意到上面的a都是被赋值的对象。如果a作为右值呢？ 1var b = a; 这个时候JS引擎就不能自作主张的生成全局变量a，因为a的值不确定，这个时候它查找a符号没有找到，就乖乖的告诉你a is not defined 这是作为左值和右值的区别，我们应该将左和右概念更泛化一下。 左值就是符号被赋值的过程 右值就是符号内容取得的过程 那么很快就能反应过来函数调用的函数参数的传入是一个符号作为右值传入的过程，这就够了。 换个角度讲，作为左值符号未声明的时候自动创建也可以叫一个特性，如果我们指定其在哪个作用域中查找符号，这样就可以动态的添加属性： 12345var A=&#123; name:\"Maoxin\"&#125;;A.age = 18;console.dir(A) 符号作用域前面就提到全局作用域，这相当于一个全局变量，而有其他语言经验的我们也知道局部变量。在重名情况下符号是就近原则，内部的能访问到外部的定义的变量，而这一切的原因其实就是压栈，函数调用的时候栈的提升，之前的变量在栈底，新的局部变量在栈提升的这部分中，所以子函数作用域能够访问到外部的作用域是合情合理的，这JavaScript也一样，但是唯一不一样的是对类似if分支，循环等等的处理。我们在使用类似C/C++/Java中，这么用是不可以的： 1234567#include&lt;stdio.h&gt;int main(int args,char **argv)&#123; for(int i=0;i&lt;10;i++)&#123; printf(\"%d\",i); &#125; printf(\"%d\",i);//错！&#125; 因为循环这个东西内部创建的变量就像一个函数的作用域一样，但是JS不是这样的。在JS中允许如下代码是可以的： 1234for(var i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i) 原因在于循环变量 123&#123; var i = 0&#125; 是创建在这个块作用域之外的。。 这样显然对于从其他语言迁移过来的很不好使，怎么创建一个就像之前语言的变量一样的东西呢？其实可以使用ES6引入的let let const 与 var let 可以创建一个块作用域的变量 const 也是块作用域的变量，不过就像其他语言的const一样，赋值之后不可修改 var 。。略 等下，let是ES6引入的，难道，之前用JS要时时刻刻被这个问题困扰？他们是怎么解决的。 下面是一个实例： 12345for(var i = 0;i&lt;5;i++)&#123; setTimeout(function()&#123; document.write(i+'&lt;br&gt;') &#125;,i*1000)&#125; 运行这个实例，刚开始会和惊讶，怎么输出的都是6？ 只要知道setTimeout是异步的，不会立即执行 ，在结合上面的内容就清楚了原因。原因就是，for都执行完了之后i=6，那么我们怎么让他正常一些？问题的根源就在于其i的作用域，我们引用了外部的i，这个i的值已经是6了。JS和其他语言的不同之处就是在块作用域的表现不同。函数作用域还是可以的，于是我们可以尝试这么改进，每次传入的i值都将其拷贝一份放在一个更小的作用域中： 12345678for(var i=1;i&lt;=5;i++)&#123; (function(i)&#123; var j = i; setTimeout(function()&#123; document.write(j+'&lt;br&gt;') &#125;,i*1000) &#125;)(i)&#125; 猛地看挺奇怪的，但要是说明白了（函数）(参数)这种形式就是将一个参数传入即将执行的函数中去就会好明白一些，我们就是强行再加了一个函数作用域将这个i当前的值保护起来放置在j中。 当然现在不用这么麻烦： 12345for(let i = 0;i&lt;5;i++)&#123; setTimeout(function()&#123; document.write(i+'&lt;br&gt;') &#125;,i*1000)&#125; 我们之前说了很多都是作用域从大到小，内部的能看到外部的。但是回顾上面的过程，我们发现一个很有趣的现象，尽管块内的函数已经执行完了，setTimeout函数却记得它内部需要引用外部的值。这表示那些看似执行完的块的某些值并没有随着执行完毕而被垃圾回收，这就是闭包。 闭包 当函数可以记住并访问所在词法作用域的时，就产生了闭包，及时函数是在当前词法作用域之外进行的。–《你不知道的JavaScript上》","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maoxin.site/tags/JavaScript/"}]},{"title":"Java验证码图片创建","slug":"Java验证码图片创建","date":"2018-07-29T08:49:02.000Z","updated":"2018-11-01T09:30:15.747Z","comments":true,"path":"2018/07/29/Java验证码图片创建/","link":"","permalink":"http://www.maoxin.site/2018/07/29/Java验证码图片创建/","excerpt":"最近需要实现一个验证码生成工具类，之前完全没有接触过Java图形方面的知识，临时上网查阅资料，总结下自己学到的内容，到最后学习实现一个自己可以用的上的工具类,所有参阅的资料都在文末的引用部分。","text":"最近需要实现一个验证码生成工具类，之前完全没有接触过Java图形方面的知识，临时上网查阅资料，总结下自己学到的内容，到最后学习实现一个自己可以用的上的工具类,所有参阅的资料都在文末的引用部分。 java.awt下的Image类与BufferedImage java.awt.Image ：抽象类Image是表示图形图像的所有类的超类 java.awt.image.BufferedImage 是Image的子类，描述具有可访问图像数据缓冲区的Image 总得来说，Image通常用来获取图片，BufferedImage做图片修改操作如大小变换等 Graphics 与Graphics2DGraphics类是所有的图像上下文类的抽象基类，这些图形上下文允许应用程序绘制在各种设备上实现的组件以及屏幕外的图像上。 图形对象封装了Java支持的基本呈现操作所需的状态信息。 Graphics2D 类扩展 Graphics 类，以提供对几何形状、坐标转换、颜色管理和文本布局更为复杂的控制。它是用于在 Java(tm) 平台上呈现二维形状、文本和图像的基础类 获取Graphics对象 通过继承BufferedImage对象实例获得：BufferedImage.createGraphics()/getGraphics(); 继承Swing组建的paintComponent(Graphics g)方法 转型为Graphics2D 对象 Graphics2D可以通过setRenderingHint(RenderingHints.key,RenderingHints.value)方法是否设置图形反锯齿、文字反锯齿、设置图像的插入方法、绘制方法、是否支持抖动等属性。 stroke 属性 stroke属性用于控制线条的宽度、笔形样式、线段连接方式或短划线图案。 如果我们要设置stroke属性，则应当先创建Stroke引用的对象，但由于Stroke为接口类型，所以我们要创建对象，可以创建其已知实现类BasicStroke的对象。 1g2d.setStroke(new BasicStroke(float width,int cap,int join)); width 笔画的宽度 cap 端点的样式 join是两线段交汇的连接方式 （具体详细解释请查看文末引用原博主博客） clip属性 clip属性用于实现剪裁效果。设置剪裁属性可调用如下方法确定剪裁区的Shape 1public abstract void setClip(int x, int y, int width, int height) paint属性 paint属性控制填充效果，通过调用setPaint()方法设置： 其函数传入对应的Paint对象 注意： paint可以同时作用在边线和填充上，可以是单色，渐变和图案，任何paint都需要实现java.awt.Paint接口 因为Color类实现了java.awt.Paint接口，所有的Color对象都是Paint对象。 一些特殊的Paint类： GradientPaint类 12public GradientPaint(float x1, float y1, Color color1, float x2, float y2, Color color2) 这个类用颜色渐变填充一个区域，构造函数指定定比例和颜色。图形引擎会从第一个点到第二个点之间线性变化两个颜色：从(x1,y1)到(x2,y2)颜色从c1渐变到c2。我们还可以指定颜色图案是否允许重复。 TexturePaint类： 1public TexturePaint(BufferedImage txtr, Rectangle2D anchor) 这个类平铺一个图像来填充图形，构造函数接收一个java.awt.image.BufferedImage和一个Rectangle2D，把图像影射到矩形里，然后平铺矩形。 我们可以先创建GradientPaint类或TexturePaint类的对象，再调用Graphics2D的setPaint()方法设置填充效果。 Font属性 所有的文本都使用能表现文字的样式图形渲染。当前的字体决定了字体的形状。使用继承自java.awt.Graphics的getFont()方法和setFont()方法来操纵字体。 Transform属性 transform属性用来实现常用的图形平移、缩放和斜切等变换操作。我们可以调用setTransform()来设置transform属性： 1public abstract void setTransform(AffineTransform Tx) 该方法需要一个AffineTransform对象的参数，所以首先创建AffineTransform对象，然后调用setTransform()方法设置transform属性。最后，用具有指定属性的Graphics2D对象绘制图形。 创建AffineTransform对象的方法有： 123456789101112131415// 旋转变换，旋转theta弧度public static AffineTransform getRotateInstance(double theta)// 绕旋转中心(anchorx, anchory)旋转public static AffineTransform getRotateInstance(double theta, double anchorx, double anchory)// 缩放变换，x和y方向分别按sx,sy比例变换public static AffineTransform getScaleInstance(double sx, double sy)// 错切变换，shx和shy指定斜拉度public static AffineTransform getShearInstance(double shx, double shy)// 平移变换，tx和ty表示x和y方向平移距离public static AffineTransform getTranslateInstance(double tx, double ty) 当然，也可以先创建一个没有transform属性的AffineTransform对象，然后用以下方法指定图形平移、旋转、缩放变换属性： 1234567891011// 将图形在x轴方向平移tx像素，y轴方向平移ty像素public void translate(double tx, double ty)// 旋转theta弧度public void rotate(double theta)// 图形以点(anchorx, anchory)为轴点，旋转theta弧度public void rotate(double theta, double anchorx, double anchory)// 图形在x轴方向缩放sx倍，纵向缩放sy倍public void scale(double sx, double sy) composit属性 composit属性设置图形重叠区域的效果。可通过调用setComposite()方法设置该属性： 1public abstract void setComposite(Composite comp) 例如先用方法AlphaComposite.getInstance(int rule, float alpha)得到AlphaComposite对象，再通过setComposite()方法设置混合效果。AlphaComposite在图形和图像中实现混合和透明效果，Alpha值的范围为0.0f(完全透明)-1.0f(完全不透明)。 使用Graphics2D绘图Graphics2D类仍然保留Graphics类的绘图方法，同时增加了许多新方法。新方法将几何图形(线段、圆等)作为一个对象来绘制。在java.awt.geom包中声明的一系列类，分别用于创建各种身体图形对象。常用的主要有： Line2D - 线段类 RoundRectangle2D - 圆角矩形类 Ellipse2D - 椭圆类 Arc2D - 圆弧类 QuadCurve2D - 二次曲线类 CubicCurve2D - 三次曲线类。 要用Graphics2D类的新方法画一个图形。先在重画方法paintComponent()或paint()中，把参数对象g强制转换成Graphics2D对象；然后，用上述图形类提供的静态内部类构造方法Double()或Float()创建该图形的对象；最后，以图形对象为参数调用Graphics2D对象的draw()方法绘制这个图形。 画一条线段： 123456/* 画线 */Stroke s = new BasicStroke(20, BasicStroke.CAP_ROUND, BasicStroke.JOIN_MITER);g2d.setStroke(s); Line2D line = new Line2D.Double(30,50,100,200);g2d.draw(line);123456 画一个圆角矩形： 123456/* 画圆角矩形 */g2d.setColor(Color.BLUE);RoundRectangle2D rect = new RoundRectangle2D.Double(100, 50, 100, 50, 4, 4);g2d.draw(rect);123456 画一个旋转一定角度的矩形： 123456/* 画旋转一定角度的矩形 */Rectangle2D rect2 = new Rectangle2D.Double(60, 160, 60, 90);AffineTransform transform = new AffineTransform();transform.rotate(45 * Math.PI / 180, 90, 200); // 围绕(90,200)点旋转图形45度g2d.setTransform(transform);g2d.draw(rect2); 消除锯齿12g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_DEFAULT); 注意：绘制完图像后记得用dispose()方法释放资源 验证码生成的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286//验证码原实现博主是CSDN的The...Exception的大佬，在这里做了简单的修改以及添加了大量的注释来巩固上面的知识。import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.LinearGradientPaint;import java.awt.Paint;import java.awt.RenderingHints;import java.awt.geom.AffineTransform;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.Arrays;import java.util.Random; import javax.imageio.ImageIO; public class VerifyCodeUtils&#123; //使用到Algerian字体，系统里没有的话需要安装字体，字体只显示大写，去掉了1,0,i,o几个容易混淆的字符 //这个也是默认的字符源 public static final String VERIFY_CODES = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZ\"; private static Random random = new Random(); /** * 使用系统默认字符源生成验证码 * @param verifySize 验证码长度 * @return */ public static String generateVerifyCode(int verifySize)&#123; return generateVerifyCode(verifySize, VERIFY_CODES); &#125; /** * 使用指定源生成验证码 * @param verifySize 验证码长度 * @param sources 验证码字符源 * @return */ public static String generateVerifyCode(int verifySize, String sources)&#123; if(sources == null || sources.length() == 0)&#123; sources = VERIFY_CODES; &#125; int codesLen = sources.length(); //用当前时间作为随机生成种子在一定程度上达到了真随机 Random rand = new Random(System.currentTimeMillis()); //使用StringBuilder做到不断的附加随机字符 StringBuilder verifyCode = new StringBuilder(verifySize); for(int i = 0; i &lt; verifySize; i++)&#123; verifyCode.append(sources.charAt(rand.nextInt(codesLen-1))); &#125; return verifyCode.toString(); &#125; /** * 生成随机验证码文件,并返回验证码值 * @param w * @param h * @param outputFile * @param verifySize * @return * @throws IOException */ public static String outputVerifyImage(int w, int h, File outputFile, int verifySize) throws IOException&#123; String verifyCode = generateVerifyCode(verifySize); outputImage(w, h, outputFile, verifyCode); return verifyCode; &#125; /** * 输出随机验证码图片流,并返回验证码值 * 先生成具体的随机验证码，再去生成对应的图片 * @param w * @param h * @param os * @param verifySize * @return * @throws IOException */ public static String outputVerifyImage(int w, int h, OutputStream os, int verifySize) throws IOException&#123; String verifyCode = generateVerifyCode(verifySize); outputImage(w, h, os, verifyCode); return verifyCode; &#125; /** * 生成指定验证码图像文件 * @param w * @param h * @param outputFile * @param code * @throws IOException */ //生成图片保存的位置,抛出异常通知上层 public static void outputImage(int w, int h, File outputFile, String code) throws IOException&#123; //没有输出文件的情况下先退出 if(outputFile == null)&#123; return; &#125; //由于File中的路径直接使用mkDir生成的都是文件夹，因此需要先找到父文件夹先判断生成文件夹 File dir = outputFile.getParentFile(); if(!dir.exists())&#123; dir.mkdirs(); &#125; //再去生成具体的文件 try&#123; outputFile.createNewFile(); FileOutputStream fos = new FileOutputStream(outputFile); outputImage(w, h, fos, code); fos.close(); &#125; catch(IOException e)&#123; throw e; &#125; &#125; /** * 输出指定验证码图片流 * @param w * @param h * @param os * @param code * @throws IOException */ public static void outputImage(int w, int h, OutputStream os, String code) throws IOException&#123; int verifySize = code.length(); //创建BufferedImage BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB); Random rand = new Random(); //获取Graphics2D对象 Graphics2D g2 = image.createGraphics(); //设置抗锯齿 g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON); //Colors数组 Color[] colors = new Color[5]; //ColorSpaces数组 Color[] colorSpaces = new Color[] &#123; Color.WHITE, Color.CYAN, Color.GRAY, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE, Color.PINK, Color.YELLOW &#125;; float[] fractions = new float[colors.length]; //随机从ColorSpace找到五种颜色和五个 //TODO for(int i = 0; i &lt; colors.length; i++)&#123; colors[i] = colorSpaces[rand.nextInt(colorSpaces.length)]; fractions[i] = rand.nextFloat(); &#125; Arrays.sort(fractions); //绘制背景，之后只保留一部分，所以是绘制边框 g2.setColor(Color.GRAY);// 设置边框色 g2.fillRect(0, 0, w, h); Color c = getRandColor(200, 250); g2.setColor(c);// 设置背景色 g2.fillRect(0, 2, w, h-4); //绘制干扰线 Random random = new Random(); g2.setColor(getRandColor(160, 200));// 设置线条的颜色 for (int i = 0; i &lt; 20; i++) &#123; int x = random.nextInt(w - 1); int y = random.nextInt(h - 1); int xl = random.nextInt(6) + 1; int yl = random.nextInt(12) + 1; g2.drawLine(x, y, x + xl + 40, y + yl + 20); &#125; // 添加噪点 float yawpRate = 0.05f;// 噪声率 int area = (int) (yawpRate * w * h); for (int i = 0; i &lt; area; i++) &#123; int x = random.nextInt(w); int y = random.nextInt(h); int rgb = getRandomIntColor(); image.setRGB(x, y, rgb); &#125; shear(g2, w, h, c);// 使图片扭曲 //设置字体颜色 g2.setColor(getRandColor(100, 160)); int fontSize = h-4; Font font = new Font(\"Algerian\", Font.ITALIC, fontSize); g2.setFont(font); char[] chars = code.toCharArray(); for(int i = 0; i &lt; verifySize; i++)&#123; AffineTransform affine = new AffineTransform(); affine.setToRotation(Math.PI / 4 * rand.nextDouble() * (rand.nextBoolean() ? 1 : -1), (w / verifySize) * i + fontSize/2, h/2); g2.setTransform(affine); g2.drawChars(chars, i, 1, ((w-10) / verifySize) * i + 5, h/2 + fontSize/2 - 10); &#125; //清除 g2.dispose(); ImageIO.write(image, \"jpg\", os); &#125; //生成一个随机的颜色，在bc-fc是其RGB分量的范围 private static Color getRandColor(int fc, int bc) &#123; //对输入参数进行过滤 if (fc &gt; 255) fc = 255; if (bc &gt; 255) bc = 255; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125; //用int类型值去保存RGB三个分量，这里用到左移，之后用逻辑加进行处理 private static int getRandomIntColor() &#123; int[] rgb = getRandomRgb(); int color = 0; for (int c : rgb) &#123; color = color &lt;&lt; 8; color = color | c; &#125; return color; &#125; //生成随机颜色，RGB分量由数组保存 private static int[] getRandomRgb() &#123; int[] rgb = new int[3]; for (int i = 0; i &lt; 3; i++) &#123; rgb[i] = random.nextInt(255); &#125; return rgb; &#125; private static void shear(Graphics g, int w1, int h1, Color color) &#123; shearX(g, w1, h1, color); shearY(g, w1, h1, color); &#125; private static void shearX(Graphics g, int w1, int h1, Color color) &#123; int period = random.nextInt(2); boolean borderGap = true; int frames = 1; int phase = random.nextInt(2); for (int i = 0; i &lt; h1; i++) &#123; double d = (double) (period &gt;&gt; 1) * Math.sin((double) i / (double) period + (6.2831853071795862D * (double) phase) / (double) frames); g.copyArea(0, i, w1, 1, (int) d, 0); if (borderGap) &#123; g.setColor(color); g.drawLine((int) d, i, 0, i); g.drawLine((int) d + w1, i, w1, i); &#125; &#125; &#125; private static void shearY(Graphics g, int w1, int h1, Color color) &#123; int period = random.nextInt(40) + 10; // 50; boolean borderGap = true; int frames = 20; int phase = 7; for (int i = 0; i &lt; w1; i++) &#123; double d = (double) (period &gt;&gt; 1) * Math.sin((double) i / (double) period + (6.2831853071795862D * (double) phase) / (double) frames); g.copyArea(i, 0, 1, h1, 0, (int) d); if (borderGap) &#123; g.setColor(color); g.drawLine(i, (int) d, i, 0); g.drawLine(i, (int) d + h1, i, h1); &#125; &#125; &#125; public static void main(String[] args) throws IOException&#123; File dir = new File(\"verifies\"); int w = 200, h = 80; for(int i = 0; i &lt; 50; i++)&#123; String verifyCode = generateVerifyCode(4); File file = new File(dir, verifyCode + \".jpg\"); outputImage(w, h, file, verifyCode); &#125; &#125;&#125; 参考资料： https://bbs.csdn.net/topics/250022320 BufferedImage与Buffer的区别 https://docs.oracle.com/javase/7/docs/api/java/awt/Graphics.html Graphics文档 https://blog.csdn.net/zlxtk/article/details/53995049 Java Graphics初探 https://blog.csdn.net/zhliro/article/details/45645569 Java Graphics2D类的绘图方法 https://blog.csdn.net/ruixue0117/article/details/22829557 Java生成验证码","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/tags/Java/"}]},{"title":"动态规划入门","slug":"动态规划入门","date":"2018-07-29T00:40:17.000Z","updated":"2018-07-29T03:37:42.383Z","comments":true,"path":"2018/07/29/动态规划入门/","link":"","permalink":"http://www.maoxin.site/2018/07/29/动态规划入门/","excerpt":"","text":"最长公共子序列参考邓俊辉老师《数据结构》的MOOC 理解问题 两个序列的子序列指的是，由序列中的若干字符，按照原来的相对次序组成的。其中有几个注意事项 可能同时有多个最长公共子序列，同时有多个意味着在不影响最长的前提下，在某个部分可能由不同的匹配结果，而几个 不同的匹配结果却不能合并，顺序是交叉的。用邓俊辉老师的例子是这样的： educational advantage 前面匹配da没问题，倒着看匹配a没问题，中间可以匹配t也可以匹配n，不能同时匹配因为其出现次序不同 可能有歧义，某一个字符同时出现两次 didactical advantage data 减而治之的思想得到递归程序 最简单最一般的情况就是其中有一个序列已经被减到空了，那么就不可能对应的序列了 在减小规模的过程中 最后两个相等，就直接得到这个公共字符 最后两个不等 分情况递归查找 1234567891011121314151617181920212223242526public class Main &#123; //最长公共子序列的递归算法 //递归算法整体采用减而治之的思想 public static String LCS(String str1,String str2,int index1,int index2) &#123; //递归基，当其中有一个串已经完成的时候结束 if(index1==-1||index2==-1) &#123; return \"\"; &#125; //第一种情况，当末尾字符匹配的时候 if(str1.charAt(index1)==str2.charAt(index2)) &#123; return LCS(str1,str2,index1-1,index2-1)+String.valueOf(str1.charAt(index1)); //当不匹配的时候分成两种情况讨论，(分而治之)取其中最长的 &#125;else &#123; String a = LCS(str1,str2,index1-1,index2); String b = LCS(str1,str2,index1,index2-1); return a.length()&gt;=b.length()?a:b; &#125; &#125; public static String LCS(String str1,String str2) &#123; return LCS(str1,str2,str1.length()-1,str2.length()-1); &#125; public static void main(String[] args) &#123; System.out.println(LCS(\"program\", \"algorithm\")); &#125;&#125; 递归存在的问题 减而治之已经带有大量重复计算的过程了，但是它又来了一个分而治之。。 改进的策略 类比斐波那契数列，斐波那契数列只用减而治之，改为迭代算法一方面可以对每一个计算结果进行保存，另一方面其计算结果依赖于前两项，对这两项从前到后的迭代也可以解决。LCS问题稍有不同的是，它有了分而治之，假设其所有的子问题都可以用M[A,B]A,B分别为子序列的长度。这些子问题构成的是一个二维的视图，求解M[A,B]在不能直接缩小问题规模的情况下（所谓直接缩小就是最后一个比对字符相等的情况下）就会比较M[A-1,B]和M[A,B-1]这两个问题的解谁大。 既然所有的子问题都可以用M[A,B]表示，设A的长度为m，B的长度为N，那么解决这些子问题远远比通过递归解决效率高得多。时间复杂度也是0(m*n) 这个表示解的二维数组的生成过程就是一个问题从最简单到复杂的过程。最简单的问题就是递归基表示的，其中有个序列为空了。之后就从左到右，从上到下扩展问题的规模。在下面的实现算法只表示LCS的字符的个数。 12345678910111213141516public static int LCS(String str1,String str2) &#123; int[][] solve = new int[str1.length()+1][str2.length()+1]; for(int i=0;i&lt;str1.length();i++) &#123; for(int j=0;j&lt;str2.length();j++) &#123; if(str1.charAt(i)==str2.charAt(j)) solve[i+1][j+1]=solve[i][j]+1; else &#123; int a = solve[i][j+1]; int b = solve[i+1][j]; solve[i+1][j+1]=a&gt;b?a:b; &#125; &#125; &#125; return solve[str1.length()][str2.length()]; &#125; 在牛客网中查询相应的习题，对代码在其规定的环境中略作修改即可通过。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.maoxin.site/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.maoxin.site/tags/算法/"}]},{"title":"Windows进程的创建过程","slug":"Windows进程的创建过程","date":"2018-07-28T12:54:37.000Z","updated":"2018-11-01T09:32:50.699Z","comments":true,"path":"2018/07/28/Windows进程的创建过程/","link":"","permalink":"http://www.maoxin.site/2018/07/28/Windows进程的创建过程/","excerpt":"什么是进程？进程是空间上的概念，程序在内存中的一个抽象，包含程序的数据代码等等具体的内容。而线程是一个时间上的概念，我们在创建一个进程的时候一般同时创建一个线程，所以很容易在进程和线程的含义上区分不清楚。","text":"什么是进程？进程是空间上的概念，程序在内存中的一个抽象，包含程序的数据代码等等具体的内容。而线程是一个时间上的概念，我们在创建一个进程的时候一般同时创建一个线程，所以很容易在进程和线程的含义上区分不清楚。 Windows进程创建过程内存中的程序是其本身文件的映射。Windows的PE文件格式和Linux的ELF文件格式都是源于COFF文件格式，该格式是分段划分的，以满足对动态链接的要求以及对每个段数据的管理与保护，在32位操作系统下，windows 的PE文件格式会映射到一个2GB（低地址，高2G是操作系统占用的）大小的虚拟地址空间，这些地址空间由PE文件映射而来，同时加载许多动态库文件。对虚拟内存地址空间大致是如下的分布： 分区 32位windows 空指针赋值区域 0x00000000-0x0000FFFF 用户模式区 0x00010000-0x7FFEFFFF 64KB禁入区 0x7FFF000-0x7FFFFFFF 内核 0x80000000-0xFFFFFFFF 下面是进程具体的创建过程： 映射EXE文件 创建内核对象EPROCESS 映射系统DLL(ntdll.dll) 创建线程内核对象ETHREAD 系统启动线程 映射DLL（ntdll.LdrlnitializeThunk） 线程开始执行 从大的方面来讲，分为两步，创建进程，创建线程 这两方面也都有共同点 都对应着内核对象，分别是EPROCESS和ETHREAD，这些都是由操作系统管理，在OS的高2G当中 都需要映射dll，只不过进程是映射ntdll，线程启动时映射的是PE文件需要的dll，是递归加入的 不同点在于 线程需要操作系统启动。 注意点： 进程都是由其他的进程创建的！第一个进程是由OS启动创建的。 CreateProcess在这里暂时不贴具体的API参数，而是先去大致学习明白它需要什么。 子进程的概念 由于进程都是由父进程创建（除了第一个创建的进程），所以引出子进程的概念 创建子进程类似运行一个程序，类比命令行： 1dir files/ 一个是这个程序路径和名字（得到程序在哪里，文件名对具体的文件索引是有一个映射的,文件名是对具体文件位置的抽象表示） 第二个是命令行参数，执行前的附加参数 第三个比较隐含，就是父进程的部分信息，这个“部分信息”包含以下内容： 父进程的环境变量 -&gt;是否继承？ 父进程信息 STARTUPINFO结构体（创建进程的时候由父进程填充），子进程通过GetStartupInfo来获取 其次，我们应该去指明，创建这个进程的方式是什么？如何去创建。主要包含以下内容 最后，我们应该返回创建的进程和线程的标识信息，方便之后的程序步骤进行处理 进程句柄，进程ID 线程句柄，线程ID","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.maoxin.site/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.maoxin.site/tags/操作系统/"},{"name":"Windows","slug":"Windows","permalink":"http://www.maoxin.site/tags/Windows/"}]},{"title":"Linux学习（命令）","slug":"Linux 学习（命令）","date":"2018-07-27T14:46:41.000Z","updated":"2018-07-28T12:21:35.909Z","comments":true,"path":"2018/07/27/Linux 学习（命令）/","link":"","permalink":"http://www.maoxin.site/2018/07/27/Linux 学习（命令）/","excerpt":"","text":"Linux常用命令的学习，不间断更新，逐渐让它完整 Shell 操作 history 显示之前输入过的命令 Ctrl+P 一直向上遍历（从下向上） Previous Ctrl+N 向下遍历 （也可以向上向下）Next 光标控制 Ctrl + B （Back Forward） Ctrl + F（Forward） Ctrl +D （Delete）删除光标盖住的（之后的）一个字符 Ctrl + U 删除光标前面的字符串 Ctrl + K 删除光标后面的字符串 Tab 自动补全 文件目录结构 / /bin ：二进制文件,包含命令等等可执行程序（其中绿色的代表可执行程序，浅蓝色是软链接（快捷方式），红色是，要想显示颜色实际上执行的指令是ls –color=auto ） /dev: device 在Linux下一切皆文件，里面包含了CPU，显卡，内存，显示器等设备的抽象 /lib：Linux运行的时候需要加载的一些动态库 /mnt: 手动挂载目录 /media: 自动挂载目录 /root ：Linux超级用户的家目录 /usr: unix system resource Unix系统资源目录 /include 头文件 /game 游戏 /local 用户安装的应用程序目录 /etc 配置文件 /passed 存储的不是密码，是用户的信息 /group 存储用户组信息 /opt: 安装第三方应用程序 /home 用户的家目录（宿主目录） /tmp: 存放临时文件 重启清空 命令学习（基本操作）tree -&gt;(查看目录) 查看一个目录的内容 tree 查看当前目录 tree dir 查看指定目录 ls -&gt;（查看文件和目录） 查看文件和目录 参数 -a 显示所有文件和目录，包括隐藏文件（以.开头的） -l 列出详细信息 -rwxrw-r– 1 kevin kevin 321145 11月 23 23:08 hello.txt 第一个字符：文件的类型 7种 普通文件：- .txt 压缩包 可执行程序 目录：d 符号链接：I 管道:p 套接字：s 字符设备：c 键盘，鼠标 块设备：b U盘，硬盘 之后就是文件所有者，文件所有组，其他人的权限 再之后的1是硬连接计数 在后来的用户名是文件所有者 再后来的名字是文件所属组的文字 后面的文字是文件的大小 如果是目录，看到的大小永远是4K （ls -lh）是目录本身的大小 日期 文件名 -f 格式化，如果是目录就加/ alias -&gt;（查看命令别名）常用的命令比如 ls =’ls –color=auto’ ll =’ls -alF’ pwd -&gt;（查看当前目录）Print Work Dictionary cd -&gt;（切换目录） cd ~ 切换到家目录 cd 退出目录 cd - 最后两个相邻的，目录特别长的时候适用 mkdir -&gt;(创建目录) mkdir 文件名 ：直接创建路径 mkdir 路径/文件名 创建子目录 mkdir 路径/文件名 -p 可以一次性创建多级目录 touch -&gt;（创建文件） touch 文件名 如果文件不存在，创建新文件，如果存在，则会更新时间而不做任何操作 rmdir -&gt;（删除空目录）注意只能删除空目录，功能比较弱 rm -&gt;(删除命令) 删除目录 直接删除也会提示’无法删除，是一个目录’ 树形结构需要递归删除，因此需要加上参数-r 删除文件 rm 文件名 -i 删除的时候给提示 -I 注意问题 删除之后，很难恢复 cp -&gt;（拷贝） cp 要拷贝的文件 拷贝目的 如果拷贝目的不存在则会创建这个文件并拷贝 cp file1 file2（存在）则会覆盖文件的内容 cp file dir（存在） 拷贝file到dir cp dir dir1（存在） 将dir拷贝到dir1，直接使用会提示略过，拷贝时候需要递归的拷贝，所以应该加-r cp dir dir1（不存在） 将dir里面的内容copy到新创建的目录中，注意不包括源dir名字 mv -&gt;(改名或者移动文件) 改名 mv file（存在）file1（不存在） mv dir（存在）dir1（不存在） 移动 mv file（文件） dir（存在） 将file移动到目录中去 mv dir1（存在）dir2(存在) 将dir1移动到dir2中 mv file（存在）file2 覅了文件会覆盖file2文件 cat -&gt;（将内容打印到终端）文件特别多，大于终端显示上限，只能显示一部分 more-&gt;（查看更多） 回车向下 空格翻页 不能回去 按下q退出 less-&gt;（可以向上）与more相同，但是可以向上翻页，可以用page up键也可以用Ctrl +P，向下Ctrl+N head -&gt;（显示前？行）可以通过加入参数来设置 12head -5 stdio.h# 默认是10行 tail -&gt;(显示后？行)同上 ln -&gt;（创建快捷方式） 软链接 –快捷方式 ln -s 它的大小对应的是其字节数 当移动之后或许会发生快捷方式失效的，这是因为是相对路径 在创建的时候使用绝对路径就可以防止移动之后的快捷方式失效 目录也可以创建软链接 硬连接 ln 文件名 相对路径或者绝对路径没有关系 认识inode结点 磁盘上的数据块是由索引节点号inode来表示 OS并不对文件名感兴趣，每个文件是由其inode决定的 因此inode不占用磁盘空间 创建一个文件，硬链接计数为1 给文件创建了硬连接，链接+1，删除一个-1 如果inode为0，那么标识为废弃，再写入新文件的时候会覆盖，如果非0会进行保护 使用场景 磁盘上有一个文件 需要再其他多个目录管理这个文件，并且能够实时同步 硬连接是直接对应inode号，软链接是对应文件路径 参考资料： https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html 理解 Linux 的硬链接与软链接 命令学习（用户权限，用户和用户组）chmod-&gt;（修改文件或者目录的权限） 文字设定法 chmod who[+|-|=]mode 文件名 Who： u -User 文件所有者 g-group 文件所属组 o-other 其他人 a -all 所有人 +|-|= mode r:读 w:写 x:执行 -：没有任何权限 12# 所有者添加读权限，同组用户减去执行权限chmod u+r,g-x file.c 数字设定法 chmod [+|-|=] mode 文件名 mode： r: 100-&gt; 4 w:010-&gt;2 x:001-&gt;1 -:0 chown-&gt;(修改文件所有者或者所属组) chown 新的所有者 文件名 chown 新的所有者：新的组 文件名 如何查看用户和组？ /etc/passwd 用户 /etc/group 组 也可以修改组 chgrp-&gt;（修改文件所有组）只能修改对应的组 chgrp 新的组 文件名 扩展 一个目录必须有可执行权限才能打开，否则就无法打开 文件的查找和检索find-&gt;(根据文件属性查找) 文件名 find 查找的目录 -name “查找的文件名” 文件类型 find 查找到目录 -type 文件类型 Linux 下的七种文件类型 普通文件（-），目录（d），磁盘链接（l），管道（p pipeline），套接字（s），字符设备（c），块设备（b） 文件大小 find 查找的目录 -size +10k （查看大于10k的文件） +:大于 -：小于 等于：直接写 单位： k - 小写 M-大写 大于10k小于100k：find . -size +10k -size -100k 按照日期 创建日期： -ctime -n/+n -n:n天以内 +n：n天以外 修改日期：-mtime 访问日期：-atime 深度 -maxdepth n(层数)搜索n层已下的目录 -mindepth n(层数)表示搜索n层以上的目录 -name 制定名字 find itcast/ -maxdepth 3 -name programer 高级查找 例，查找制定目录，并列出该目录中文件的详细信息 find ./ -type d -exec ls -l {} \\; find ./ -type d -ok ls -l {} \\; OK比较安全 find ./-type d | xargs ls -l 管道一端是Read端，一端是Write端 grep -&gt;(根据文件内容查找) 搜索目录有子目录的时候需要加上-r grep -r “查找的内容” 搜索的路径 搜索家目录中带有helloword字符串的文件 grep -r “helloworld” ~ 显示在第几行 1grep -r \"stdio.h\" ~ -n 压缩包管理 Linux下常见的压缩格式 .gz –gzip 压缩：gzip 文件1，文件2… -k(保留源文件) 解压缩：gunzip *.gz 不能压缩目录 .bz2 -bzip 常用压缩命令： tar -打包 参数： c-创建压缩文件 x-释放压缩文件 v-打印提示信息 f-制定压缩包的名字 z-使用gzip压缩文件-&gt;xxx.tar.gz j -使用bzip2的方式压缩文件-&gt;xxx.tar.bz2 压缩 tar 参数 压缩包名字 原材料。。。 1tar zcvf test.tar.gz file1... 解压缩 tar 参数 要解压包的名字 1tar zxvf test.tar.gz rar rar需要安装 压缩 rar a 压缩包名（不需要指定后缀） 压缩的内容 注意压缩的时候是不压缩子目录的 所以就需要再后面加上-r 解压缩 rar x 压缩包名 解压的目录 zip/unzip 压缩： zip 参数 压缩包名 原材料 如果有目录就是-r 解压缩 unzip 压缩包的名字 -d 解压目录 -O 制定编码 软件的安装与卸载（Ubnutu)apt-get在线安装 16.04版本之上就可以直接apt就可以 安装 sudo apt-get install tree 卸载 sudo apt-get remove tree 软件列表的更新 sudo apt-get update 注意只是更新列表，列表是所有可安装程序的URL 清空缓存 sudo apt-get clean 对应的目录在var/cache/apt/archives 存储的是deb包 deb软件包安装方式 安装 sudo dpkg -i xxx.deb sudp dpkg -r 软件名","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.maoxin.site/categories/操作系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.maoxin.site/tags/Linux/"}]},{"title":"Linux系统函数学习","slug":"Linux系统函数学习（更新中）","date":"2018-07-27T14:45:37.000Z","updated":"2018-07-29T04:39:45.081Z","comments":true,"path":"2018/07/27/Linux系统函数学习（更新中）/","link":"","permalink":"http://www.maoxin.site/2018/07/27/Linux系统函数学习（更新中）/","excerpt":"","text":"Linux系统函数的学习，不间断更新，直到完整 从fopen看文件FILE结构体​ 在使用fopen打开文件返回的是FILE结构体，之前并不了解其内部，只是大致会用而已，在这里首先剖析FILE结构体。 FILE结构体的内容很多，主要分为以下部分 FILE 文件描述符（整形值）FD 文件描述符内部有inode信息，再通过inode找到具体的文件 文件读写指针位置 FP_POS 首先读写指针是一个指针，因此在切换读写文件的时候需要fseek来移动文件指针 对于文件读写是对应的二进制读取，文本文件读取信息的资料补充 知乎：fopen 为什么要区分文本模式和二进制模式？ https://www.zhihu.com/question/24662572 牵扯到了BOM，下面为总结： BOM（byte-order mark）它用来标识该字节流的字节序，是高位在前还是低位在前。从Unicode3.2开始，BOM只能位于流的开头，只能用于标识字节序。 UTF-8: 若为UTF-8有BOM格式，则文件开头为 EF BB BF； 若为UTF-8无BOM格式，则不能依据上述规则；此时需要依据UTF-8编码格式来判断 I/O缓冲区（内存地址）BUFFER C标准函数都有Buffer I/O缓存区域，根据存储器层次结构，硬盘会比内存慢100万倍，因此要增设缓存，默认是8K，同样需要注意的是IO的形式除了默认的，还有以下形式： 直接IO 内存映射文件的形式 读写过程： 例如Printf(“Hello World”); 调用write函数将文件描述符传入（系统API write(fd,”hello”,5)）完成将”hello”用户空间到内核空间的传递 系统调用sys_write 使用设备驱动，通过设备驱动函数写入到驱动操作硬件 显示器显示 虚拟地址空间32位操作系统当一个可执行文件允许起来成为一个进程的时候操作系统会为其分配一个4G的地址空间，虚拟内存是分段的，而其根据局部性原理也不是一次性加载的，而是分页的 下面是对虚拟地址空间做一个详细的总结，虚拟地址空间的引出和计算机的发展历程是离不开的的。 在早期的计算机中，程序是直接运行在物理内存上的，程序直接访问的是物理地址，这种模式的限制在于，只要程序要求的内存空间不要超过超过物理内存的大小，就不会有问题，但是为了提高CPU的使用效率，我们更期望的是同时运行多个程序，现在关键的问题在于，能运行的程序受限于物理内存的大小以及运行程序本身的大小。所以一个需要关键解决的问题就是如何将有限的物理内存分配给多个程序使用，也就是内存分配问题，但除了内存分配问题，传统的方式还存在许多问题。 地址空间不隔离导致程序的安全性不足，一个程序的崩溃会影响到其他程序，恶意程序可以轻松修改其他程序的数据，总而言之，缺乏安全稳定性 内存地址分配随机就让程序内部的重定位工作（运行地址不确定）变得异常麻烦 内存使用效率低下 内存切换过程（将完整程序换入到硬盘或者将完整换出）效率十分低下 如果引入一个中间层，在外部忽视内存地址的差异，在内部执行一个转换到真实地址的过程，就可以轻松解决第一第二点，这就是虚拟内存。虚拟内存使得应用程序不需要考虑自己加载到什么地方。相互之间也起到了隔离的作用，程序与程序之间安全性得到了一定的保障。但是第三个第四个仍然没有解决。内存毕竟是有限的。为了能让在内存的程序尽可能的多，当然是程序占用内存越小越好，但是程序变小不可能的。但这个思路得以运用，将程序加载到内存的粒度缩小，采用分页模式就有效的解决的这个问题。 在以上的描述中，并没有深入研究CPU如何做到将虚拟内存映射到实际内存的过程，也没有研究页是如何被操作系统管理，缺页的时候怎么办等等，这个在之后学习。 程序都是按照一定格式存储的，由操作系统统一加载。在内存中映射为4GB的虚拟内存空间（32位）这样的文件格式是分段的，很好的解决了一些资源共享的问题，比如动态库的共享，也为每一个应用程序提供了一个统一的视图，完成功能，下面是Linux的ELF文件在内存的映射 内核区：内存管理，进程管理，设备驱动管理，VFS虚拟文件系统（4G-3G linux） 环境变量 env 命令行参数 int main(int argc,char* argv[])中的参数 栈空间（小）向下增长 共享库 堆空间（大）向上增长 .bass（未初始化的全局变量）全局变量=0 .data（已初始化全局变量） .text（代码段 二进制机器指令） 受保护的地址（0-4K）其中0是收保护的地址，这也就是NULL的作用 文件描述符表内核进程管理里面由一个叫做PCB(进程控制块)每个进程都在其PCB中保存着一份文件描述符表，而文件描述符作为这个表的索引可以让我们快速的查到每个表项对应的打开文件的指针，文件描述符表最多可以存储1024个文件描述符 用户不能直接访问具体的文件描述符，就只能通过文件描述符表的下标由内核函数访问。 文件描述符前3个分别是STDIN_FILENO 标准输入 STDOUT_FILENO 标准输出 STDERR_FILENO 标准错误默认是打开状态，根据该文件描述符可以读写当前终端，每打开一个新文件，则占用一个文件描述符，而且是空闲的最小的一个文件描述符 文件描述符内含有inode信息，具体的介绍查看: http://www.docin.com/p-941544538.html 豆丁网-inode,文件描述符 Linux的open函数返回的int类型就是文件描述符表对新创建文件的下标，也就是文件描述符 而系统函数read传入文件描述符，就可以清楚的知道要操作哪一个文件。 系统函数系统函数在man帮助文档的第二章 Open函数查看文档 1man 2 open 头文件 123#include&lt;sys/types.h&gt; //宏定义#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt; open函数看起来是函数重载的原因是使用了变长参数 123int open(const char* pathnamae,int flags);//第三个参数是在第二个参数有效的情况下才有意义int open(const char* pathname,int flags,mode_t mode); 返回值：文件描述符，失败返回-1 参数 flags 必选项目 O_RDONLY,O_WRONLY,O_RDWR 可选项目 创建文件：O_CREATE 创建文件时检测文件是否存在：O_EXCL 如果文件存在，返回-1 必须与O_CREAT一起使用 追加文件：O_APPEND:文件指针移动到末尾 文件截断：O_TRUNC ：做文件清空的情况 设置非阻塞：O_NONBLOCK mode 八进制文件权限 注意设置的权限不等于最终的权限值 （mode&amp;~umask） umask是0002 close函数关闭文件描述符 read函数write函数","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.maoxin.site/categories/操作系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.maoxin.site/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://www.maoxin.site/tags/操作系统/"}]},{"title":"Java反射基础","slug":"Java反射基础","date":"2018-07-27T14:44:59.000Z","updated":"2018-11-01T09:30:09.716Z","comments":true,"path":"2018/07/27/Java反射基础/","link":"","permalink":"http://www.maoxin.site/2018/07/27/Java反射基础/","excerpt":"Java反射机制的学习 什么是反射？ JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 –百度百科","text":"Java反射机制的学习 什么是反射？ JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 –百度百科 Class类 - 反射的根源Class类描述Class类是对应类文件的描述，可以说是class字节码的抽象，这种描述包含：类名、构造函数以及成员函数、属性，它是对应对象的模板，用它可以去实例化类类对象。 得到Class类的三种方法 Object中有getClass方法。 一个具体的类.class 通过Class类中的静态方法forName。使用Class来实例化对象 使用newInstance来实例化，该对象调用的是无参数的构造方法，如果没有默认的构造方法就会报错！因此在使用反射框架的时候注意尽量保留默认构造方法。 使用getConstructors用有参的方式来进行实例化该方法返回所有的构造方法。返回的是一个Constructor对象的数组,Constructor对象包含函数名信息，参数个数等等： 1234567891011121314public class ref &#123; public static void main(String[] args) &#123; Class&lt;Dog&gt; dogClass = Dog.class; Constructor[] constructors = dogClass.getConstructors(); for(Constructor constructor:constructors)&#123; System.out.println(constructor.getName());//名字 System.out.println(constructor.getParameterCount());//参数个数 Class[] classes = constructor.getParameterTypes();//参数类型 for(Class _class:classes)&#123; System.out.println(_class); &#125; &#125; &#125;&#125; 可以使用getConstructor来获取制定的构造器。 获取构造器中可以使用newInstance来进行初始化。12Dog dog = (Dog)constructor.newInstance(1,\"Hello\");System.out.println(dog); 访问属性 通过getFiled属性来得到属性，返回Filed[]对象，注意这样得到的只能是共有的属性。如果是想得到全部的属性值需要使用getDeclaredFileds方法。1234567891011121314151617181920212223242526//Dog类class Dog &#123; public int id; private String name; public Dog(int id,String name)&#123; this.id = id; this.name = name; &#125; public Dog(int id)&#123; this.id = id; this.name=\"NULL\"; &#125; @Override public String toString() &#123; return this.id+this.name; &#125;&#125;public class ref&#123; public static void main(String[] args) &#123; Field[] fields = Dog.class.getFields(); Field[] fields1 = Dog.class.getDeclaredFields(); System.out.println(fields.length); System.out.println(fields1.length); &#125;&#125; 得到Field对象之后可以得到相应的属性与方法。12345678910public static void main(String[] args) &#123; Field[] fields = Dog.class.getFields(); Field[] fields1 = Dog.class.getDeclaredFields(); for(Field field:fields1)&#123; System.out.println(field.getName());//得到名字 System.out.println(field.getDeclaringClass());//得到类 System.out.println(field.getModifiers());//得到修饰符，返回是int System.out.println(Modifier.toString(field.getModifiers()));//通过Modifier的静态方法转换 // System.out.println(field.); &#125; 获取包的信息得到包需要使用到Class类中的getPackage的方法，返回一个Package对象可以通过Package对象的方法得到其中的具体信息123Class&lt;Dog&gt; dogClass = Dog.class;Package pack = dogClass.getPackage();System.out.println(pack.getName()); 获得方法对应Method对象，通过getMethods方法可以得到所有的公共的方法，包括继承的公有方法，如果想要获取私有方法，就通过getDeclaredMethods方法，但是直接执行是不行的，由于是private的限制，但是这个总是有办法去解决的，就是对Method执行setAccessible函数来设置为true（暴力执行）。方法的到之后我们需要执行，执行函数是invoke方法的作用，执行函数是依赖与具体对象的，除了传入对象当然还有具体的参数。上面都是得到方法的数组，得到具体的方法就把后面的s去掉即可。下面是一个简单的Demo1234567891011121314151617181920class Test&#123; public void sayHello(String message)&#123; System.out.println(message); &#125; private void sayByebye(String message)&#123; System.out.println(\"ByeBye:\"+message); &#125;&#125;public class ref &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException, InvocationTargetException &#123; Class&lt;Test&gt; test = Test.class; Test obj =(Test) test.newInstance(); Method[] methods = test.getDeclaredMethods(); for(Method method:methods)&#123; method.setAccessible(true); method.invoke(obj,\"HelloWorld!\"); &#125; &#125;&#125; ###","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/tags/Java/"},{"name":"反射","slug":"反射","permalink":"http://www.maoxin.site/tags/反射/"}]},{"title":"Servlet 执行过程笔记","slug":"Servlet执行过程","date":"2018-07-27T14:44:18.000Z","updated":"2018-07-28T12:23:04.421Z","comments":true,"path":"2018/07/27/Servlet执行过程/","link":"","permalink":"http://www.maoxin.site/2018/07/27/Servlet执行过程/","excerpt":"","text":"首先必须明确，Servlet是JavaEE一个规范，包括JDBC，都是提供了一个规范，而Servlet的具体实现以及运行过程是Tomcat来具体进行的。Servlet本身就是一个接口。HttpServlet只是它的一个具体的实现。 Web容器Web容器说白了就是Web服务器，Tomcat在收到客户端发来的请求之后，创建HttpServletRequest，HttpServletResponse等，它得到请求信息封装起来，交给Servlet去处理。 Servlet容器在Tomcat启动之后也会初始化一个Servlet容器，其会检索web.xml或者是注解来生成ServletConfig对象，ServletConfig本身也是接口，其定义了获取在web.xml或者注解中指明的参数。其接口的具体方法如下：123456public interface ServletConfig&#123; public String getServletName(); public ServletContext getServletContext(); public String getInitParameter(String name); public Enumeration&lt;String&gt; getInitParameterNames();&#125; Servlet 接口则指明了Servlet生命期的几个关键的函数。1234567public interface Servlet&#123; public void init(ServletConfig config)throws ServletExection; public ServletConfig getServletConfig(); public void service(ServletRequest req, ServletResponse res)throws ServletException, IOException; public String getServletInfo(); public void destroy();&#125; 接下来，Tomcat规定了如何调用整个Servlet过程，这就是具体的算法。 init 方法在Servlet生命周期中的初始化阶段被调用 servlet初始化后，有了新的请求调用service方法，进行处理，如HttpServlet 进行doGet和doPost方法的判断。 当销毁servlet对象的时候，调用distory方法释放被占用的资源 ServletConfig和Servlet封装了这个过程中容易变化的部分。再定义一个抽象类将算法封装起来，这就是所谓的模板方法模式，封装算法的抽象类是GenericServlet，我们查看GenericServlet的具体内容。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable &#123; private static final long serialVersionUID = 1L; //这里组合了一个ServletConfig对象 private transient ServletConfig config; public GenericServlet() &#123; &#125; @Override public void destroy() &#123; &#125; @Override public String getInitParameter(String name) &#123; return getServletConfig().getInitParameter(name); &#125; @Override public Enumeration&lt;String&gt; getInitParameterNames() &#123; return getServletConfig().getInitParameterNames(); &#125; @Override public ServletConfig getServletConfig() &#123; return config; &#125; @Override public ServletContext getServletContext() &#123; return getServletConfig().getServletContext(); &#125; @Override public String getServletInfo() &#123; return \"\"; &#125; @Override public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init(); &#125; public void init() throws ServletException &#123; // NOOP by default &#125; public void log(String msg) &#123; getServletContext().log(getServletName() + \": \" + msg); &#125; public void log(String message, Throwable t) &#123; getServletContext().log(getServletName() + \": \" + message, t); &#125;@Override public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; @Override public String getServletName() &#123; return config.getServletName(); &#125; 这个封装算法的抽象类描述的是什么？首先它实现了 Servlet, ServletConfig,Serializable，自然封装了Servlet和ServletConfig所描述的算法，这里实现ServletConfig的实现比较有意思，它是组合了一个ServletConfig对象，然后间接调用这个对象的方法来实现具体ServletConfig接口指明的方法。 整个调用过程 Web服务器接受到HTTP请求 web容器生成对象，将请求转发给Servlet容器 如果容器中不存在对应的Servlet，那么Servlet容器就会去检索，加载，调用init方法，如果有直接进行下一步。 容器调用Servlet的service方法来处理HTTP请求 Web服务器返回信息给客户 其他注意点loadonstartup指明是否在Servlet容器启动的时候就进行初始化，其值代表一个优先级顺序。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Java Servlet","slug":"Java-Servlet","permalink":"http://www.maoxin.site/tags/Java-Servlet/"}]},{"title":"Java注解学习","slug":"Java注解学习","date":"2018-07-27T14:43:28.000Z","updated":"2018-11-01T09:30:22.300Z","comments":true,"path":"2018/07/27/Java注解学习/","link":"","permalink":"http://www.maoxin.site/2018/07/27/Java注解学习/","excerpt":"Java注解的学习","text":"Java注解的学习 什么是注解Java注解提供了关于代码的一些信息，但并不直接作用于它所注解的代码内容，在使用注解之前，程序源数据只是通过java注释和javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。 自定义注解自定义注解的语法稍微特殊，现在将创建一般的注解的形式以代码的形式给出123456789public @interface MyAnnoutation&#123; //设定所有的数据成员都需要后面加上括号 //设定变量 public String name(); //设定变量由默认值 public int age() default 18; //设定数组 public float[] grades();&#125; 而在一个类中去使用该注解的格式为：1234@MyAnnotation(name = \"Maoxin\",age = 19,grades = &#123;1,2,3&#125;)public class Demo &#123;&#125; @Retention 和 RetentionPolicyAnnotation要想决定其作用范围，则通过@Retention指定，而Retention制定的范围由RetentiontPolicy（枚举）决定，RetentionPolicy指定三种范围： 范围 描述 public static final RetentionPolicy SOURCE 在Java源程序中存在 Public static final RetentionPolicy CLASS 在Java生成的类文件中存在 Public static final RetentionPolicy SOURCE 在Java运行的时候存在 示例：123@Retention(value = RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123;&#125; @document 指明拥有这个注解的元素可以被javadoc此类的工具文档化。 @targettarget注解表示注解的使用范围，如果不定义的话表示可以在任何位置上去使用 范围 作用 public static final ElementType TYPE 只能在类或者接口或者枚举上去使用 public static final ElementType FIELD 在成员变量中使用 public static final ElementType METHOD 在方法中使用 public static final ElementType PARAMETER 在参数上使用 public static final ElementType CONSTRUCTOR 在构造方法上去使用 public static final ElementType LOCAL_VARIABLE 在局部变量上使用 public static final ElementType ANNOTATION_TYPE 只能在Annotation中使用 public static final ElementType PACKAGE 只能在包中使用 @inherited注解表示注解能否继承下去 反射与注解在反射API中包含与注解相关的类与API，其中与注解有关的类是java.lang.reflect.AccessibleObject,相关的方法为： 方法名称 描述 public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt;) 判断是否为制定的Annotation public Annotation[] getAnnotations() 得到全部的Annotation 例子： 用指定的元信息去初始化类对象 123456789101112131415@Documented@Target(value = ElementType.TYPE)@Retention(value = RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; //设定变量 public String name(); //设定变量，有默认值 public int age() default 18; //设定数组 public float[] grades();&#125;public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123; //得到具体的注解实例 MyAnnotation cls = Demo.class.getAnnotation(MyAnnotation.class); &#125; 判断方法上有无注解，有的话获取并处理 1234567//设存在Test对象其中的setName方法被注解被MyAnnotation修饰Class&lt;?&gt;cls = Class.forName(\"Test\")；Method method = cls.getMethod(\"setName\");if(met.isAnnotationPresent(MyAnnotation.class))&#123; MyAnnotation my = (MyAnnotation) met.getAnnotation(MyAnnotation.class); //执行一些具体的操作，例如赋值&#125; 大致流程 找到Class对象，找到目标注解，返回一个注解对象 对注解对象做一个操作 系统内建注解@Override12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)//只对方法有效，信息只保留到编译期public @interface Override &#123;&#125; @Deprecated123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)//生成文档信息，信息一直保留到运行期间，目标是全部public @interface Deprecated &#123;&#125; @SuppressWarnings12345@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; Servlet3.0的注解WebServlet12345678910111213141516@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet &#123; String name() default \"\"; String[] value() default &#123;&#125;; String[] urlPatterns() default &#123;&#125;; int loadOnStartup() default -1; //WebInitParam也是注解 WebInitParam[] initParams() default &#123;&#125;; boolean asyncSupported() default false; String smallIcon() default \"\"; String largeIcon() default \"\"; String description() default \"\"; String displayName() default \"\";&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.maoxin.site/tags/Java/"},{"name":"注解","slug":"注解","permalink":"http://www.maoxin.site/tags/注解/"}]},{"title":"Java动态代理","slug":"动态代理模式","date":"2018-07-27T14:42:51.000Z","updated":"2018-07-28T12:18:23.076Z","comments":true,"path":"2018/07/27/动态代理模式/","link":"","permalink":"http://www.maoxin.site/2018/07/27/动态代理模式/","excerpt":"","text":"什么是动态代理？所谓动态代理买就是通过代理类让接口和实现类之间不直接发生联系，可以在运行期（Runtime）实现动态的关联，实现使用反射机制。 回顾代理模式代理模式(Proxy)：为其他对象提供一种代理以控制对这个对象的访问。代理模式说白了就是“真实”对象的代表，这样在访问对象的时候就引入了一定的间接性，这种间接性可以附加功能，在执行前或执行后增加类似检查，控制等功能。 动态代理的优势对比静态代理，静态代理模式一般代理类和具体实现类是一一对应的，这样如果需要使用代理的话需要创建的代理类就会变得繁多，而动态代理可以根据需要在运行时生成一个代理对象，一个类通过动态生成解决多个问题。 下面先概述一个静态代理的实例： 123456789101112131415161718192021222324252627282930313233343536//学生总会要考试的interface Student &#123; void doExam();&#125;//具体的学生class ConcreteStudent implements Student&#123; int id; String name; public ConcreteStudent(int id,String name)&#123; this.id = id; this.name = name; &#125; @Override public void doExam() &#123; System.out.println(\"学号为\"+id+\"的\"+name+\"正在考试。。。。\"); &#125;&#125;//代考中心class ExamProxy implements Student&#123; Student student; public ExamProxy(Student student)&#123; this.student = student; &#125; @Override public void doExam() &#123; student.doExam(); &#125;&#125;public class staticProxy &#123; //代考人员进行考试 public static void main(String[] args) &#123; Student student = new ConcreteStudent(201611,\"王二小\"); Student proxy = new ExamProxy(student); proxy.doExam(); &#125;&#125; 动态代理的过程动态代理在实现的时候并不去考虑去代理谁，而是在运行时制定代理哪一个对象，下面先描述在Java中构建动态代理的整个过程。 事先得有代理对象的主题，也就是说要代理的对象的功能是什么 创建动态代理类，实现InvocationHandler接口，这一点是与静态代理不同的一点，这一点动态代理类就实现的不是具体的主题，而是一个完全不相干的InvocationHandler接口（说明动态代理动态生产的类还不是在这一步接收接口信息的），该接口有一个需要实现的方法：12public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; 接收代理的对象，方法，以及参数 使用Proxy类的静态方法getInstance方法传入ClassLoader(),实现的接口类，以及InvokeHandler对象。之后指向相应的函数。下面举例一个动态代理的应用场景：现在的代考中心变成了中介机构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.maoxin;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//学生总会要考试的interface Student &#123; void doExam();&#125;//白领要买房interface Worker&#123; void buyHouse();&#125;//具体的学生class ConcreteStudent implements Student&#123; int id; String name; public ConcreteStudent(int id,String name)&#123; this.id = id; this.name = name; &#125; @Override public void doExam() &#123; System.out.println(\"学号为\"+id+\"的\"+name+\"正在考试。。。。\"); &#125;&#125;//具体的工作人员class ConcreteWorker implements Worker&#123; String name; public ConcreteWorker(String name)&#123; this.name = name; &#125; @Override public void buyHouse() &#123; System.out.println(name+\"成功购买了一套房！\"); &#125;&#125;//中介机构,承接各种例如代考和买房class SmallProxy implements InvocationHandler &#123; Object obj = null; public SmallProxy(Object obj)&#123; this.obj = obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; if(method.getName().equals(\"doExam\"))&#123; result = method.invoke(obj,args); &#125; if(method.getName().equals(\"buyHouse\"))&#123; result = method.invoke(obj,args); &#125; return result; &#125;&#125;public class dynamicProxy &#123; public static void main(String[] args) &#123; Student student = new ConcreteStudent(201611,\"小红帽\"); Worker worker = new ConcreteWorker(\"小白\"); InvocationHandler proxy1 = new SmallProxy(student); InvocationHandler proxy2 = new SmallProxy(worker); Student studentProxy = (Student) Proxy.newProxyInstance(student.getClass().getClassLoader(), new Class[]&#123;Student.class&#125;,proxy1); Worker workerProxy = (Worker)Proxy.newProxyInstance(worker.getClass().getClassLoader(), new Class[]&#123;Worker.class&#125;,proxy2); studentProxy.doExam(); workerProxy.buyHouse(); &#125;&#125; 为什么需要代理在网上看到的一个很好的解答，这里引用一下： 打个比喻，明星为什么需要经纪人来代理他呢？因为明星的专职是唱歌或演戏，如果把除此以外的其他事情比如演出费用谈判等等都揽在身上，他会累死。这就是体现一个思想：专业分工，用面向对象术语说：就是职责分明。所以，代理类一般是做些除原始类核心功能以外的其他功能，比如权限 事务等等都要专门的代理来实现。当我们的代码每个类代表一个主要功能，而不是将所有功能混在一个类中，那么代码无疑清晰有条理的，易于维护，比如我要修改权限，就不必打开原始类代码，直接修改权限代理类就可以了。就很少发生修改一个BUG，带来一个新BUG的烦恼问题。No matter how slow you are writing clean code, you will always be slower if you make a mess 写干净的代码无论有多慢，总是快于把代码写得一团糟。 参考 https://wangjingxin.top/2016/11/16/proxy/王镜鑫的个人博客http://www.jdon.com/43740一个关于动态代理的提问","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.maoxin.site/categories/设计模式/"}],"tags":[{"name":"设计模式 动态代理","slug":"设计模式-动态代理","permalink":"http://www.maoxin.site/tags/设计模式-动态代理/"}]},{"title":"观察者模式","slug":"观察者模式（Observer pattern）","date":"2018-07-27T14:41:59.000Z","updated":"2018-07-28T12:18:50.557Z","comments":true,"path":"2018/07/27/观察者模式（Observer pattern）/","link":"","permalink":"http://www.maoxin.site/2018/07/27/观察者模式（Observer pattern）/","excerpt":"","text":"场景我们先预想一个这样的情景，有一个类负责监听随时随地都可能发生的事件，例如：天气的变化，用户在桌面上执行操作出发的事件。。有许多类对象需要接收这些信息并进行处理，而且这些类对象往往还不止一个，还需要动态的添加和替换，比如天气显示器，比如事件处理函数。我们需要将“通知”分发给多个对象。假设负责监听的类一旦发现变化，便触发了changed函数，我们想要通知对象，最粗暴最干脆的做法就是：1234567public void changed()&#123; int info = getChanged(); classA.update(info); classB.update(info); classC.update(info); //...&#125; 上面代码主要有以下问题： 大量使用update方法，可以用一个接口来处理 针对具体的实现编程，我们在添加或者删除对象的时候必须修改changed函数 上面几个问题结合起来的问题就是，对象与对象之间的联系太紧密了！ 观察者模式定义一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。 如何解决问题？从最简单的着手，既然出现了大量的update方法，我们首先用一个接口封装起来，既然描述的是观察者，我们就起名Observer接口，里面有一个update方法。观察者的管理者是前面提到的起到监听作用的类，对观察者对象的管理主要有几个内容：1.添加观察者2.删除观察者3.通知。我们将这些方法抽象一下，作为一个Subject接口。具体的细节还有，多个观察者对象如何管理，我们可以利用Java内置的数据结构。就这样，两个本来关系紧密的类现在只暴露出了几个来让两者建立联系的方法。这就是所谓的松耦合。 松耦合：两个对象之间松耦合指的是，他们仍然可以交互，但是不太清楚彼此的细节。 JDK中应用到观察者模式的场景Swing中注册事件处理函数的时候我们首先创建的类要实现ActionListener接口，之后将该对象通过addActionListener注册到相对应的控件中去。 Java内置了观察者模式的类和接口，内部数据结构是用Vector实现的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.maoxin.site/categories/设计模式/"}],"tags":[{"name":"设计模式 观察者模式","slug":"设计模式-观察者模式","permalink":"http://www.maoxin.site/tags/设计模式-观察者模式/"}]},{"title":"策略模式（strategy Pattern）","slug":"策略模式（Strategy Pattern）","date":"2018-07-27T14:41:01.000Z","updated":"2018-07-28T12:18:40.536Z","comments":true,"path":"2018/07/27/策略模式（Strategy Pattern）/","link":"","permalink":"http://www.maoxin.site/2018/07/27/策略模式（Strategy Pattern）/","excerpt":"","text":"策略模式问题导入继承的问题当一类对象都具有相同的行为的时候，我们一般会通过继承来实现代码的复用，但是问题在于，继承太死板了，假设我们要对部分子类添加新的功能，我们需要在子类中写入实现方法，但是这样太啰嗦了，我们为了代码复用，就想在父类写这样一个方法，之后让子类去继承实现，可是有的类并不需要这样一个方法。这样牵一发而动全身。使用继承的效果并不好。 解决方案用接口如何？用了接口就又想到了继承的好处了，接口没有包含具体的实现，我们如果用接口，解决了一部分问题，就是继承带来的死版，但是又陷入了另外一个问题，相同接口对象要写大量的重复代码（现在Java8就支持了接口的实现，解决这个问题） 将容易改变的部分和不容易改变的部分分离我们既想要接口为我们带来的弹性，又想要类给我们带来的代码复用。我们把这个容易改变的部分分离。创建一个接口，描述行为。创建一个类，封装具体的行为。我们创建接口对应的对象，然后组合在需要的类中。 经验学习： 有一个可能比是一个更好，多用组合，少用继承 分离变化和不变的，封装变化 对接口和类继承以及抽象类要有更深的理解 总结 相同的行为而又可变的方法善用interface Java8已经有了可实现的方法，接口已经可以独当一面","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.maoxin.site/categories/设计模式/"}],"tags":[{"name":"设计模式 策略模式","slug":"设计模式-策略模式","permalink":"http://www.maoxin.site/tags/设计模式-策略模式/"}]},{"title":"数组实现栈和队列","slug":"数组实现栈和队列","date":"2018-07-27T14:39:11.000Z","updated":"2018-07-28T12:24:05.965Z","comments":true,"path":"2018/07/27/数组实现栈和队列/","link":"","permalink":"http://www.maoxin.site/2018/07/27/数组实现栈和队列/","excerpt":"","text":"用数组实现简单线性结构，栈和队列 实现栈 由于是数组，因此必然要明确栈的大小 实现相对简单，但是要注意条件检查，错误处理123456789101112131415161718192021222324252627282930public class ArrayToStack &#123; int[] array = null; int index = 0; ArrayToStack(int initsize)&#123; if(initsize&lt;0)&#123; throw new IllegalArgumentException(\"初始化值小于0！\"); &#125; array = new int[initsize]; &#125; public int peek()&#123; if(index==0)&#123; throw new IllegalArgumentException(\"栈已空！\"); &#125; return array[index-1]; &#125; public void push(int i)&#123; if(index == array.length)&#123; throw new IllegalAccessException(\"栈已经满了！\")； &#125; array[index++]= i; &#125; public int pop()&#123; if(index==0)&#123; throw new IllegalArgumentException(\"栈已空！\"); &#125; return array[--index]; &#125;&#125; 实现队列实现队列有几个点关键： 可以使用变量去指向队列头部和指向队列尾部 可以设置一个size去表示队列是否有空间去push以及是否为空 只要是在size不为0的情况下，执行push和pop的结果都会导致start和end的值的增加 当增加到数组最大值的时候注意可以将其置为0，置为0可以有许多方式，可以使用if直接设置也可以进行一个取余数，取余数可以让其在一定的值内循环。 123456789101112131415161718192021222324252627282930313233343536373839public class ArrayToQueue &#123; private int[] array = null; int end; int start; int size; public ArrayToQueue(int init)&#123; if(init&lt;0) throw new IllegalArgumentException(\"不能为负数！\"); array = new int[init]; end = 0; start = 0; size = 0; &#125; public int pop()&#123; if(size==0) throw new IllegalArgumentException(\"队列是空的\"); if(end==array.length) end = 0; size--; return array[end++]; &#125; public void push(int x)&#123; if(size==array.length) throw new IllegalArgumentException(\"队列已满！\"); if(start==array.length) start = 0; array[start++] = x; size++; &#125; public static void main(String[] args) &#123; ArrayToQueue arrayToQueen = new ArrayToQueue(3); arrayToQueen.push(1); arrayToQueen.push(2); arrayToQueen.push(3); System.out.println(arrayToQueen.pop()); arrayToQueen.push(4); System.out.println(arrayToQueen.pop()); System.out.println(arrayToQueen.pop()); System.out.println(arrayToQueen.pop()); //为空的时候报错 System.out.println(arrayToQueen.pop()); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.maoxin.site/categories/算法/"}],"tags":[{"name":"栈 队列 算法","slug":"栈-队列-算法","permalink":"http://www.maoxin.site/tags/栈-队列-算法/"}]},{"title":"递归过程的复杂度计算","slug":"递归过程的复杂度计算","date":"2018-07-27T14:37:00.000Z","updated":"2018-07-28T12:18:59.318Z","comments":true,"path":"2018/07/27/递归过程的复杂度计算/","link":"","permalink":"http://www.maoxin.site/2018/07/27/递归过程的复杂度计算/","excerpt":"","text":"引入：一个简单的例子求数组内最大值的递归算法123456789101112131415161718public class test &#123; public static int GetMax(int[] arrays,int L,int R)&#123; if(arrays==null) return Integer.MIN_VALUE; if(R-L&lt;=1) return Math.max(arrays[L],arrays[R]); int mid = L+((R-L)&gt;&gt;1); return Math.max(GetMax(arrays,L,mid),GetMax(arrays,mid+1,R)); &#125; public static void main(String[] args) throws Exception&#123; int[] testArray = &#123;5,4,9,2,3,1&#125;; System.out.println(GetMax(testArray,0,testArray.length-1)); &#125;&#125; Master 公式在满足：T(N)=aT(n/b)+O(n^d) 的时间复杂度的递归行为统一可以使用Master公式来求，在用分治的思想去解决问题的时候，我们将问题分成的规模是n/b，而处理这个问题的规模所需要的次数是a，处理的过程是 O(n^d) 以二分法查找我们一次将问题规模分为了两个部分，于是b就是2，而我们将我们关注的那一部分再进行分解。不需要处理另一部分，于是a就是1，之后我们对数据的处理是一个常数时间的，因此d就是0 如上进行一个最大值的查找过程使用了递归，将问题分成了两个规模，b=2，每次都进行处理a=2，处理的操作是常数时间，因此d = 0 如果满足以上的通式就可以使用Master公式来求解： 如果log(b,a)&gt;d -&gt;复杂度为O(N^log(b,a)) 如果log(b,a)=d-&gt;复杂度为O(N^d*logN) 如果log(b,a)复杂度为O(N^d) 那么上面两个问题的时间复杂度就可以快速计算 二分法查找是满足第二个条件，因此就是O(logN)递归求最大值的程序满足第一个条件，因此结果就是O(N) 对于归并排序，首先将问题分成了两个规模，每个规模都要处理，其次处理规模是利用外排的方式进行处理，时间复杂度为O(n)，这样根据Master公式计算出来的结果是O(N*logN)","categories":[{"name":"算法","slug":"算法","permalink":"http://www.maoxin.site/categories/算法/"}],"tags":[{"name":"算法 递归","slug":"算法-递归","permalink":"http://www.maoxin.site/tags/算法-递归/"}]}]}