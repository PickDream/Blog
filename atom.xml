<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞翔的傻瓜</title>
  
  <subtitle>菜鸟的试飞之旅</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.maoxin.site/"/>
  <updated>2018-12-03T04:25:10.612Z</updated>
  <id>http://www.maoxin.site/</id>
  
  <author>
    <name>FlyingFool</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM启动流程</title>
    <link href="http://www.maoxin.site/2018/12/02/JavaVM-02/"/>
    <id>http://www.maoxin.site/2018/12/02/JavaVM-02/</id>
    <published>2018-12-02T13:31:50.000Z</published>
    <updated>2018-12-03T04:25:10.612Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章主要分析学习JVM的包括启动流程等等重要的知识点，不断更新<br><a id="more"></a></p><h2 id="JVM基本结构"><a href="#JVM基本结构" class="headerlink" title="JVM基本结构"></a>JVM基本结构</h2><p><img src="1.png" alt=""></p><p>PC寄存器</p><ul><li>每一个线程拥有PC寄存器</li><li>在线程创建时创建</li><li>执行本地方法时该值是undefined</li><li>指向下一条指令的地址</li></ul><p>方法区</p><ul><li>保存装载的类的元信息<ul><li>类型的常量池（JDK6时候，String等常量信息置于方法区，JDK7时候移动到了堆）</li><li>字段，方法信息</li><li>方法字节码</li></ul></li><li>通常和永久区（Perm）关联在一起，Perm保存相对不容易发生变动</li></ul><p>Java堆</p><ul><li>和程序开发密切相关</li><li>应用系统对象都保存在Java堆中</li><li>所有线程共享Java堆</li><li>对于分代GC来说，堆也是分代的</li><li>GC主要工作的区间</li></ul><p><img src="2.png" alt=""></p><ol><li>eden 伊甸园，对象“出身”的地方</li><li>S0和S1</li><li>tenured</li></ol><p>Java栈</p><ul><li><p>线程私有的</p></li><li><p>栈由一系列帧组成(Java栈也叫帧栈)</p></li><li><p>帧保存一个方法的局部变量，操作数栈，常量池指针</p></li><li><p>每次方法调用创建一个帧并且压栈</p></li><li><p>Java栈-局部变量表（包括函数的传入参数以及局部变量）</p><ul><li>注意如果是类的实例方法会传入this</li></ul><p><img src="3.png" alt=""></p></li><li><p>Java栈-操作数栈（Java没有寄存器，所有参数传递使用操作数栈）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c = a+b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章主要分析学习JVM的包括启动流程等等重要的知识点，不断更新&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://www.maoxin.site/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://www.maoxin.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>SSH框架整合</title>
    <link href="http://www.maoxin.site/2018/12/01/SSH-01/"/>
    <id>http://www.maoxin.site/2018/12/01/SSH-01/</id>
    <published>2018-12-01T10:01:24.000Z</published>
    <updated>2018-12-03T03:26:17.542Z</updated>
    
    <content type="html"><![CDATA[<p>该笔记主要介绍的是配置SSH框架的整合，记录整合的思路与方法，在整合过程中也遇到了许多小问题，在此做一个详细的记录。</p><a id="more"></a><h2 id="xml-相关"><a href="#xml-相关" class="headerlink" title="xml 相关"></a>xml 相关</h2><p>在配置之前，先要明白XML的一些容易被忽视的概念，这在Spring的配置中尤为重要，在一个Spring配置文件中众多复杂的功能通过一系列类似<code>xmlns</code>,<code>xmlns:xsi</code>,<code>xsi:schemaLocation</code>,<code>dtd</code>等等概念串联起来，有必要去了解其本身，这样无论是找出配置文件的问题还是写配置文件的问题都非常的重要。借助与IDEA这样的IDE固然可以自动导入，但是太依赖工具也是很危险的事情，我在使用IDEA导入<code>&lt;tx:advice&gt;</code>标签IDEA导错了，结果浪费了很多时间。</p><h3 id="xmlns"><a href="#xmlns" class="headerlink" title="xmlns"></a>xmlns</h3><p>xmlns的全程是xml namespace，代表xml的命名空间，同其他语言的命名空间的概念一样，xml的也是为了解决命名冲突的，xml标签本身就是一种人类可读的形式，就好比一个<code>&lt;table&gt;&lt;/table&gt;</code>可以代表表格，也可以代表桌子。如果在一个XML中同时有这两种语义不同但是名称完全相同的标签，如何解决这个问题：可以使用<code>xmlns:namespace-prefix=&quot;namespaceURI&quot;</code>冒号后面是自定义的前缀，后面自定义的URI</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br></pre></td></tr></table></figure><p>上面截取配置文件的一部分内容，可见用到了四种不同的命名空间，其中最上面的没有用冒号隔开，这是默认的命名空间。不同命名空间的使用也很简单，C++通过使用<code>std::endl</code>两个冒号，而XML使用前缀一个冒号如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"C3P0.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="xmlns-xsi-与-xsi-schemaLocation"><a href="#xmlns-xsi-与-xsi-schemaLocation" class="headerlink" title="xmlns:xsi 与 xsi:schemaLocation"></a>xmlns:xsi 与 xsi:schemaLocation</h3><p>xmlns:xsi当然也是一个命名空间，但是之所以单独拿出来是因为其比较特殊</p><blockquote><p><code>xsi</code> 已经成为了一个业界默认的用于 XSD（XML Schema Definition) 文件的命名空间。 而 XSD 文件（也常常称为 Schema 文件）是用来定义 xml 文档结构的。</p></blockquote><p>从上面的描述中不难看出xsi与xsd关联紧密，如何建立命名空间与文档结构文件的关系呢？需要用到<code>xsi:schemaLocation</code>这个标签下的字符串以key-value的形式关联命名空间与文档结构文件。所以这个部分字符串当然是偶数的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span> &gt;</span></span><br></pre></td></tr></table></figure><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>这个网上资料非常多</p><blockquote><p>菜鸟教程  <a href="http://www.runoob.com/dtd/dtd-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/dtd/dtd-tutorial.html</a></p></blockquote><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p><img src="1.png" alt=""></p><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>总的目标是为了实现Spring和Hibernate以及Struts的整合，我们有必要细化一下目的，这样才更容易明白，做这些事情的目的是什么。首先来看Spring以及Hibernate的整合，我们使用Spring的与Hibernate整合的目的是：</p><ul><li>使用Spring提供的特性，包括声明式事务以及IOC等等，这需要Spring来管理数据源以及提供对应数据库模块的数据库管理类。Hibernate本身也能配置数据源以及数据库连接池。此时我们为了使用Spring提供方便的对事务控制功能，就需要在Spring中配置数据源以及事务管理器</li></ul><p>接下来的问题是如何与Web项目做整合，</p><ul><li>一个普通Java入口程序是<code>main</code>函数，而一个Web项目的入口点我们找的是一个监听器<code>ServletContextListener</code>,在WEB项目被创建时初始化Spring容器。其配置文件的路径可以在xml文件中被配置</li></ul><p>而如果我们管理的是Struts2的话，我们面临的问题是如何管理Action对象，我们希望依然使用<code>struts.xml</code>所提供的“路由”功能，但是具体实例创建依赖于Spring提供的容器。我们首先要了解的是Struts2本身Action，Package以及Result对象是怎么创建的</p><h3 id="补充：Struts的对象工厂"><a href="#补充：Struts的对象工厂" class="headerlink" title="补充：Struts的对象工厂"></a>补充：Struts的对象工厂</h3><p> Struts2中引了xwork中的对象工厂、它的作用就是把配置文件中的action、result、package对象的创建。它创建各类的对象，所以说是对象工厂</p><p>其在struts-default.xml文件中指明是对象工厂<code>ObjectFactory</code>，其部分方法如下</p><p><img src="2.png" alt=""></p><p>如果在创建的时候能和Spring容器想配合，那么就OK了，而Struts2有一个插件使用<code>struts2-spring-plugin-2.5.18</code>其struts-plugin.xml重新定义了新的对象工厂</p><p><img src="3.png" alt=""></p><p>其中BuildBean方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">buildBean</span><span class="params">(String beanName, Map&lt;String, Object&gt; extraContext, <span class="keyword">boolean</span> injectInternal)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object o;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.appContext.containsBean(beanName)) &#123;</span><br><span class="line">        o = <span class="keyword">this</span>.appContext.getBean(beanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class beanClazz = <span class="keyword">this</span>.getClassInstance(beanName);</span><br><span class="line">        o = <span class="keyword">this</span>.buildBean(beanClazz, extraContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (injectInternal) &#123;</span><br><span class="line">        <span class="keyword">this</span>.injectInternalBeans(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见其先拿着Class名当作是bean的ID去先找，找不到之后再通过反射来创建</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="配置Spring"><a href="#配置Spring" class="headerlink" title="配置Spring"></a>配置Spring</h3><h3 id="配置Hibernate"><a href="#配置Hibernate" class="headerlink" title="配置Hibernate"></a>配置Hibernate</h3><h3 id="配置Struts2"><a href="#配置Struts2" class="headerlink" title="配置Struts2"></a>配置Struts2</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该笔记主要介绍的是配置SSH框架的整合，记录整合的思路与方法，在整合过程中也遇到了许多小问题，在此做一个详细的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.maoxin.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.maoxin.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate的检索策略</title>
    <link href="http://www.maoxin.site/2018/11/27/hibernate-06/"/>
    <id>http://www.maoxin.site/2018/11/27/hibernate-06/</id>
    <published>2018-11-27T10:25:35.000Z</published>
    <updated>2018-11-27T12:36:22.381Z</updated>
    
    <content type="html"><![CDATA[<p>Hibernate的检索策略主要围绕着两个问题展开：</p><ul><li>如何不浪费内存，因此出现了延迟加载的策略，在需要的时候操发送SQL获取。在需要只传入引用的情况就暂时不先将其所有的数据都加载。</li><li>如何尽可能的减少SQL语句的发送，完成同一个功能可以有许多方式<ul><li>直接通过Select的方式</li><li>通过join链接方式</li><li>通过子查询的方式，先获取到一组数据通过in关键字链接起来进程查询</li><li>在多对多关系的时候，是一次性加载多个Set中的元素还是一个一个的加载</li></ul></li></ul><p>而Hibernate通过XML的一系列设置去控制以上的种种设置。</p><a id="more"></a><h2 id="单个类级别的检索策略"><a href="#单个类级别的检索策略" class="headerlink" title="单个类级别的检索策略"></a>单个类级别的检索策略</h2><p>单个类级别的检索策略可以通过设置<code>class</code>标签的<code>lazy</code>属性来确定其是否是支持懒加载，一下是其关键点：</p><ul><li>无论<code>&lt;class&gt;</code> 元素的 lazy 属性是 true 还是 false, Session 的 get() 方法及 Query 的 list() 方法在类级别总是使用立即检索策略,而只有load方法根据懒加载的方式来加载</li><li>若 <code>&lt;class&gt;</code> 元素的 lazy 属性为 true 或取默认值, Session 的 load() 方法不会执行查询数据表的 SELECT 语句, 仅返回代理类对象的实例, 该代理类实例有如下特征:<ul><li>由 Hibernate 在运行时采用 CGLIB 工具动态生成</li><li>Hibernate 创建代理类实例时, 仅初始化其 OID 属性</li><li>在应用程序第一次访问代理类实例的非 OID 属性时, Hibernate 会初始化代理类实例</li></ul></li></ul><h2 id="一对多和多对多的检索策略"><a href="#一对多和多对多的检索策略" class="headerlink" title="一对多和多对多的检索策略"></a>一对多和多对多的检索策略</h2><p>在一对多和多对多关系中，<code>Set</code>元素就是关键，而在刚开始提到的几种策略在这里都适用。</p><ul><li><p>lazy: 主要决定 orders 集合被初始化的时机. 即到底是在加载 Customer 对象时就被初始化, 还是在程序访问 orders 集合时被初始化</p><ul><li>1-n n-n的集合属性默认使用<strong>懒加载</strong>的检索策略，即lazy=true</li><li>lazy还可以设置为extra，是增强的延迟检索，该值会尽可能延迟集合的初始化的时机！<ul><li>例如，在执行集合的size方法获取大小，以及使用contains方法的时候只是发送select语句来得到大小或者判断是否存在，准确的说：程序第一次访问 order 属性的 size(), contains() 和 isEmpty() 方法时, Hibernate 不会初始化 orders 集合类的实例, 仅通过特定的 select 语句查询必要的信息, 不会检索所有的 Order 对象</li><li>当程序第一次访问 orders 属性的 iterator() 方法时, 会导致 orders 集合代理类实例的初始化</li></ul></li><li>上面描述了增强的延迟初始化激活的时机，下面总结普通的延迟检索执行的时机<ul><li>应用程序第一次访问集合属性: iterator(), size(), isEmpty(), contains() 等方法</li><li>通过 <code>Hibernate.initialize()</code> 静态方法显式初始化</li></ul></li></ul></li><li><p>fetch: 取值为 “select” 或 “subselect” 时, 决定初始化 orders 的查询语句的形式;  若取值为”join”, 则决定 orders 集合被初始化的时机</p><ul><li><p>顾名思义，select是采用select语句获得集合信息，subselect则是通过子查询来获得集合信息，前者与后者最大的区别就是前者要完成子查询的功能的时候必然会发送两条SQL，先完成子查询的功能，再拿结果来select，而子查询只需要一次。这就是关键，也是前面所讨论的SQL语句个数问题的体现。</p></li><li><p>join在加载1的一端的对象时候使用迫切左外链接（使用左外连接查询，并且将集合属性进行初始化）因此可以推断</p><ul><li>lazy延迟检索失效（两张表的操作，就没有必要使用Lazy了）</li></ul><p>其他需要注意的点：</p><ul><li>HQL查询忽略fetch=join的取值</li><li>Query 的list() 方法会忽略映射文件中配置的迫切左外连接检索策略, 而依旧采用延迟加载策略</li></ul></li></ul></li><li><p>batch-size 可以设置一次性初始化set集合元素的数量，使用fatch=select的情况下，获取一个集合元素就会发送一条SQL语句，此时可以通过batch-size来减少SQL语句发送的条数，但是，对于fatch=subselect的情况下，batch-size就不起作用了。（一次性将需要作为子查询的id全部取出了）</p></li></ul><h2 id="多对一和一对一关联的检索策略"><a href="#多对一和一对一关联的检索策略" class="headerlink" title="多对一和一对一关联的检索策略"></a>多对一和一对一关联的检索策略</h2><p>和 <code>&lt;set&gt;</code> 一样,<code>&lt;many-to-one&gt;</code> ,<code>&lt;one-to-one&gt;</code>元素也有一个 lazy 属性和 fetch 属性,由于是对该标签进行操作，就是多对一和一对一的检索策略。</p><p>其元素对应的属性值的设置：</p><p><img src="1.png" alt=""></p><p>其中需要注意的是：</p><ul><li>无代理延迟检索需要增强持久化类的字节码才能实现</li><li>迫切左外连接检索策略的优点在于比立即检索策略使用的 SELECT 语句更少. </li><li>Query 的 list 方法会忽略映射文件配置的迫切左外连接检索策略, 而采用延迟检索策略</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>类级别和关联级别的检错策略</li></ul><p><img src="2.png" alt=""></p><ul><li>三种检索策略的运行机制</li></ul><p><img src="3.png" alt=""></p><ul><li>set集合配置的检索策略的属性</li></ul><p><img src="4.png" alt=""></p><ul><li>综合比较Hibernate的三种检索策略</li></ul><p><img src="5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hibernate的检索策略主要围绕着两个问题展开：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何不浪费内存，因此出现了延迟加载的策略，在需要的时候操发送SQL获取。在需要只传入引用的情况就暂时不先将其所有的数据都加载。&lt;/li&gt;
&lt;li&gt;如何尽可能的减少SQL语句的发送，完成同一个功能可以有许多方式&lt;ul&gt;
&lt;li&gt;直接通过Select的方式&lt;/li&gt;
&lt;li&gt;通过join链接方式&lt;/li&gt;
&lt;li&gt;通过子查询的方式，先获取到一组数据通过in关键字链接起来进程查询&lt;/li&gt;
&lt;li&gt;在多对多关系的时候，是一次性加载多个Set中的元素还是一个一个的加载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而Hibernate通过XML的一系列设置去控制以上的种种设置。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.maoxin.site/categories/java/"/>
    
    
      <category term="Hibernate" scheme="http://www.maoxin.site/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>mysql-01</title>
    <link href="http://www.maoxin.site/2018/11/26/mysql-01/"/>
    <id>http://www.maoxin.site/2018/11/26/mysql-01/</id>
    <published>2018-11-26T11:29:40.000Z</published>
    <updated>2018-11-26T11:29:40.293Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NOSQL-概述</title>
    <link href="http://www.maoxin.site/2018/11/24/NOSQL-01/"/>
    <id>http://www.maoxin.site/2018/11/24/NOSQL-01/</id>
    <published>2018-11-24T02:41:58.000Z</published>
    <updated>2018-11-25T03:30:56.177Z</updated>
    
    <content type="html"><![CDATA[<p>NOSQL 相关技术的入门概述</p><a id="more"></a><h2 id="为什么是NoSQL"><a href="#为什么是NoSQL" class="headerlink" title="为什么是NoSQL"></a>为什么是NoSQL</h2><h3 id="单机数据库的时代"><a href="#单机数据库的时代" class="headerlink" title="单机数据库的时代"></a>单机数据库的时代</h3><p><img src="1.png" alt=""></p><ul><li>数据库的总大小，一个机器放不下</li><li>数据的索引（B+树）一个机器的内存放不下</li><li>访问量（读写混合）一个实例不能承受</li></ul><h3 id="Memcached（缓存）-MYSQL-垂直拆分"><a href="#Memcached（缓存）-MYSQL-垂直拆分" class="headerlink" title="Memcached（缓存）+MYSQL+垂直拆分"></a>Memcached（缓存）+MYSQL+垂直拆分</h3><p><img src="2.png" alt=""></p><p>访问量上升，使用缓存技术来缓解数据库的压力，优化数据库的结构和索引，同时数据库也进行分库处理，之前使用的是文件缓存，但是在访问量继续增大的时候，多台Web机器通过文件缓存不能共享，大量的小文件缓存也带来了比较高的IO压力，这个时候Memcached就自然的成为一个非常时尚的技术产品。</p><h3 id="主从复制与读写分离"><a href="#主从复制与读写分离" class="headerlink" title="主从复制与读写分离"></a>主从复制与读写分离</h3><p><img src="3.png" alt=""></p><p>由于数据库的写入压力增加，Mencached只能缓解数据库的读取压力，读写集中在一个数据库让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提供读写性能和读库的可扩展性，mysql的master-slave模式成为了网站的标配。</p><h3 id="分库分表-水平拆分-mysql集群"><a href="#分库分表-水平拆分-mysql集群" class="headerlink" title="分库分表+水平拆分+mysql集群"></a>分库分表+水平拆分+mysql集群</h3><p><img src="4.bmp" alt=""></p><p>在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。（InnoDB使用行锁）</p><p> 同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库也就在这个时候，分库分表就是将变化不多的表与经常变化的表分开。</p><p>水平拆分简单的说就是9千万条数据通过某种手段分到多个库中。</p><p>MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</p><h3 id="Mysql扩展性瓶颈"><a href="#Mysql扩展性瓶颈" class="headerlink" title="Mysql扩展性瓶颈"></a>Mysql扩展性瓶颈</h3><p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</p><p>不在数据库中使用CLOB BLOB这样的大型数据存储</p><h3 id="如今的形式"><a href="#如今的形式" class="headerlink" title="如今的形式"></a>如今的形式</h3><p><img src="5.bmp" alt=""></p><ul><li>用户访问首先经过防火墙</li><li>之后通过Nginx反向代理（其中做了主备）</li><li>通过应用服务器，Tomcat集群</li><li>之后是数据库集群</li><li>其他的服务器</li></ul><h2 id="为什么使用NoSQL"><a href="#为什么使用NoSQL" class="headerlink" title="为什么使用NoSQL"></a>为什么使用NoSQL</h2><h3 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h3><p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系形数据库</p><p>随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS（社交类网站-网状关系）类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。</p><p><strong>这些类型的数据存储不需要固定的模式，无需多于操作就可以横向扩展</strong></p><h3 id="易扩展"><a href="#易扩展" class="headerlink" title="易扩展"></a>易扩展</h3><p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。<br>数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p><h3 id="大数据量，高性能"><a href="#大数据量，高性能" class="headerlink" title="大数据量，高性能"></a>大数据量，高性能</h3><p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。<br>这得益于它的无关系性，数据库的结构简单。<br>一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，<br>在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，<br>是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了</p><h3 id="多样灵活的数据模型"><a href="#多样灵活的数据模型" class="headerlink" title="多样灵活的数据模型"></a>多样灵活的数据模型</h3><p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，<br><strong>增删</strong>字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦</p><h3 id="传统的RDBMS-VS-NOSQL"><a href="#传统的RDBMS-VS-NOSQL" class="headerlink" title="传统的RDBMS VS NOSQL"></a>传统的RDBMS VS NOSQL</h3><table><thead><tr><th>RDBMS</th><th>NOSQL</th></tr></thead><tbody><tr><td>高度组织化结构化数据</td><td>没有声明性查询语言</td></tr><tr><td>结构化查询语言（SQL）</td><td>没有预定义的模式</td></tr><tr><td>数据和关系都存储在单独的表中。</td><td>键 - 值对存储，列存储，文档存储，图形数据库</td></tr><tr><td>数据操纵语言，数据定义语言</td><td>最终一致性，而非ACID属性</td></tr><tr><td>严格的一致性</td><td>CAP+BASE</td></tr><tr><td>基础事务</td><td>高性能，高可用性可伸缩性</td></tr></tbody></table><h3 id="有什么类型"><a href="#有什么类型" class="headerlink" title="有什么类型"></a>有什么类型</h3><ul><li><code>Redis</code></li><li><code>Memcache</code></li><li><code>Mongdb</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NOSQL 相关技术的入门概述&lt;/p&gt;
    
    </summary>
    
      <category term="NOSQL" scheme="http://www.maoxin.site/categories/NOSQL/"/>
    
    
      <category term="NOSQL" scheme="http://www.maoxin.site/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate-多对多映射关系</title>
    <link href="http://www.maoxin.site/2018/11/24/Hibernate-05/"/>
    <id>http://www.maoxin.site/2018/11/24/Hibernate-05/</id>
    <published>2018-11-24T01:09:00.000Z</published>
    <updated>2018-11-24T01:44:48.037Z</updated>
    
    <content type="html"><![CDATA[<p>多对多关系毋庸置疑需要中间表的参与，关键在于，中间表是怎么配置产生的，多对多同时有双向和单项之分。下面通过商品的item以及分类category为例阐述多对多关系的映射以及复习数据库内、外连接,左、右连接的区别与联系。</p><a id="more"></a><p><img src="1.png" alt=""></p><h2 id="单向多对多"><a href="#单向多对多" class="headerlink" title="单向多对多"></a>单向多对多</h2><p>多对多关系必须要有中间的关联表，首先明确中间的关联表并不对应Java的一个新的类，而是配置生成。配置文件如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Categories"</span> <span class="attr">table</span>=<span class="string">"categories"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cate_id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"cate_id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--关键代码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"items"</span> <span class="attr">table</span>=<span class="string">"categories_items"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"C_ID"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Item"</span> <span class="attr">column</span>=<span class="string">"I_ID"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可见，一个Set就将中间表的关系描述的很清楚了，首先定义了参照哪张表查（categories_items）,用这张表的哪个字段查(C_ID)，Set集合的获取对象的主键从哪个字段获取（I_ID）。</p><p>下面是一些执行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line">session.beginTransaction();</span><br><span class="line">Categories categories = <span class="keyword">new</span> Categories();</span><br><span class="line">Categories categories2 = <span class="keyword">new</span> Categories();</span><br><span class="line">categories.setName(<span class="string">"C1"</span>);</span><br><span class="line">categories2.setName(<span class="string">"C2"</span>);</span><br><span class="line">Item item = <span class="keyword">new</span> Item();</span><br><span class="line">Item item2 = <span class="keyword">new</span> Item();</span><br><span class="line">item.setItem_name(<span class="string">"I1"</span>);</span><br><span class="line">item2.setItem_name(<span class="string">"I2"</span>);</span><br><span class="line"></span><br><span class="line">categories.getItems().add(item);</span><br><span class="line">categories.getItems().add(item2);</span><br><span class="line">categories2.getItems().add(item);</span><br><span class="line">categories2.getItems().add(item2);</span><br><span class="line">session.save(categories);</span><br><span class="line">session.save(categories2);</span><br><span class="line">session.save(item);</span><br><span class="line">session.save(item2);</span><br><span class="line"></span><br><span class="line">session.getTransaction().commit();</span><br></pre></td></tr></table></figure><p>查询依然有我们熟悉的懒加载。</p><p>需要注意的是，对具有Set一端查询的时候适用了内连接（inner join）</p><h2 id="双向多对多"><a href="#双向多对多" class="headerlink" title="双向多对多"></a>双向多对多</h2><p>关于双向多对多只需要注意一下几点即可</p><ul><li>在双向 n-n 关联的两边都需指定连接表的表名及外键列的列名. 两个集合元素 set 的 table 元素的值必须指定，而且必须相同。set元素的两个子元素：key 和 many-to-many 都必须指定 column 属性，其中，key 和 many-to-many 分别指定本持久化类和关联类在连接表中的外键列名，因此两边的 key 与 many-to-many 的column属性交叉相同。</li><li>对于双向 n-n 关联, 必须把其中一端的 inverse 设置为 true, 否则两端都维护关联关系可能会造成主键冲突</li></ul><h2 id="内连接、左外连接、右外连接、交叉连接"><a href="#内连接、左外连接、右外连接、交叉连接" class="headerlink" title="内连接、左外连接、右外连接、交叉连接"></a>内连接、左外连接、右外连接、交叉连接</h2><blockquote><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录<br>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>inner join(等值连接) 只返回两个表中联结字段相等的行</p><p>交叉连接，这个没有具体参照，只要列出全部的关系，也就是笛卡尔积</p></blockquote><p>有一张图诠释的很好：</p><p><img src="2.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多对多关系毋庸置疑需要中间表的参与，关键在于，中间表是怎么配置产生的，多对多同时有双向和单项之分。下面通过商品的item以及分类category为例阐述多对多关系的映射以及复习数据库内、外连接,左、右连接的区别与联系。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.maoxin.site/categories/java/"/>
    
    
      <category term="Hibernate框架" scheme="http://www.maoxin.site/tags/Hibernate%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate-一对一关联关系</title>
    <link href="http://www.maoxin.site/2018/11/22/Hibernate-04/"/>
    <id>http://www.maoxin.site/2018/11/22/Hibernate-04/</id>
    <published>2018-11-22T10:26:35.000Z</published>
    <updated>2018-11-22T12:09:56.240Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习的是一对一映射关系，一对一映射关系分为两种</p><ul><li>基于外键的一对一映射关系</li><li>基于主键的一对一映射关系</li></ul><p>其中，基于外键的一对一映射关系的数据库视图上基本与单项多对一一样，而在javabean的角度上看都持有对方的引用。其中有许多需要注意的细节，基于主键的一对一映射关系需要再一个表中的主键加上外键约束。</p><a id="more"></a><p>下面的例子主要描述的是Leader与Department的关系，一个Leader只能领导一个部门，这种关系的数据表关系主要是如下的形式：</p><p><img src="1.png" alt=""></p><p>可以看出双方都持有对方的引用，而关系模型却与一对多的情况基本一样。下面开始总结两种映射关系</p><h2 id="基于外键的1对1映射关系"><a href="#基于外键的1对1映射关系" class="headerlink" title="基于外键的1对1映射关系"></a>基于外键的1对1映射关系</h2><p><img src="2.png" alt=""></p><p>都是其中一张表中有指向另外一张表主键的外键，这个外键如果不设置unique的话，那么就是典型的单向多对一的关系，因此，必须对外键加上unique约束，如何配置这个unique？如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"One2One"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Department"</span> <span class="attr">table</span>=<span class="string">"department"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"departmentName"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"department_name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置多对一关联，只不过将unique属性设置位true--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"leader"</span> <span class="attr">class</span>=<span class="string">"Leader"</span> <span class="attr">column</span>=<span class="string">"leader_id"</span> <span class="attr">unique</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可见是在原来基础上的<code>&lt;many-to-one&gt;</code>下配置unique。这样，对于Department这张表，它知道自己是一对一关系，但是对于Leader这张表的操作，它自己从表的字段就无从得知了，这个时候，需要明确指明其关系。“告诉他”自己是和谁（哪张表）有怎样的关系，这就用到了<code>&lt;one-to-one&gt;</code>标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"One2One"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Leader"</span> <span class="attr">table</span>=<span class="string">"leader"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关键在于property--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"department"</span> <span class="attr">class</span>=<span class="string">"Department"</span> <span class="attr">property-ref</span>=<span class="string">"leader"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不配置property-ref其整个一对一映射关系是错的，因为Leader不知道自己和Department是怎样建立关系的，只知道和谁，却不知道和哪个字段建立关系（默认是和主键建立关系的），这个时候需要property-ref来明确，这里的<code>property-ref=&quot;leader&quot;</code>这个leader指的是另外一张表中名为leader的字段，通过这样建立关系。</p><blockquote><p>property-ref 属性指定使用被关联实体主键以外的字段作为关联字段</p></blockquote><p>这样关系就明确了。</p><p>还有几个问题需要解释：</p><ul><li>为什么从department一端去获取leader的时候可以进行懒加载，而leader却是直接获取到department？<ul><li>这主要是因为department持有leader的主键，反之却没有，因此需要左外链接来获取。</li></ul></li><li>建立实体之间关系时发现，只要是关系（外键）都用实体类来联系</li><li>需要注意的是一边使用<code>many-to-one</code>一边使用<code>one to one</code></li></ul><h2 id="基于主键的1对1关系"><a href="#基于主键的1对1关系" class="headerlink" title="基于主键的1对1关系"></a>基于主键的1对1关系</h2><p>什么是基于主键的一对一关系呢？就是说两张表的主键需要保持一致，这就需要其中一张表去建立一个主键约束。其关系如下图：</p><p><img src="3.png" alt=""></p><p>既然是主键作为外键势必对其中一张需要建立外键的表中建立关系，其SQL语句为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department (</span><br><span class="line">        <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">        department_name <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">        primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">    ) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> department </span><br><span class="line">       <span class="keyword">add</span> <span class="keyword">constraint</span> FKkp74p62nnqrxs8compagd3qkd </span><br><span class="line">       foreign <span class="keyword">key</span> (<span class="keyword">id</span>) </span><br><span class="line">       <span class="keyword">references</span> leader (<span class="keyword">id</span>)</span><br></pre></td></tr></table></figure><p>双方的XML分别为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"One2One"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Department"</span> <span class="attr">table</span>=<span class="string">"department"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这里对主键的生成策略有了不一样的约束--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>leader<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"departmentName"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"department_name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意这里使用了constrained=true--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"leader"</span> <span class="attr">class</span>=<span class="string">"Leader"</span> <span class="attr">constrained</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>constrained(约束):指定为当前持久化类对应的数据库表的主键添加一个外键约束，引用被关联的对象(“对方”)所对应的数据库表主键</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习的是一对一映射关系，一对一映射关系分为两种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于外键的一对一映射关系&lt;/li&gt;
&lt;li&gt;基于主键的一对一映射关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，基于外键的一对一映射关系的数据库视图上基本与单项多对一一样，而在javabean的角度上看都持有对方的引用。其中有许多需要注意的细节，基于主键的一对一映射关系需要再一个表中的主键加上外键约束。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.maoxin.site/categories/java/"/>
    
    
      <category term="Hibernate框架" scheme="http://www.maoxin.site/tags/Hibernate%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate-多对一关联</title>
    <link href="http://www.maoxin.site/2018/11/21/Hibernate-03-1/"/>
    <id>http://www.maoxin.site/2018/11/21/Hibernate-03-1/</id>
    <published>2018-11-21T11:30:38.000Z</published>
    <updated>2018-11-21T12:27:27.995Z</updated>
    
    <content type="html"><![CDATA[<p>今天自学Hibernate的多对一关联，整体来说，多对一关联分为单向多对一和双向多对一，这两种从数据库视图中完全没有区别，区别在于编码的数据访问层视图，单向多对一在多的那边的每一个实体持有”一“端这边的引用，获取可以直接获取，通过代理模式实现懒加载来提供一个看似“直接操作”的效果，而所谓双向，就是“一“这一端持有一个集合类型的引用，来描述多的一方，当然这个集合类型也是懒加载的，因此需要注意Set类型的引用必须是接口。当然这在数据访问层的不同是通过Hibernate的配置文件设置的。下面将会对一个具体的例子来总结。</p><a id="more"></a><p>这里介绍的还是一个订单”orders(注意order是数据库关键字)“和”顾客customer“间的例子</p><p><img src="1.png" alt="关系"></p><h2 id="单向一对一"><a href="#单向一对一" class="headerlink" title="单向一对一"></a>单向一对一</h2><p>单向一对一中，主要是”多“这一端持有”一“这一端的引用，那么在其实体类就变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//orders,忽略Getter&amp;Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;<span class="comment">//引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在其hbm.xml自然会去指明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Order"</span> <span class="attr">table</span>=<span class="string">"orders"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"productName"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"product_name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--一对多映射--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--本表的name指向外表的哪个column--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"consumer"</span> <span class="attr">class</span>=<span class="string">"Consumer"</span> <span class="attr">column</span>=<span class="string">"consumer_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这里使用many-to-map,自己这一端是many，对的是one，这个标签整体的语义是</p><ul><li>首先是一个多对一映射</li><li>自己这一端的类字段名是consumer</li><li>这个类字段名对应的类是Consumer</li><li>通过consumer_id字段值去找对应的实体</li></ul><h2 id="双向一对一"><a href="#双向一对一" class="headerlink" title="双向一对一"></a>双向一对一</h2><p>双向一对多，这里的类添加了一个set类型的引用，需要注意的是这个set引用提前被初始化，以防止空指针异常这个错误:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向一对多</span></span><br><span class="line"><span class="comment">     * 需要将集合初始化，防止发生空指针异常</span></span><br><span class="line"><span class="comment">     * 注意声明接口类型，因为其返回的是Hibernate实现的集合类型</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样hbm.xml文件需要一些操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Consumer"</span> <span class="attr">table</span>=<span class="string">"consumer"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--双向一对多增加项目--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指明本表的哪个字段（默认是ID）作为哪张表的外键，其类型是什么--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span> <span class="attr">table</span>=<span class="string">"orders"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"consumer_id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"Order"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是set标签其内容。注意其中包含的是one-to-many的标签，这样就可以获得对应多端的集合了，但是在此，务必要明白以下几个关键点：</p><ul><li><p>是否只要将Order的Set集合赋值给一个新的Consumer实例，之后调用Session保存就可以都添加进去(不行，除非添加级联)</p></li><li><p>为什么先保存Order再保存Consumer发送的SQL个数的条数不一样？（调用了update方法，刚开始插入那几条外键为空）</p></li><li><p>为什么如下代码发送SQL如此啰嗦，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMany2OneSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session session =sessionFactory.openSession();</span><br><span class="line">    session.beginTransaction();</span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">    consumer.setName(<span class="string">"Maoxin"</span>);</span><br><span class="line">    <span class="comment">//这里多的一方建立与1的一方的关系</span></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setProductName(<span class="string">"YunDongDian"</span>);</span><br><span class="line">    order1.setConsumer(consumer);</span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setProductName(<span class="string">"PS4"</span>);</span><br><span class="line">    order2.setConsumer(consumer);</span><br><span class="line">    <span class="comment">//这里是consumer主动管理n的乙方</span></span><br><span class="line">    consumer.getOrders().add(order1);</span><br><span class="line">    consumer.getOrders().add(order2);</span><br><span class="line">  </span><br><span class="line">    session.save(consumer);</span><br><span class="line">    session.save(order1);</span><br><span class="line">    session.save(order2);</span><br><span class="line">    session.getTransaction().commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送的SQL为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        consumer</span><br><span class="line">        (<span class="keyword">name</span>) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        orders</span><br><span class="line">        (product_name, consumer_id) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        orders</span><br><span class="line">        (product_name, consumer_id) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?)</span><br><span class="line"># 下面的<span class="keyword">update</span>是什么意思？        </span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        orders </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        consumer_id=? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">id</span>=?</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        orders </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        consumer_id=? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">id</span>=?</span><br></pre></td></tr></table></figure><p>由于默认情况下是双方维护关联关系，也就是说1这一方也得去维护，这就导致了以上结果，详情在下面，最终应该使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span> <span class="attr">table</span>=<span class="string">"orders"</span> <span class="attr">inverse</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"consumer_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"Order"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="inverse属性"><a href="#inverse属性" class="headerlink" title="inverse属性"></a>inverse属性</h3><ul><li><p>其是SET的属性</p></li><li><p>在hibernate中通过对 inverse 属性的来决定是由双向关联的哪一方来维护表和表之间的关系. inverse = false 的为主动方，inverse = true 的为被动方, 由主动方负责维护关联关系在没有设置 inverse=true 的情况下，父子两边都维护父子关系 </p></li><li>在 1-n 关系中，将 n 方设为主控方将有助于性能改善(如果要国家元首记住全国人民的名字，不是太可能，但要让全国人民知道国家元首，就容易的多)</li><li>在 1-N 关系中，若将 1 方设为主控方会额外多出 update 语句。插入数据时无法同时插入外键列，因而无法为外键列添加非空约束</li></ul><h3 id="关于级联"><a href="#关于级联" class="headerlink" title="关于级联"></a>关于级联</h3><ul><li><p>在对象 – 关系映射文件中, 用于映射持久化类之间关联关系的元素, <code>&lt;set&gt;</code>, <code>&lt;many-to-one&gt;</code> 和 <code>&lt;one-to-one&gt;</code> 都有一个 cascade 属性, 它用于指定如何操纵与当前对象关联的其他对象. </p></li><li><p>级联的详情</p><p><img src="2.png" alt="级联属性"></p></li></ul><h3 id="order-By属性"><a href="#order-By属性" class="headerlink" title="order By属性"></a>order By属性</h3><p><set> 元素有一个 order-by 属性, 如果设置了该属性, 当 Hibernate 通过 select 语句到数据库中检索集合对象时, 利用 order by 子句进行排序</set></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天自学Hibernate的多对一关联，整体来说，多对一关联分为单向多对一和双向多对一，这两种从数据库视图中完全没有区别，区别在于编码的数据访问层视图，单向多对一在多的那边的每一个实体持有”一“端这边的引用，获取可以直接获取，通过代理模式实现懒加载来提供一个看似“直接操作”的效果，而所谓双向，就是“一“这一端持有一个集合类型的引用，来描述多的一方，当然这个集合类型也是懒加载的，因此需要注意Set类型的引用必须是接口。当然这在数据访问层的不同是通过Hibernate的配置文件设置的。下面将会对一个具体的例子来总结。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.maoxin.site/categories/java/"/>
    
    
      <category term="Hibernate框架" scheme="http://www.maoxin.site/tags/Hibernate%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring总结-AOP</title>
    <link href="http://www.maoxin.site/2018/11/20/Spring-Summary-1/"/>
    <id>http://www.maoxin.site/2018/11/20/Spring-Summary-1/</id>
    <published>2018-11-20T02:08:48.000Z</published>
    <updated>2018-11-20T02:22:40.188Z</updated>
    
    <content type="html"><![CDATA[<p>AOP名词在Spring学习中已经听的不能再熟了，但是不能保证所有的概念都了然于胸，对于什么通知，增强，切面等概念含糊的不行，对于什么时候使用<code>advice</code>相关的标签，什么时候使用<code>aspect</code>相关的标签，他们有什么区别与联系？从这里起就开始总结，博文书写的过程就是加深理解的过程。</p><a id="more"></a><h2 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h2><h2 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AOP名词在Spring学习中已经听的不能再熟了，但是不能保证所有的概念都了然于胸，对于什么通知，增强，切面等概念含糊的不行，对于什么时候使用&lt;code&gt;advice&lt;/code&gt;相关的标签，什么时候使用&lt;code&gt;aspect&lt;/code&gt;相关的标签，他们有什么区别与联系？从这里起就开始总结，博文书写的过程就是加深理解的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.maoxin.site/categories/Java/"/>
    
    
      <category term="Spring框架学习" scheme="http://www.maoxin.site/tags/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate配置项</title>
    <link href="http://www.maoxin.site/2018/11/19/Hibernate-03/"/>
    <id>http://www.maoxin.site/2018/11/19/Hibernate-03/</id>
    <published>2018-11-19T02:27:32.000Z</published>
    <updated>2018-11-19T02:31:23.762Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些常见的<code>hibernate.cfg.xml</code>的配置项，会随着后续学习不断更新。目前配置项内容包括</p><ul><li>jdbc驱动</li><li>C3P0数据源</li><li>fetch与Batch的大小(Mysql不起作用)</li><li>其他例如数据库方言等等配置项目</li></ul><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Configuration DTD//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置链接数据库的基本信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/Hibernate?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置C3P0数据源--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接池最大连接数(大量并发)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.max_size"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接池最小连接数(保持)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.min_size"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接增长的步长--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.acquire_increment"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--idle 空闲，指的是多长时间检测是否超时--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.idle_test_period"</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--缓存Statment对象的数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.max_statements"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定时检测多长时间没有使用过就会被销毁--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.timeout"</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置hibernate的基本信息--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--hibernate所使用的数据库方言--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQL55Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--执行时候是否在控制台打印SQL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--是否对SQL进行格式化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定自动生成数据表的策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设定JDBC的statement读取数据库每次从数据库中取出的记录数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbc.fetch_size"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置批量更新的批次的大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbc.batch_size"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指明自动关联的.hbm.xml文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"entity/NewsEntity.hbm.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些常见的&lt;code&gt;hibernate.cfg.xml&lt;/code&gt;的配置项，会随着后续学习不断更新。目前配置项内容包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdbc驱动&lt;/li&gt;
&lt;li&gt;C3P0数据源&lt;/li&gt;
&lt;li&gt;fetch与Batch的大小(Mysql不起作用)&lt;/li&gt;
&lt;li&gt;其他例如数据库方言等等配置项目&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.maoxin.site/categories/java/"/>
    
    
      <category term="Hibernate" scheme="http://www.maoxin.site/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务相关</title>
    <link href="http://www.maoxin.site/2018/11/15/Spring-06/"/>
    <id>http://www.maoxin.site/2018/11/15/Spring-06/</id>
    <published>2018-11-15T03:47:13.000Z</published>
    <updated>2018-11-20T02:12:09.590Z</updated>
    
    <content type="html"><![CDATA[<p>该博文主要正对Spring提供的事务支持功能的总结，其主要包含以下内容：</p><ul><li>事务的配置</li><li>事务的传播行为</li><li>事务的特性复习以及隔离级别的设置</li><li>事务属性的配置</li><li>事务如何使用XML方式进行配置</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该博文主要正对Spring提供的事务支持功能的总结，其主要包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务的配置&lt;/li&gt;
&lt;li&gt;事务的传播行为&lt;/li&gt;
&lt;li&gt;事务的特性复习以及隔离级别的设置&lt;/li&gt;
&lt;li&gt;事务属性的配置&lt;/li&gt;
&lt;li&gt;事务如何使用XML方式进行配置&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.maoxin.site/categories/Java/"/>
    
    
      <category term="Spring框架学习" scheme="http://www.maoxin.site/tags/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用注解的方式配置Bean</title>
    <link href="http://www.maoxin.site/2018/11/15/Spring-05/"/>
    <id>http://www.maoxin.site/2018/11/15/Spring-05/</id>
    <published>2018-11-15T03:16:36.000Z</published>
    <updated>2018-11-15T03:52:17.576Z</updated>
    
    <content type="html"><![CDATA[<p>使用注解配置的方式,其是通过包扫描的方式获得哪些类需要装配，Spring启动的起点是一个配置文件，那么该配置文件必然指定了从哪里扫描，怎样去扫描，扫描那些对象被IOC容器所管理等等，下面主要针对基本的步骤进行总结。<br><a id="more"></a></p><h2 id="扫描哪些组件？"><a href="#扫描哪些组件？" class="headerlink" title="扫描哪些组件？"></a>扫描哪些组件？</h2><p>扫描的组件是由以下注解指定的，其都能被Spring的IOC容器所管理，不同的是其语义不同，如下：</p><table><thead><tr><th>注解</th><th>含义</th></tr></thead><tbody><tr><td>@Component</td><td>基本注解, 标识了一个受 Spring 管理的组件</td></tr><tr><td>@Respository</td><td>标识持久层组件</td></tr><tr><td>@Service</td><td>标识持久层组件</td></tr><tr><td>@Controller</td><td>标识表现层组件</td></tr></tbody></table><p>类被以上注解修饰即可被扫描到并装入IOC容器内进行管理</p><h2 id="组件如何装配？"><a href="#组件如何装配？" class="headerlink" title="组件如何装配？"></a>组件如何装配？</h2><p>我们之前通过XML方式来装配大致有如下几种方法：</p><ol><li>直接定义其值（基本类型）</li><li>用ref引用来引用IOC容器管理的其他的对象</li><li>集合的装配</li></ol><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><h3 id="AutoWired-注解"><a href="#AutoWired-注解" class="headerlink" title="@AutoWired 注解"></a>@AutoWired 注解</h3><h3 id="Resource-与-Inject"><a href="#Resource-与-Inject" class="headerlink" title="@Resource 与@ Inject"></a>@Resource 与@ Inject</h3><h3 id="组件如何被装配的？"><a href="#组件如何被装配的？" class="headerlink" title="组件如何被装配的？"></a>组件如何被装配的？</h3><h2 id="确定如何扫描？"><a href="#确定如何扫描？" class="headerlink" title="确定如何扫描？"></a>确定如何扫描？</h2><h3 id="指定扫描什么位置？"><a href="#指定扫描什么位置？" class="headerlink" title="指定扫描什么位置？"></a>指定扫描什么位置？</h3><h3 id="指明排除项目"><a href="#指明排除项目" class="headerlink" title="指明排除项目"></a>指明排除项目</h3><h3 id="指明包含项目"><a href="#指明包含项目" class="headerlink" title="指明包含项目"></a>指明包含项目</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用注解配置的方式,其是通过包扫描的方式获得哪些类需要装配，Spring启动的起点是一个配置文件，那么该配置文件必然指定了从哪里扫描，怎样去扫描，扫描那些对象被IOC容器所管理等等，下面主要针对基本的步骤进行总结。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.maoxin.site/categories/Java/"/>
    
    
      <category term="Spring框架学习" scheme="http://www.maoxin.site/tags/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate-02</title>
    <link href="http://www.maoxin.site/2018/11/11/Hibernate-02/"/>
    <id>http://www.maoxin.site/2018/11/11/Hibernate-02/</id>
    <published>2018-11-11T11:48:24.000Z</published>
    <updated>2018-11-11T11:48:24.471Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring-SPEL&amp;Bean的生命周期&amp;从工厂中装配Bean</title>
    <link href="http://www.maoxin.site/2018/11/11/Spring-04/"/>
    <id>http://www.maoxin.site/2018/11/11/Spring-04/</id>
    <published>2018-11-11T02:30:32.000Z</published>
    <updated>2018-11-12T11:37:34.541Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要关注以下内容：</p><ul><li>如何给更好的给Bean的属性赋值，甚至将简单的赋值逻辑加入-&gt;SPEL</li><li>如何更细粒度的管理对象在IOC容器中的生命周期-&gt;初始化+销毁方法+初始化方法前后进行处理</li><li>通过工厂方法对Bean进行配置-&gt;静态工厂+实例工厂+FactoryBean方式</li></ul><a id="more"></a><h2 id="SPEL"><a href="#SPEL" class="headerlink" title="SPEL"></a>SPEL</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。其使用<code>#{}</code>作为界定符，所有在大括号内的字符都被认为是SpEL</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><p>整数<code>#{1}</code>，浮点数<code>#{89.7}</code>,科学计数法<code>#{1e4}</code>字符串<code>#{&#39;Hello&#39;}</code>或者<code>#{&quot;Hello&quot;}</code>，布尔值<code>#{false}</code></p><h4 id="引用对象、属性与方法"><a href="#引用对象、属性与方法" class="headerlink" title="引用对象、属性与方法"></a>引用对象、属性与方法</h4><p>引用其他对象<code>#{objName}</code>,对象的属性<code>#{objName.property}</code>,调用方法<code>#{objName.function()}</code>,链式调用方法<code>#{objName.toString().toUpperCase()}</code></p><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>加减乘除不在赘述，这里最关键的是调用静态方法或者字段:<code>#{T(java.lang.Math).PI}</code>比较运算符</p><p>&lt;,&gt;,==,&lt;=,&gt;=,lt,gt,eq,le,ge 例如<code>#{counter.total le 100}</code></p><h4 id="逻辑运算-amp-三目表达式-amp-正则"><a href="#逻辑运算-amp-三目表达式-amp-正则" class="headerlink" title="逻辑运算&amp;三目表达式&amp;正则"></a>逻辑运算&amp;三目表达式&amp;正则</h4><p>逻辑运算：and,or,not,|<code>#{!product.available}</code></p><p>三目表达形式:<code>#{obj.name==&#39;maoxin&#39;?&#39;item1&#39;,&#39;item2&#39;}</code></p><p>正则表达式:<code>#{admin.email matchs &#39;[a-zA-z0-9._%+=]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}&#39;}</code></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>首先在Bean的标签中可以配置两个属性，分别代表Bean的初始化方法以及销毁方法，例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">class</span>=<span class="string">"LifeCircle.SomeWhat"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"value"</span> <span class="attr">value</span>=<span class="string">"123"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过对一下代码的单步执行得到生命周期的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在初始化的IOC容器的时候就执行了构造函数以及init方法</span></span><br><span class="line">ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans-lifecircle.xml"</span>);</span><br><span class="line"><span class="comment">//此时直接从容器中得到</span></span><br><span class="line">SomeWhat someWhat = (SomeWhat) applicationContext.getBean(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">//在容器关闭的时候执行close方法</span></span><br><span class="line">applicationContext.close();</span><br></pre></td></tr></table></figure><p>大致总结下，实例的生命周期</p><ul><li>容器初始化，执行构造方法以及指定的初始化方法</li><li>容器关闭得到时候，执行指定的销毁方法</li></ul><p>在Spring，还可以对Bean的生命周期执行更加细粒度的管理，通过实现<code>BeanPostProcessor</code></p><p>接口。</p><h3 id="BeanPostProcessor接口"><a href="#BeanPostProcessor接口" class="headerlink" title="BeanPostProcessor接口"></a>BeanPostProcessor接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(beanName.toString()+beanName);</span><br><span class="line">        System.out.println(<span class="string">"postProcessAfter"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessBefore"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在XML中配置并且启用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"LifeCircle.MyBeanPostProcessor"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样在IOC容器初始化的过程中就执行完了上述初始化</p><h2 id="从工厂中配置Bean"><a href="#从工厂中配置Bean" class="headerlink" title="从工厂中配置Bean"></a>从工厂中配置Bean</h2><p>从静态方法中配置使用<code>factory-method</code>配合<code></code></p><h3 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h3><p>首先创建静态工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Car&gt; resp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        resp.put(<span class="string">"BMW"</span>,<span class="keyword">new</span> Car(<span class="string">"BMW"</span>,<span class="number">1</span>));</span><br><span class="line">        resp.put(<span class="string">"CCC"</span>,<span class="keyword">new</span> Car(<span class="string">"CCC"</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resp.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方式创建：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car1"</span>  <span class="attr">class</span>=<span class="string">"LifeCircle.CarFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getCar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"BMW"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h3><p>实例工厂首先要创建出这么一个工厂，之后在这个工厂进行配置Bean的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceCarFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Car&gt; cars = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceCarFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cars = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cars.put(<span class="string">"audi"</span>,<span class="keyword">new</span> Car(<span class="string">"audi"</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cars.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--首先创建实例方法Bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"carFactory"</span> <span class="attr">class</span>=<span class="string">"LifeCircle.InstanceCarFactory"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--再创建实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car2"</span> <span class="attr">factory-bean</span>=<span class="string">"carFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getCar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"audi"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Factory-Bean形式"><a href="#Factory-Bean形式" class="headerlink" title="Factory Bean形式"></a>Factory Bean形式</h2><blockquote><p>参阅<a href="http://book.51cto.com/art/201311/419081.htm" target="_blank" rel="noopener">http://book.51cto.com/art/201311/419081.htm</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要关注以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何给更好的给Bean的属性赋值，甚至将简单的赋值逻辑加入-&amp;gt;SPEL&lt;/li&gt;
&lt;li&gt;如何更细粒度的管理对象在IOC容器中的生命周期-&amp;gt;初始化+销毁方法+初始化方法前后进行处理&lt;/li&gt;
&lt;li&gt;通过工厂方法对Bean进行配置-&amp;gt;静态工厂+实例工厂+FactoryBean方式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.maoxin.site/categories/Java/"/>
    
    
      <category term="Spring框架学习" scheme="http://www.maoxin.site/tags/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>hibernate起步</title>
    <link href="http://www.maoxin.site/2018/11/10/hibernate-01/"/>
    <id>http://www.maoxin.site/2018/11/10/hibernate-01/</id>
    <published>2018-11-10T09:06:13.000Z</published>
    <updated>2018-11-27T10:27:43.199Z</updated>
    
    <content type="html"><![CDATA[<p>之前也多多少少接触过Hibernate框架，只限于简单的使用，没有深入的去理解学习，这次从头开始，踏踏实实完成Hibernate的系统学习，起步部分主要完成如何配置环境，大致操作流程，一些注意点。</p><a id="more"></a><h2 id="导入jar"><a href="#导入jar" class="headerlink" title="导入jar"></a>导入jar</h2><ul><li>从官方网站下载对应的jar包，导入压缩文件中<code>lib/required</code>的全部jar包</li><li>导入数据库驱动</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>总而言之，Hibernate的配置和MyBatis这样的持久层框架的使用可以说是很相似，首先有一个主的配置文件，完成框架属性的配置、数据库驱动的指定、连接池的配置等等。其次，在主的配置文件中也得引入对实体类与数据表的映射文件，是XML格式的。在之下的内容主要是借助与idea这样的IDE工具完成最基本项目的搭建。</p><h3 id="idea中生成主配置文件"><a href="#idea中生成主配置文件" class="headerlink" title="idea中生成主配置文件"></a>idea中生成主配置文件</h3><ol><li>导包完成之后，在ide中项目文件夹中右键-&gt;<code>add  Frameworks Support</code>-&gt; 选中<code>Hibernate</code> </li><li>应用之后打开<code>project structure</code>后转到<code>Modules</code>找到<code>Hibernate</code>点击加号添加主配置文件，成功之后在<code>src</code>下就创建了<code>hibernate.cfg.xml</code></li></ol><h3 id="配置主配置文件"><a href="#配置主配置文件" class="headerlink" title="配置主配置文件"></a>配置主配置文件</h3><ul><li>配置数据库信息</li><li>配置hibernate 信息</li><li>关联的映射信息</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置链接数据库的基本信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/Hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span>???<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置hibernate的基本信息--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--hibernate所使用的数据库方言--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQL55Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--执行时候是否在控制台打印SQL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--是否对SQL进行格式化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定自动生成数据表的策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指明自动关联的.hbm.xml文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"entity/NewsEntity.hbm.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之上配置了一些例如是否在控制台打印SQL的象，格式化SQL等等，需要关注的配置是hbm2ddl.auto：</p><p>该配置名的含义是Hibernate Mapping to Data Define Language(Hibernate 映射转数据定义语言)，其能够帮助我们完成从映射文件到生成数据库实体的过程，取值为</p><table><thead><tr><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>create</td><td>每次运行都会生成表</td></tr><tr><td>create-drop</td><td>除了创建SessionFactory创建生成表之外，关闭的时候删除</td></tr><tr><td>update</td><td>最常用，表结构不同将会输出</td></tr><tr><td>validate</td><td>初始化发现表结构的列不存在会抛出异常</td></tr></tbody></table><h3 id="逆向生成实体对象以及配置文件"><a href="#逆向生成实体对象以及配置文件" class="headerlink" title="逆向生成实体对象以及配置文件"></a>逆向生成实体对象以及配置文件</h3><p>打开 <code>Persistence</code>-&gt;右键-&gt;<code>Generate Persistence Mapping</code>-&gt;<code>By Database Schema</code></p><p><img src="1.png" alt="实例"></p><p>接下来就照提示操作了。</p><p>生成的Bean(只包含字段)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的关系映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"entity.NewsEntity"</span> <span class="attr">table</span>=<span class="string">"news"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"Id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指明主键的生成方式，native:使用数据库本地的方式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span> <span class="attr">not-null</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"author"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span> <span class="attr">not-null</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"date"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"date"</span> <span class="attr">sql-type</span>=<span class="string">"date"</span> <span class="attr">not-null</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总得来事其中描述了以下关键信息</p><ol><li>数据库列名与字段名的关系</li><li>数据库字段的数据库类型（为了与Java类型进行自动转换）</li><li>字段其他属性</li></ol><h2 id="Hibernate-写入数据库流程"><a href="#Hibernate-写入数据库流程" class="headerlink" title="Hibernate 写入数据库流程"></a>Hibernate 写入数据库流程</h2><ol><li>创建<code>SessionFactory</code>对象(读取配置文件)</li><li>创建Session对象</li><li>开启事务</li><li>执行操作</li><li>提交事务</li><li>关闭Session</li><li>关闭<code>SessionFactory</code></li></ol><p>其中关键点是创建<code>SessionFactory</code>,官方文档给出的创建方式(Hibernate5.0)，之后是对文档内容的翻译。自己翻译的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 一个SessionFactory 在一个应用中启动一次</span></span><br><span class="line"><span class="keyword">final</span> StandardServiceRegistry registry = <span class="keyword">new</span> StandardServiceRegistryBuilder()</span><br><span class="line">.configure() <span class="comment">//依据hibernate.cfg.xml来配置</span></span><br><span class="line">.build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sessionFactory = <span class="keyword">new</span> MetadataSources(registry).buildMetadata().buildSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// registry would be destroyed by the SessionFactory, but we had trouble building the SessionFactory</span></span><br><span class="line"><span class="comment">// so destroy it manually.</span></span><br><span class="line">StandardServiceRegistryBuilder.destroy( registry );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个<code>SetUp</code>方法首先构建了一个<code>org.hibernate.boot.registry.StandardServiceRegistry</code></li></ul><p>实例将配置信息合并到一组工作服务中以供<code>SessionFactory</code>去使用。</p><ul><li><p>使用<code>StandardServiceRegistry</code>我们创建的<code>org.hibernate.boot.MetadataSources</code>是我们告诉Hibernate关于我们领域模型的起点，由于我们是通过<code>hibernate.cfg.xml</code>去配置的，所以这里没有什么特别的需要关注</p></li><li><p><code>org.hibernate.boot.Metadata</code>代表着一个完整的，部分验证过的领域模型视图，而<code>SessionFactory</code>也正是基于此的</p></li><li>在启动过程的最后一步是去构建一个<code>SessionFactory</code>,这个<code>SessionFactory</code>是一个线程安全的对象只实例化一次而服务整个应用</li><li>这个<code>SessionFactory</code>表现的像是一个<code>org.hibernate.Session</code>对象的工厂</li></ul><p>在得到了Session之后，我们就可以进行简单的增删查改了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开Session</span></span><br><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">session.beginTransaction();</span><br><span class="line"><span class="comment">//保存对象实体</span></span><br><span class="line">session.save( <span class="keyword">new</span> Event( <span class="string">"Our very first event!"</span>, <span class="keyword">new</span> Date() ) );</span><br><span class="line">session.save( <span class="keyword">new</span> Event( <span class="string">"A follow up event"</span>, <span class="keyword">new</span> Date() ) );</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">session.getTransaction().commit();、</span><br><span class="line"><span class="comment">//关闭Session</span></span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前也多多少少接触过Hibernate框架，只限于简单的使用，没有深入的去理解学习，这次从头开始，踏踏实实完成Hibernate的系统学习，起步部分主要完成如何配置环境，大致操作流程，一些注意点。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.maoxin.site/categories/java/"/>
    
    
      <category term="Hibernate" scheme="http://www.maoxin.site/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Bean的自动装配&amp;关系&amp;作用域&amp;导入外部属性文件</title>
    <link href="http://www.maoxin.site/2018/11/10/Spring-03/"/>
    <id>http://www.maoxin.site/2018/11/10/Spring-03/</id>
    <published>2018-11-10T01:46:54.000Z</published>
    <updated>2018-11-10T03:24:11.618Z</updated>
    
    <content type="html"><![CDATA[<p>第三天的内容主要继续了解配置beans的方方面面，包括以下内容：</p><ul><li>自动装配(Auto Wire)</li><li>Bean之间的关系(继承&amp;依赖)</li><li>Bean的作用域(scope=singleton|prototype)</li><li>使用外部属性文件</li></ul><a id="more"></a><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>自动装配是虽不明确指明属性装配什么，但是通过Bean内部属性的名字或者类型自动装配的一种方式，其有三种，最常见的有两种</p><h3 id="自动装配的方式"><a href="#自动装配的方式" class="headerlink" title="自动装配的方式"></a>自动装配的方式</h3><p>装配的方式通过Bean标签的<code>aurowire</code>来指明的</p><h4 id="By-Name"><a href="#By-Name" class="headerlink" title="By Name"></a>By Name</h4><p>By Name方式是通过Bean内部Setter的名字部分去找到id进行装配的，实例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Address address;</span><br><span class="line">    private Car car1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Address"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:city</span>=<span class="string">"BeiJin"</span> <span class="attr">p:street</span>=<span class="string">"Wangfujin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Car"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:brand</span>=<span class="string">"Audi"</span> <span class="attr">p:price</span>=<span class="string">"300000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car1"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Car"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:brand</span>=<span class="string">"NoBrand"</span> <span class="attr">p:price</span>=<span class="string">"20000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Person"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:name</span>=<span class="string">"Tom"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>注意上面设置了两个Car对象，id分别为car1，car，因此预测通过属性名car1应该得到的是car1的内容：运行结果如下</p><p><code>Person(name=Tom, address=Address(city=BeiJin, street=Wangfujin), car1=Car(brand=NoBrand, price=20000.0))</code></p><p>符合预期</p><h4 id="By-Type"><a href="#By-Type" class="headerlink" title="By Type"></a>By Type</h4><p>By Type是通过Class类型来装配的，这也意味着在配置文件中不能有两个相同的作为属性的类配置</p><h3 id="自动装配的缺点"><a href="#自动装配的缺点" class="headerlink" title="自动装配的缺点"></a>自动装配的缺点</h3><p>不够灵活</p><h2 id="Bean之间的关系"><a href="#Bean之间的关系" class="headerlink" title="Bean之间的关系"></a>Bean之间的关系</h2><p>Bean之间的关系主要是：继承和依赖，被继承的父Bean可以充当模版，而交给子Bean去重写，当然也可以设置Bean的abstract属性为true，为抽象Bean，抽象Bean不可以被实例化，如果一个Bean的Class属性没有设置，则必须设置位抽象Bean,子Bean继承可以使用parent属性</p><p>依赖关系主要是在创建对象前指明自己需要依赖的Bean必须加载完成。而不代表设置了依赖自己就会在对应的属性中装载</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"abstractAddreass"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Address"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">p:city</span>=<span class="string">"Beijin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Address"</span> <span class="attr">parent</span>=<span class="string">"abstractAddreass"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:street</span>=<span class="string">"Wangfujin"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>此时创建的Address对象的city自动有了city</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>依赖通过append-on来设置依赖，前置依赖的Bean会在本Bean实例化之前创建好</p><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>通过Bean的scope属性来设置</p><ul><li>scope=”singleton” 默认值，是单例的</li><li>scope=”prototype” 可以创建多个</li></ul><h2 id="整合外部属性文件"><a href="#整合外部属性文件" class="headerlink" title="整合外部属性文件"></a>整合外部属性文件</h2><p>以整合c3p0连接池为例：不使用外部配置文件直接配置搭配bean中，每次修改配置必须打开spring配置文件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"?????"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/struts?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>将具体的配置放置在外部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user=root</span><br><span class="line">password=?????</span><br><span class="line">driverclass=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbcurl=jdbc:mysql://localhost:3306/struts?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC</span><br></pre></td></tr></table></figure></p><p>使用<code>&lt;context:property-placeholder&gt;</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;driverclass&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbcurl&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三天的内容主要继续了解配置beans的方方面面，包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动装配(Auto Wire)&lt;/li&gt;
&lt;li&gt;Bean之间的关系(继承&amp;amp;依赖)&lt;/li&gt;
&lt;li&gt;Bean的作用域(scope=singleton|prototype)&lt;/li&gt;
&lt;li&gt;使用外部属性文件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.maoxin.site/categories/java/"/>
    
    
      <category term="Spring框架学习" scheme="http://www.maoxin.site/tags/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Spring-属性注入</title>
    <link href="http://www.maoxin.site/2018/11/08/Spring-02/"/>
    <id>http://www.maoxin.site/2018/11/08/Spring-02/</id>
    <published>2018-11-08T08:36:08.000Z</published>
    <updated>2018-11-08T11:10:51.071Z</updated>
    
    <content type="html"><![CDATA[<p>自学Spring框架第二天，今天主要是更加深入的学习了Spring Bean的配置方式（XML形式的）使用方式以及一些注意的点。简而言之就是如何配置一个Bean，属性如何去注入？引用类型如何去注入？集合属性如何去注入，以及Properties属性如何去注入等等。需要注意的是之下的实例代码为了简化使用了 <code>lombok</code>开源工具。</p><a id="more"></a><h2 id="普通属性注入方式"><a href="#普通属性注入方式" class="headerlink" title="普通属性注入方式"></a>普通属性注入方式</h2><p>下面总结的是一般的属性注入方式，普通类型以及引用类型，不包括集合类型，其分为三种，最后一种不常用，暂时没有总结。</p><h3 id="属性名注入"><a href="#属性名注入" class="headerlink" title="属性名注入"></a>属性名注入</h3><p>属性名注入的前提是对应Bean类属性值对应着<code>setter</code>方法，并且创建对象的方式必然通过无参构造方法，因此在Bean类必须保留无参构造方法。首先建立实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String corp;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">    <span class="comment">//无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, String corp, Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.corp = corp;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入对应的XML:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car1"</span> <span class="attr">class</span>=<span class="string">"Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--value在标签内部--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span> <span class="attr">value</span>=<span class="string">"audi"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--value在标签外部--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corp"</span> <span class="attr">value</span>=<span class="string">"my"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>property</code>标签注入，并且<code>value</code>字段可以放在外面也可以放在属性的位置上，由于是在XML中写对应的属性值，因此需要注意如果写特殊字符应该使用<code>&lt;!CDATA[..]]&gt;</code>的方式来引用，例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;AUDI&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后的输出为：</p><p><code>Car(brand=&lt;AUDI&gt;, corp=my, price=2000.0)</code></p><p>如果需要注入一个引用,使用ref来引用id即可注入,首先创建一个需要注入引用的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML相关配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"car1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"maoxin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>打印输出：</p><p><code>User(car=Car(brand=&lt;AUDI&gt;, corp=my, price=2000.0), name=maoxin)</code></p><p>如果不想引用的话，可以创建内部Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"Car"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corp"</span> <span class="attr">value</span>=<span class="string">"corp"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"200"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span> <span class="attr">value</span>=<span class="string">"audi"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"maoxin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打印输出：</p><p><code>User(car=Car(brand=audi, corp=corp, price=200.0), name=maoxin)</code></p><h3 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h3><p>构造方法注入方式关注的是构造函数，而识别构造函数的关键是参数的类型，这也是识别重载的关键，因此使用构造方法注入对应的标签有<code>type</code>属性，同时也有<code>index</code>属性来指明位置，这里列一个两者同时使用的例子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"new_car"</span> <span class="attr">class</span>=<span class="string">"Car"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"brand"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"corp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span> <span class="attr">type</span>=<span class="string">"java.lang.Double"</span> <span class="attr">value</span>=<span class="string">"12.00"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然也可以其在注入引用类型的时候也可以使用<code>ref</code>也可以使用内部Beans</p><h3 id="工厂方法注入"><a href="#工厂方法注入" class="headerlink" title="工厂方法注入"></a>工厂方法注入</h3><p>待续..</p><h2 id="集合属性的赋值"><a href="#集合属性的赋值" class="headerlink" title="集合属性的赋值"></a>集合属性的赋值</h2><p>在Spring中对集合类型的赋值有一系列标签的支持，在这里将User类修改以做一下的Demo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,String&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Car&gt; cars;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>填充cars</p><p>需要指定<code>&lt;list&gt;</code>  标签, 在标签里包含一些元素. 这些标签可以通过 <code>&lt;value&gt;</code> 指定简单的常量值, 通过<code>&lt;ref&gt;</code>指定对其他 Bean 的引用. 通过<code>&lt;bean&gt;</code> 指定内置 Bean 定义. 通过<code>&lt;null/&gt;</code> 指定空元素. 甚至可以内嵌其他集合.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"new_user"</span> <span class="attr">class</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"maoxin"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"car1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"Car"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span> <span class="attr">value</span>=<span class="string">"A"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corp"</span> <span class="attr">value</span>=<span class="string">"B"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map的概念包含Entry、Key和Value，其均对应着标签或者属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maps"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"one"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"two"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"3"</span> <span class="attr">value</span>=<span class="string">"three"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"name"</span>&gt;</span>maoxin<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"password"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"xxx"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="集合信息的外部配置"><a href="#集合信息的外部配置" class="headerlink" title="集合信息的外部配置"></a>集合信息的外部配置</h3><p>之前集合的配置都是在内部实现了，现在配置独立的集合对象，使用util标签，其他都差不多</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"mycars"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"car1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring-的IOC容器简介"><a href="#Spring-的IOC容器简介" class="headerlink" title="Spring 的IOC容器简介"></a>Spring 的IOC容器简介</h2><p>在使用Spring读取Bean之前必须先实例化Spring IOC容器，而Spring 提供了两种类型的IOC容器的实现</p><ul><li>Bean Factory IOC容器的基本实现，面向Spring本身</li><li>Application Context 提供了更多的高级特性，面向使用Spring框架的开发者</li></ul><p>而ApplicationContext也有具体的实现，最常用的是ClassPathXmlApplicationContext以及FileSystemXmlApplicationContext</p><p><img src="1.png" alt="ApplicationContext的继承结构"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自学Spring框架第二天，今天主要是更加深入的学习了Spring Bean的配置方式（XML形式的）使用方式以及一些注意的点。简而言之就是如何配置一个Bean，属性如何去注入？引用类型如何去注入？集合属性如何去注入，以及Properties属性如何去注入等等。需要注意的是之下的实例代码为了简化使用了 &lt;code&gt;lombok&lt;/code&gt;开源工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.maoxin.site/categories/Java/"/>
    
    
      <category term="Spring框架学习" scheme="http://www.maoxin.site/tags/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Spring HelloWorld</title>
    <link href="http://www.maoxin.site/2018/11/07/Spring-01/"/>
    <id>http://www.maoxin.site/2018/11/07/Spring-01/</id>
    <published>2018-11-07T01:03:27.000Z</published>
    <updated>2018-11-07T01:43:31.159Z</updated>
    
    <content type="html"><![CDATA[<p>自学Spring第一天，主要目的是使用Spring中的Beans完成依赖注入或者叫做控制反转，之后对所学的内容做一个总结。</p><a id="more"></a><h2 id="安装Spring与HelloWorld"><a href="#安装Spring与HelloWorld" class="headerlink" title="安装Spring与HelloWorld"></a>安装Spring与HelloWorld</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>Spring 项目本身托管到Github上，官方首页有通往Github的链接，但是这里提供更为方便的方式去获取Spring相关的jar包<a href="https://repo.spring.io/webapp/#/home" target="_blank" rel="noopener">https://repo.spring.io/webapp/#/home</a></p><h3 id="将jar包添加到目录"><a href="#将jar包添加到目录" class="headerlink" title="将jar包添加到目录"></a>将jar包添加到目录</h3><p><img src="1.png" alt="需要的jar包"></p><p>其中<code>commons-logging.jar</code>需要另外下载</p><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><h3 id="建立一个简单的Bean"><a href="#建立一个简单的Bean" class="headerlink" title="建立一个简单的Bean"></a>建立一个简单的Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello:"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置Spring-Bean容器配置文件"><a href="#配置Spring-Bean容器配置文件" class="headerlink" title="配置Spring Bean容器配置文件"></a>配置Spring Bean容器配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"HelloWorld"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Spring"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是IDEA添加的方式是<code>src上右键</code>-&gt;<code>XMLConfigurationFile</code>-&gt;<code>SpringConfig</code></p><h3 id="实现IOC"><a href="#实现IOC" class="headerlink" title="实现IOC"></a>实现IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//交给Spring完成，依赖于Spring的Beans容器</span></span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"appclicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line">        HelloWorld helloWorld = (HelloWorld) ctx.getBean(<span class="string">"helloWorld"</span>);</span><br><span class="line"></span><br><span class="line">        helloWorld.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对于依赖处理方式的演变"><a href="#对于依赖处理方式的演变" class="headerlink" title="对于依赖处理方式的演变"></a>对于依赖处理方式的演变</h2><h3 id="分类接口与实现"><a href="#分类接口与实现" class="headerlink" title="分类接口与实现"></a>分类接口与实现</h3><p><img src="2.png" alt="阶段1"></p><p>这种方式虽用面向对象的处理方式，抽象出接口，并有其不同的实现类，但是导致依赖于其接口的业务类太过复杂,图中Report Service需要与三个组件打交道</p><h3 id="工厂模式的引入"><a href="#工厂模式的引入" class="headerlink" title="工厂模式的引入"></a>工厂模式的引入</h3><p><img src="3.png" alt="阶段2"></p><p>引入工厂模式，加入了中间层，由工厂去管理依赖，而Report直接依赖与工厂，这样大大简化了阶段一Report Service的职责，由工厂保证是否是单例等等，依赖变少，组织结构变得更加清晰</p><h3 id="IOC方式的引入"><a href="#IOC方式的引入" class="headerlink" title="IOC方式的引入"></a>IOC方式的引入</h3><p><img src="4.png" alt="阶段3"></p><p>由之前需要什么找工厂去“生产”到需要什么让管理器去注入，容器管理对象的完整声明周期。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自学Spring第一天，主要目的是使用Spring中的Beans完成依赖注入或者叫做控制反转，之后对所学的内容做一个总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.maoxin.site/categories/Java/"/>
    
    
      <category term="Spring框架学习" scheme="http://www.maoxin.site/tags/Spring%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CORS跨域问题的认识与解决</title>
    <link href="http://www.maoxin.site/2018/11/04/HTTP-02/"/>
    <id>http://www.maoxin.site/2018/11/04/HTTP-02/</id>
    <published>2018-11-04T07:01:00.000Z</published>
    <updated>2018-11-04T08:42:28.677Z</updated>
    
    <content type="html"><![CDATA[<p>之前曾经见过跨域问题的解决方式，一个是CORS，一个是JSONP，但是就是处于知其然，不知其所以然的阶段，因此在这里借助网上资料和Node.js来分析和解决如上问题<br><a id="more"></a></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>除去一些常用标签的<code>src</code>，<code>image</code>以及<code>link</code>等属性是可以进行跨域的，一般的其他请求尤其是<code>json</code>请求是不能进行跨域的，否则会出现问题，按照如下方式初始化<code>node.js</code>代码，进行跨域测试：</p><ul><li>Server.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"get request form"</span>,request.url)</span><br><span class="line">    response.end(<span class="string">"HelloWorld"</span>)</span><br><span class="line">&#125;).listen(<span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Server listening on 8887"</span>)</span><br></pre></td></tr></table></figure><ul><li>Server2.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request,responce</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Server2 request form"</span>,request.url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> html = fs.readFileSync(<span class="string">'test.html'</span>,<span class="string">"utf-8"</span>)</span><br><span class="line">    responce.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>:<span class="string">'text/html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    responce.end(html)</span><br><span class="line">&#125;).listen(<span class="number">8889</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Server 2 Listening..."</span>)</span><br></pre></td></tr></table></figure><p>在Server2.js中无论请求如何都会返回一个html页面，该页面主要包含如下请求代码</p><ul><li>html中的js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'http://127.0.0.1:8888/'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>向服务器2进行Http请求控制台信息如图所示</p><p><img src="1.png" alt="错误信息"></p><p>可见，其提示<code>No Access-Control-Allow-Origin</code> ,表示没有Access-Control-Allow-Origin头部信息，无法访问资源</p><p>我们修改服务器添加头信息为<code>Access-Control-Allow-Origin:*</code>在Server1中添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">       <span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>之后就不会报错了，打开控制台的NetWork栏，可以查看到”HelloWorld”字符串</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>由于浏览器允许如文章开始描述的在标签内部访问，所以就可以实现跨域，这也是JSONP的原理，而只要服务器返回的信息满足json这样可以被js原生支持，客户端就会很容易的去处理，在这里我们模拟一种JSONP的方式返回信息</p><p>修改Server1的代码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.end(<span class="string">'&#123;"result":2018&#125;'</span>)</span><br></pre></td></tr></table></figure><p>查看浏览器NetWork，发现返回成功</p><p><img src="2.png" alt="成功"></p><h2 id="CORS跨域的限制"><a href="#CORS跨域的限制" class="headerlink" title="CORS跨域的限制"></a>CORS跨域的限制</h2><p>不是只要设置了<code>Access-Control-Allow-Origin</code>头部就可以随意跨域了</p><ul><li>允许方法<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>允许的Content-Type<ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li><li>请求头。。</li></ul><h3 id="预请求"><a href="#预请求" class="headerlink" title="预请求"></a>预请求</h3><p>之上描述了CORS种种限制，如果想要使用自定义头或者其他Method，浏览器采用了预请求的方式，先发送一个Method=OPTION的请求，根据返回的头信息来判断请求是否合法，而服务器返回如下字段来判断<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span>,</span><br><span class="line"><span class="string">'Access-Control-Allow-Headers'</span>:<span class="string">'X-Test-Cors'</span>,</span><br><span class="line"><span class="string">'Access-Control-Allow-Method'</span>:<span class="string">'POST,PUT,DElete'</span>,</span><br><span class="line"><span class="string">'Access-Control-Max-Age'</span>:<span class="string">'1000'</span><span class="comment">//代表1000s之内不用发送预请求</span></span><br></pre></td></tr></table></figure></p><h2 id="练习代码地址"><a href="#练习代码地址" class="headerlink" title="练习代码地址"></a>练习代码地址</h2><blockquote><p><a href="https://gitee.com/lumaoxin/DemoHouse/tree/master/CORS" target="_blank" rel="noopener">https://gitee.com/lumaoxin/DemoHouse/tree/master/CORS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前曾经见过跨域问题的解决方式，一个是CORS，一个是JSONP，但是就是处于知其然，不知其所以然的阶段，因此在这里借助网上资料和Node.js来分析和解决如上问题&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.maoxin.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP协议" scheme="http://www.maoxin.site/tags/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议的三次握手</title>
    <link href="http://www.maoxin.site/2018/11/04/HTTP-01/"/>
    <id>http://www.maoxin.site/2018/11/04/HTTP-01/</id>
    <published>2018-11-04T06:36:31.000Z</published>
    <updated>2018-11-04T06:55:48.330Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP协议是基于TCP的，一个TCP请求可以传送多个请求，在HTTP0.9/1.0中，连接建立，请求发送得到响应之后，HTTP链接就被关闭了。而在HTTP/1.1中链接会得到一定的保持（长链接),之所以会有这样的改进是因为创建链接的开销太大，需要三次握手（TCP的三次握手）<br><a id="more"></a></p><h2 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h2><ol><li>Client发出请求，传递到服务器（此时客户端不知道Server能否联通）</li><li>Server得到了请求，向Client发出一个确认，此时服务器不知道Client能否收到数据</li><li>客户端收到请求之后，知道Client和Server通信没问题，问题是Server不知道自己的信送到了没？所以Client再次发送一个确认包。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP协议是基于TCP的，一个TCP请求可以传送多个请求，在HTTP0.9/1.0中，连接建立，请求发送得到响应之后，HTTP链接就被关闭了。而在HTTP/1.1中链接会得到一定的保持（长链接),之所以会有这样的改进是因为创建链接的开销太大，需要三次握手（TCP的三次握手）&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.maoxin.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP协议" scheme="http://www.maoxin.site/tags/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
</feed>
