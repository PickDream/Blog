<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>对称加密与非对称性加密</title>
      <link href="/2019/02/13/RSA01/"/>
      <url>/2019/02/13/RSA01/</url>
      
        <content type="html"><![CDATA[<ul><li>简单而言就是私钥加密公钥解，公钥加密私钥解。</li><li>如果一方要向对方发送数据的话，就需要先去请求对方的公钥，之后发送数据的一方拿着公钥发送数据，对方用私钥去解密，但是此时的问题是伪造，中间人拿到公钥，自己就可以发送伪造的数据了。（请求对方的公钥）</li><li>那如果发送数据的一方主动告诉另一方自己的私钥，让对方按照私钥来解密数据，自己拿着公钥来解密数据，这个时候中间人就不能伪造数据了，但是他可以偷看数据</li><li><p>以上两种策略都有问题。<br>总结下，第一种是发送信息，中间人只能伪造<br>第二种是发送信息，中间人可以监听。</p></li><li><p>那么之后可以采用对称加密以及非对称加密结合的方式，利用前者加密对称加密密钥。</p></li><li><p>看起来似乎可以了，但是我们的前提是通信双方可信任，如果你不确定对面是不是我要联系的人，那么就炸了。</p></li><li>这个时候，需要值得信赖的中间机构来做担保。这就是CA。当然我们的前提CA是值得信任的。安全问题需要厘清的一个点是什么值得信任，只有分清什么值得信任，什么不值得信任，安全措施可以展开。</li><li>我们先用CA机构的私钥去加密对方提供的公钥发送给CA，CA去读取，在这个过程中可以知道可以伪造信息，但是读不出来信息，对CA来说，伪造是无意义的，发送给CA之后，CA会通过非对称加密传回包含对方在CA机构注册的公钥，来去比对。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>annotation-driven的作用</title>
      <link href="/2018/12/13/SpringMVC-03/"/>
      <url>/2018/12/13/SpringMVC-03/</url>
      
        <content type="html"><![CDATA[<p>在SpringMVC的配置文件中，一般的资料都会自动的加上<code>&lt;mvc:annotation-driven&gt;</code>标签，让人感觉摸不着头脑，现在结合所学对该标签做一个学习。</p><a id="more"></a><h2 id="之前使用该标签的场景"><a href="#之前使用该标签的场景" class="headerlink" title="之前使用该标签的场景"></a>之前使用该标签的场景</h2><h3 id="使用view-controller时"><a href="#使用view-controller时" class="headerlink" title="使用view-controller时"></a>使用view-controller时</h3><p>在使用<code>&lt;mvc:view-controller&gt;</code>不经过处理器直接转发页面的时候，启用该标签使得处理器中的转发到视图过程出错。必须加上该标签</p><h3 id="解决SpringMVC处理静态资源时"><a href="#解决SpringMVC处理静态资源时" class="headerlink" title="解决SpringMVC处理静态资源时"></a>解决SpringMVC处理静态资源时</h3><p>为了支持RESTful API，我们一般使得DispatcherServlet拦截“/”根目录下的请求，但是在访问静态资源的时候也会被拦截，因此我们使用了<code>&lt;mvc:default-servlet-handler&gt;</code>,配完之后处理器出现问题，这是又加上了该标签</p><h3 id="自定义类型转换器时候"><a href="#自定义类型转换器时候" class="headerlink" title="自定义类型转换器时候"></a>自定义类型转换器时候</h3><p>我们使用到了该标签的<code>conversion-service</code>属性来指明<code>ConversionService</code>.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC-01</title>
      <link href="/2018/12/10/SpringMVC-01/"/>
      <url>/2018/12/10/SpringMVC-01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2018/12/02/JavaVM-02/"/>
      <url>/2018/12/02/JavaVM-02/</url>
      
        <content type="html"><![CDATA[<p>在这篇文章主要分析学习JVM的包括启动流程等等重要的知识点。</p><a id="more"></a><h2 id="JVM基本结构"><a href="#JVM基本结构" class="headerlink" title="JVM基本结构"></a>JVM基本结构</h2><p><img src="1.png" alt=""></p><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><ul><li>每一个线程拥有PC寄存器</li><li>在线程创建时创建</li><li>执行本地方法时该值是undefined</li><li>指向下一条指令的地址</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>保存装载的类的元信息<ul><li>类型的常量池（JDK6时候，String等常量信息置于方法区，JDK7时候移动到了堆）</li><li>字段，方法信息</li><li>方法字节码</li></ul></li><li>通常和永久区（Perm）关联在一起，Perm保存相对不容易发生变动</li></ul><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ul><li>和程序开发密切相关</li><li>应用系统对象都保存在Java堆中</li><li>所有线程共享Java堆</li><li>对于分代GC来说，堆也是分代的</li><li>GC主要工作的区间</li></ul><p><img src="2.png" alt=""></p><ol><li>eden 伊甸园，对象“出身”的地方</li><li>S0和S1</li><li>tenured</li></ol><h3 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h3><ul><li><p>线程私有的</p></li><li><p>栈由一系列帧组成(Java栈也叫帧栈)</p></li><li><p>帧保存一个方法的局部变量，操作数栈，常量池指针</p></li><li><p>每次方法调用创建一个帧并且压栈</p></li><li><p>Java栈-局部变量表（包括函数的传入参数以及局部变量）</p><ul><li>注意如果是类的实例方法会传入this</li></ul><p><img src="3.png" alt=""></p></li><li><p>Java栈-操作数栈（Java没有寄存器，所有参数传递使用操作数栈，来完成寄存器的功能）</p><p><img src="4.png" alt=""></p><p>此案例程序对应的局部变量表与操作数栈</p><p><img src="5.png" alt=""></p></li><li><p>Java栈-栈上分配</p><p>C语言包括C++的变量可以选择使用栈上分配的方式，这样的好处也很明显，不用去担心内存泄漏的问题，Java也可以进行栈上分配：</p><p>如下小实例将演示开启逃逸分析与不开启逃逸分析的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">虚拟机参数</span></span><br><span class="line"><span class="comment">-server  使用服务器模式</span></span><br><span class="line"><span class="comment">-Xmx10m 设置最大的Java堆大小</span></span><br><span class="line"><span class="comment">-Xms10m  设置设置初始Java堆大小</span></span><br><span class="line"><span class="comment">-XX:+DoEscapeAnalysis 开启逃逸分析</span></span><br><span class="line"><span class="comment">-XX:+PrintGC 打印GC日志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> b = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++)&#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(e-b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行之后，将逃逸分析的+改为-再次执行，为不开启之后，对比时间，在开启逃逸分析之后的时间差为6ms，而不开启逃逸分析的时间为：使用了1071ms，同时打印了大量的GC日志。</p></li></ul><h2 id="插-关于逃逸分析"><a href="#插-关于逃逸分析" class="headerlink" title="[插]关于逃逸分析"></a>[插]关于逃逸分析</h2><blockquote><p><a href="http://kenwu.me/jvm-optimization-escape-analysis" target="_blank" rel="noopener">JVM优化之逃逸分析Escape Analysis</a></p></blockquote><p>老帖，但是由于原博客无法访问，只好找到360Doc网站人们转载的副本，在网上找到的转载到这里</p><h3 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h3><p>在编程语言的编译优化原理中，分析指针动态范围的方法称之为逃逸分析。它跟静态代码分析技术中的指针分析和外形分析类似。</p><p>通俗一点讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。而用来分析这种逃逸现象的方法，就称之为逃逸分析。</p><h3 id="逃逸的场景"><a href="#逃逸的场景" class="headerlink" title="逃逸的场景"></a>逃逸的场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> B b;   </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalVariablePointerEscape</span><span class="params">()</span> </span>&#123; <span class="comment">// 给全局变量赋值，发生逃逸   </span></span><br><span class="line">b = <span class="keyword">new</span> B();   </span><br><span class="line">&#125;   </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">methodPointerEscape</span><span class="params">()</span> </span>&#123; <span class="comment">// 方法返回值，发生逃逸   </span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> B();   </span><br><span class="line">&#125;   </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instancePassPointerEscape</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">methodPointerEscape().printClassName(<span class="keyword">this</span>); <span class="comment">// 实例引用传递，发生逃逸   </span></span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClassName</span><span class="params">(A a)</span> </span>&#123;   </span><br><span class="line">System.out.println(a.class.getName());   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，一共举了3种常见的指针逃逸场景。分别是 全局变量赋值，方法返回值，实例引用传递。</p><h3 id="逃逸分析优化JVM的原理"><a href="#逃逸分析优化JVM的原理" class="headerlink" title="逃逸分析优化JVM的原理"></a>逃逸分析优化JVM的原理</h3><p>我们知道java对象是在堆里分配的，在调用栈中，只保存了对象的指针。</p><p>当对象不再使用后，需要依靠GC来遍历引用树并回收内存，如果对象数量较多，将给GC带来较大压力，也间接影响了应用的性能。减少临时对象在堆内分配的数量，无疑是最有效的优化方法。<br>怎么减少临时对象在堆内的分配数量呢？不可能不实例化对象吧！</p><p>其实，在java应用里普遍存在一种场景。一般是在方法体内，声明了一个局部变量，且该变量在方法执行生命周期内未发生逃逸（在方法体内，未将引用暴露给外面）。</p><p>按照JVM内存分配机制，首先会在堆里创建变量类的实例，然后将返回的对象指针压入调用栈，继续执行。</p><p>这是优化前，JVM的处理方式。</p><h4 id="使用栈上分配的优化策略"><a href="#使用栈上分配的优化策略" class="headerlink" title="使用栈上分配的优化策略"></a>使用栈上分配的优化策略</h4><p>优化原理：分析找到未逃逸的变量，将变量类的实例化内存直接在栈里分配(无需进入堆)，分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。</p><p>​        这是优化后的处理方式，对比可以看出，主要区别在栈空间直接作为临时对象的存储介质。从而减少了临时对象在堆内的分配数量。</p><p>逃逸分析的原理很简单，但JVM在应用过程中，还是有诸多考虑。</p><p>比如，逃逸分析不能在静态编译时进行，<strong>必须在JIT里完成</strong>。原因是，与java的动态性有冲突。因为你可以在运行时，通过动态代理改变一个类的行为，此时，逃逸分析是无法得知类已经变化了。</p><h4 id="另外一个重要的优化，同步消除"><a href="#另外一个重要的优化，同步消除" class="headerlink" title="另外一个重要的优化，同步消除"></a>另外一个重要的优化，同步消除</h4><p>如果你定义的类的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>小对象（一般几十个bytes），在没有逃逸的情况下，可以直接分配在栈上</li><li>直接分配在栈上，可以自动回收，减轻GC压力</li><li>大对象或者逃逸对象无法栈上分配</li></ul><h3 id="堆、栈、方法区交互"><a href="#堆、栈、方法区交互" class="headerlink" title="堆、栈、方法区交互"></a>堆、栈、方法区交互</h3><p><img src="6.png" alt=""></p><p><img src="7.png" alt=""></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="8.png" alt=""></p><ul><li><p>内存模型分为三个部分，每个线程都有一个工作内存和主存内存，之上是线程执行引擎，其交互如上图的Java字节码指令。</p></li><li><p>线程工作内存可以看作是CPU中的cache，而主内存可以对应到物理内存上去理解</p></li><li><p>当数据从主内存复制到工作存储时，必须出现两个动作：第一，由主内存执行的读（read）操作；第二，由工作内存执行的相应的load操作；当数据从工作内存拷贝到主内存时，也出现两个操作：第一个，由工作内存执行的存储（store）操作；第二，由主内存执行的相应的写（write）操作</p></li><li><p>每一个操作都是原子的，即执行期间不会被中断</p></li><li><p>对于普通变量，一个线程中更新的值，不能马上反应在其他变量中,如果需要在其他线程中立即可见，需要使用 volatile(易失的) 关键字</p><p><img src="9.png" alt=""></p></li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>一个线程修改了变量，其他线程可以立即知道</p><h3 id="保证可见性的方法"><a href="#保证可见性的方法" class="headerlink" title="保证可见性的方法"></a>保证可见性的方法</h3><ul><li>volatile</li><li>synchronized(unlock之前，写变量值回主存)</li><li><p>final(一旦初始化完成，其他线程就可见)</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3></li><li><p>在本线程内部，操作都是有序的，尽管会发生指令重排，但是语义Java编译器负责保证不变</p></li><li>在线程外观察，操作都是无序的。（指令重排或者主内存同步演示，编译器不考虑多线程之间的语义）</li></ul><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>线程内部串行语义<ul><li>写后读 a=1；b=a；</li><li>写后写 a=1; a=2;</li><li>读后写 a=b;b=1；</li></ul></li><li>以上语句不可重排</li><li>编译器不考虑多线程间的语义</li><li>a=1，b=2就可以重排</li></ul><h3 id="指令重排破坏线程之间的有序性"><a href="#指令重排破坏线程之间的有序性" class="headerlink" title="指令重排破坏线程之间的有序性"></a>指令重排破坏线程之间的有序性</h3><p><img src="10.png" alt=""></p><h3 id="指令重排保证有序性的方法"><a href="#指令重排保证有序性的方法" class="headerlink" title="指令重排保证有序性的方法"></a>指令重排保证有序性的方法</h3><p>使用同步机制：(平行变串行)</p><p><img src="11.png" alt=""></p><h3 id="指令重排的基本原则"><a href="#指令重排的基本原则" class="headerlink" title="指令重排的基本原则"></a>指令重排的基本原则</h3><ol><li>程序顺序原则：一个线程内保证语义的串行性</li><li>volatile规则：volatile变量的写，先发生于读</li><li>锁规则：解锁(unlock)必然发生在随后的加锁(lock)前</li><li>传递性：A先于B，B先于C 那么A必然先于C</li><li>线程的start方法先于它的每一个动作</li><li>线程的所有操作先于线程的终结（Thread.join()）</li><li>线程的中断（interrupt()）先于被中断线程的代码</li><li>对象的构造函数执行结束先于finalize()方法</li></ol><h2 id="解释运行与编译运行"><a href="#解释运行与编译运行" class="headerlink" title="解释运行与编译运行"></a>解释运行与编译运行</h2><h3 id="解释运行"><a href="#解释运行" class="headerlink" title="解释运行"></a>解释运行</h3><p>解释执行以解释方式运行字节码</p><p>解释执行的意思是：读一句，执行一句</p><h3 id="编译运行（JIT）"><a href="#编译运行（JIT）" class="headerlink" title="编译运行（JIT）"></a>编译运行（JIT）</h3><p>将字节码编译成机器码</p><p>直接执行机器码</p><p>运行时编译</p><p>编译后性能有数量级的提升</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSH框架整合</title>
      <link href="/2018/12/01/SSH-01/"/>
      <url>/2018/12/01/SSH-01/</url>
      
        <content type="html"><![CDATA[<p>该笔记主要介绍的是配置SSH框架的整合，记录整合的思路与方法，在整合过程中也遇到了许多小问题，在此做一个详细的记录。</p><a id="more"></a><h2 id="xml-相关"><a href="#xml-相关" class="headerlink" title="xml 相关"></a>xml 相关</h2><p>在配置之前，先要明白XML的一些容易被忽视的概念，这在Spring的配置中尤为重要，在一个Spring配置文件中众多复杂的功能通过一系列类似<code>xmlns</code>,<code>xmlns:xsi</code>,<code>xsi:schemaLocation</code>,<code>dtd</code>等等概念串联起来，有必要去了解其本身，这样无论是找出配置文件的问题还是写配置文件的问题都非常的重要。借助与IDEA这样的IDE固然可以自动导入，但是太依赖工具也是很危险的事情，我在使用IDEA导入<code>&lt;tx:advice&gt;</code>标签IDEA导错了，结果浪费了很多时间。</p><h3 id="xmlns"><a href="#xmlns" class="headerlink" title="xmlns"></a>xmlns</h3><p>xmlns的全程是xml namespace，代表xml的命名空间，同其他语言的命名空间的概念一样，xml的也是为了解决命名冲突的，xml标签本身就是一种人类可读的形式，就好比一个<code>&lt;table&gt;&lt;/table&gt;</code>可以代表表格，也可以代表桌子。如果在一个XML中同时有这两种语义不同但是名称完全相同的标签，如何解决这个问题：可以使用<code>xmlns:namespace-prefix=&quot;namespaceURI&quot;</code>冒号后面是自定义的前缀，后面自定义的URI</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br></pre></td></tr></table></figure><p>上面截取配置文件的一部分内容，可见用到了四种不同的命名空间，其中最上面的没有用冒号隔开，这是默认的命名空间。不同命名空间的使用也很简单，C++通过使用<code>std::endl</code>两个冒号，而XML使用前缀一个冒号如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"C3P0.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="xmlns-xsi-与-xsi-schemaLocation"><a href="#xmlns-xsi-与-xsi-schemaLocation" class="headerlink" title="xmlns:xsi 与 xsi:schemaLocation"></a>xmlns:xsi 与 xsi:schemaLocation</h3><p>xmlns:xsi当然也是一个命名空间，但是之所以单独拿出来是因为其比较特殊</p><blockquote><p><code>xsi</code> 已经成为了一个业界默认的用于 XSD（XML Schema Definition) 文件的命名空间。 而 XSD 文件（也常常称为 Schema 文件）是用来定义 xml 文档结构的。</p></blockquote><p>从上面的描述中不难看出xsi与xsd关联紧密，如何建立命名空间与文档结构文件的关系呢？需要用到<code>xsi:schemaLocation</code>这个标签下的字符串以key-value的形式关联命名空间与文档结构文件。所以这个部分字符串当然是偶数的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span> &gt;</span></span><br></pre></td></tr></table></figure><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>这个网上资料非常多</p><blockquote><p>菜鸟教程  <a href="http://www.runoob.com/dtd/dtd-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/dtd/dtd-tutorial.html</a></p></blockquote><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p><img src="1.png" alt=""></p><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>总的目标是为了实现Spring和Hibernate以及Struts的整合，我们有必要细化一下目的，这样才更容易明白，做这些事情的目的是什么。首先来看Spring以及Hibernate的整合，我们使用Spring的与Hibernate整合的目的是：</p><ul><li>使用Spring提供的特性，包括声明式事务以及IOC等等，这需要Spring来管理数据源以及提供对应数据库模块的数据库管理类。Hibernate本身也能配置数据源以及数据库连接池。此时我们为了使用Spring提供方便的对事务控制功能，就需要在Spring中配置数据源以及事务管理器</li></ul><p>接下来的问题是如何与Web项目做整合，</p><ul><li>一个普通Java入口程序是<code>main</code>函数，而一个Web项目的入口点我们找的是一个监听器<code>ServletContextListener</code>,在WEB项目被创建时初始化Spring容器。其配置文件的路径可以在xml文件中被配置</li></ul><p>而如果我们管理的是Struts2的话，我们面临的问题是如何管理Action对象，我们希望依然使用<code>struts.xml</code>所提供的“路由”功能，但是具体实例创建依赖于Spring提供的容器。我们首先要了解的是Struts2本身Action，Package以及Result对象是怎么创建的</p><h3 id="补充：Struts的对象工厂"><a href="#补充：Struts的对象工厂" class="headerlink" title="补充：Struts的对象工厂"></a>补充：Struts的对象工厂</h3><p> Struts2中引了xwork中的对象工厂、它的作用就是把配置文件中的action、result、package对象的创建。它创建各类的对象，所以说是对象工厂</p><p>其在struts-default.xml文件中指明是对象工厂<code>ObjectFactory</code>，其部分方法如下</p><p><img src="2.png" alt=""></p><p>如果在创建的时候能和Spring容器想配合，那么就OK了，而Struts2有一个插件使用<code>struts2-spring-plugin-2.5.18</code>其struts-plugin.xml重新定义了新的对象工厂</p><p><img src="3.png" alt=""></p><p>其中BuildBean方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">buildBean</span><span class="params">(String beanName, Map&lt;String, Object&gt; extraContext, <span class="keyword">boolean</span> injectInternal)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object o;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.appContext.containsBean(beanName)) &#123;</span><br><span class="line">        o = <span class="keyword">this</span>.appContext.getBean(beanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class beanClazz = <span class="keyword">this</span>.getClassInstance(beanName);</span><br><span class="line">        o = <span class="keyword">this</span>.buildBean(beanClazz, extraContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (injectInternal) &#123;</span><br><span class="line">        <span class="keyword">this</span>.injectInternalBeans(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见其先拿着Class名当作是bean的ID去先找，找不到之后再通过反射来创建</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="配置Spring"><a href="#配置Spring" class="headerlink" title="配置Spring"></a>配置Spring</h3><h3 id="配置Hibernate"><a href="#配置Hibernate" class="headerlink" title="配置Hibernate"></a>配置Hibernate</h3><h3 id="配置Struts2"><a href="#配置Struts2" class="headerlink" title="配置Struts2"></a>配置Struts2</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hibernate的检索策略</title>
      <link href="/2018/11/27/hibernate-06/"/>
      <url>/2018/11/27/hibernate-06/</url>
      
        <content type="html"><![CDATA[<p>Hibernate的检索策略主要围绕着两个问题展开：</p><ul><li>如何不浪费内存，因此出现了延迟加载的策略，在需要的时候操发送SQL获取。在需要只传入引用的情况就暂时不先将其所有的数据都加载。</li><li>如何尽可能的减少SQL语句的发送，完成同一个功能可以有许多方式<ul><li>直接通过Select的方式</li><li>通过join链接方式</li><li>通过子查询的方式，先获取到一组数据通过in关键字链接起来进程查询</li><li>在多对多关系的时候，是一次性加载多个Set中的元素还是一个一个的加载</li></ul></li></ul><p>而Hibernate通过XML的一系列设置去控制以上的种种设置。</p><a id="more"></a><h2 id="单个类级别的检索策略"><a href="#单个类级别的检索策略" class="headerlink" title="单个类级别的检索策略"></a>单个类级别的检索策略</h2><p>单个类级别的检索策略可以通过设置<code>class</code>标签的<code>lazy</code>属性来确定其是否是支持懒加载，一下是其关键点：</p><ul><li>无论<code>&lt;class&gt;</code> 元素的 lazy 属性是 true 还是 false, Session 的 get() 方法及 Query 的 list() 方法在类级别总是使用立即检索策略,而只有load方法根据懒加载的方式来加载</li><li>若 <code>&lt;class&gt;</code> 元素的 lazy 属性为 true 或取默认值, Session 的 load() 方法不会执行查询数据表的 SELECT 语句, 仅返回代理类对象的实例, 该代理类实例有如下特征:<ul><li>由 Hibernate 在运行时采用 CGLIB 工具动态生成</li><li>Hibernate 创建代理类实例时, 仅初始化其 OID 属性</li><li>在应用程序第一次访问代理类实例的非 OID 属性时, Hibernate 会初始化代理类实例</li></ul></li></ul><h2 id="一对多和多对多的检索策略"><a href="#一对多和多对多的检索策略" class="headerlink" title="一对多和多对多的检索策略"></a>一对多和多对多的检索策略</h2><p>在一对多和多对多关系中，<code>Set</code>元素就是关键，而在刚开始提到的几种策略在这里都适用。</p><ul><li><p>lazy: 主要决定 orders 集合被初始化的时机. 即到底是在加载 Customer 对象时就被初始化, 还是在程序访问 orders 集合时被初始化</p><ul><li>1-n n-n的集合属性默认使用<strong>懒加载</strong>的检索策略，即lazy=true</li><li>lazy还可以设置为extra，是增强的延迟检索，该值会尽可能延迟集合的初始化的时机！<ul><li>例如，在执行集合的size方法获取大小，以及使用contains方法的时候只是发送select语句来得到大小或者判断是否存在，准确的说：程序第一次访问 order 属性的 size(), contains() 和 isEmpty() 方法时, Hibernate 不会初始化 orders 集合类的实例, 仅通过特定的 select 语句查询必要的信息, 不会检索所有的 Order 对象</li><li>当程序第一次访问 orders 属性的 iterator() 方法时, 会导致 orders 集合代理类实例的初始化</li></ul></li><li>上面描述了增强的延迟初始化激活的时机，下面总结普通的延迟检索执行的时机<ul><li>应用程序第一次访问集合属性: iterator(), size(), isEmpty(), contains() 等方法</li><li>通过 <code>Hibernate.initialize()</code> 静态方法显式初始化</li></ul></li></ul></li><li><p>fetch: 取值为 “select” 或 “subselect” 时, 决定初始化 orders 的查询语句的形式;  若取值为”join”, 则决定 orders 集合被初始化的时机</p><ul><li><p>顾名思义，select是采用select语句获得集合信息，subselect则是通过子查询来获得集合信息，前者与后者最大的区别就是前者要完成子查询的功能的时候必然会发送两条SQL，先完成子查询的功能，再拿结果来select，而子查询只需要一次。这就是关键，也是前面所讨论的SQL语句个数问题的体现。</p></li><li><p>join在加载1的一端的对象时候使用迫切左外链接（使用左外连接查询，并且将集合属性进行初始化）因此可以推断</p><ul><li>lazy延迟检索失效（两张表的操作，就没有必要使用Lazy了）</li></ul><p>其他需要注意的点：</p><ul><li>HQL查询忽略fetch=join的取值</li><li>Query 的list() 方法会忽略映射文件中配置的迫切左外连接检索策略, 而依旧采用延迟加载策略</li></ul></li></ul></li><li><p>batch-size 可以设置一次性初始化set集合元素的数量，使用fatch=select的情况下，获取一个集合元素就会发送一条SQL语句，此时可以通过batch-size来减少SQL语句发送的条数，但是，对于fatch=subselect的情况下，batch-size就不起作用了。（一次性将需要作为子查询的id全部取出了）</p></li></ul><h2 id="多对一和一对一关联的检索策略"><a href="#多对一和一对一关联的检索策略" class="headerlink" title="多对一和一对一关联的检索策略"></a>多对一和一对一关联的检索策略</h2><p>和 <code>&lt;set&gt;</code> 一样,<code>&lt;many-to-one&gt;</code> ,<code>&lt;one-to-one&gt;</code>元素也有一个 lazy 属性和 fetch 属性,由于是对该标签进行操作，就是多对一和一对一的检索策略。</p><p>其元素对应的属性值的设置：</p><p><img src="1.png" alt=""></p><p>其中需要注意的是：</p><ul><li>无代理延迟检索需要增强持久化类的字节码才能实现</li><li>迫切左外连接检索策略的优点在于比立即检索策略使用的 SELECT 语句更少. </li><li>Query 的 list 方法会忽略映射文件配置的迫切左外连接检索策略, 而采用延迟检索策略</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>类级别和关联级别的检错策略</li></ul><p><img src="2.png" alt=""></p><ul><li>三种检索策略的运行机制</li></ul><p><img src="3.png" alt=""></p><ul><li>set集合配置的检索策略的属性</li></ul><p><img src="4.png" alt=""></p><ul><li>综合比较Hibernate的三种检索策略</li></ul><p><img src="5.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql-01</title>
      <link href="/2018/11/26/mysql-01/"/>
      <url>/2018/11/26/mysql-01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>NOSQL-概述</title>
      <link href="/2018/11/24/NOSQL-01/"/>
      <url>/2018/11/24/NOSQL-01/</url>
      
        <content type="html"><![CDATA[<p>NOSQL 相关技术的入门概述</p><a id="more"></a><h2 id="为什么是NoSQL"><a href="#为什么是NoSQL" class="headerlink" title="为什么是NoSQL"></a>为什么是NoSQL</h2><h3 id="单机数据库的时代"><a href="#单机数据库的时代" class="headerlink" title="单机数据库的时代"></a>单机数据库的时代</h3><p><img src="1.png" alt=""></p><ul><li>数据库的总大小，一个机器放不下</li><li>数据的索引（B+树）一个机器的内存放不下</li><li>访问量（读写混合）一个实例不能承受</li></ul><h3 id="Memcached（缓存）-MYSQL-垂直拆分"><a href="#Memcached（缓存）-MYSQL-垂直拆分" class="headerlink" title="Memcached（缓存）+MYSQL+垂直拆分"></a>Memcached（缓存）+MYSQL+垂直拆分</h3><p><img src="2.png" alt=""></p><p>访问量上升，使用缓存技术来缓解数据库的压力，优化数据库的结构和索引，同时数据库也进行分库处理，之前使用的是文件缓存，但是在访问量继续增大的时候，多台Web机器通过文件缓存不能共享，大量的小文件缓存也带来了比较高的IO压力，这个时候Memcached就自然的成为一个非常时尚的技术产品。</p><h3 id="主从复制与读写分离"><a href="#主从复制与读写分离" class="headerlink" title="主从复制与读写分离"></a>主从复制与读写分离</h3><p><img src="3.png" alt=""></p><p>由于数据库的写入压力增加，Mencached只能缓解数据库的读取压力，读写集中在一个数据库让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提供读写性能和读库的可扩展性，mysql的master-slave模式成为了网站的标配。</p><h3 id="分库分表-水平拆分-mysql集群"><a href="#分库分表-水平拆分-mysql集群" class="headerlink" title="分库分表+水平拆分+mysql集群"></a>分库分表+水平拆分+mysql集群</h3><p><img src="4.bmp" alt=""></p><p>在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。（InnoDB使用行锁）</p><p> 同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库也就在这个时候，分库分表就是将变化不多的表与经常变化的表分开。</p><p>水平拆分简单的说就是9千万条数据通过某种手段分到多个库中。</p><p>MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</p><h3 id="Mysql扩展性瓶颈"><a href="#Mysql扩展性瓶颈" class="headerlink" title="Mysql扩展性瓶颈"></a>Mysql扩展性瓶颈</h3><p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</p><p>不在数据库中使用CLOB BLOB这样的大型数据存储</p><h3 id="如今的形式"><a href="#如今的形式" class="headerlink" title="如今的形式"></a>如今的形式</h3><p><img src="5.bmp" alt=""></p><ul><li>用户访问首先经过防火墙</li><li>之后通过Nginx反向代理（其中做了主备）</li><li>通过应用服务器，Tomcat集群</li><li>之后是数据库集群</li><li>其他的服务器</li></ul><h2 id="为什么使用NoSQL"><a href="#为什么使用NoSQL" class="headerlink" title="为什么使用NoSQL"></a>为什么使用NoSQL</h2><h3 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h3><p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系形数据库</p><p>随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS（社交类网站-网状关系）类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。</p><p><strong>这些类型的数据存储不需要固定的模式，无需多于操作就可以横向扩展</strong></p><h3 id="易扩展"><a href="#易扩展" class="headerlink" title="易扩展"></a>易扩展</h3><p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。<br>数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p><h3 id="大数据量，高性能"><a href="#大数据量，高性能" class="headerlink" title="大数据量，高性能"></a>大数据量，高性能</h3><p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。<br>这得益于它的无关系性，数据库的结构简单。<br>一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，<br>在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，<br>是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了</p><h3 id="多样灵活的数据模型"><a href="#多样灵活的数据模型" class="headerlink" title="多样灵活的数据模型"></a>多样灵活的数据模型</h3><p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，<br><strong>增删</strong>字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦</p><h3 id="传统的RDBMS-VS-NOSQL"><a href="#传统的RDBMS-VS-NOSQL" class="headerlink" title="传统的RDBMS VS NOSQL"></a>传统的RDBMS VS NOSQL</h3><table><thead><tr><th>RDBMS</th><th>NOSQL</th></tr></thead><tbody><tr><td>高度组织化结构化数据</td><td>没有声明性查询语言</td></tr><tr><td>结构化查询语言（SQL）</td><td>没有预定义的模式</td></tr><tr><td>数据和关系都存储在单独的表中。</td><td>键 - 值对存储，列存储，文档存储，图形数据库</td></tr><tr><td>数据操纵语言，数据定义语言</td><td>最终一致性，而非ACID属性</td></tr><tr><td>严格的一致性</td><td>CAP+BASE</td></tr><tr><td>基础事务</td><td>高性能，高可用性可伸缩性</td></tr></tbody></table><h3 id="有什么类型"><a href="#有什么类型" class="headerlink" title="有什么类型"></a>有什么类型</h3><ul><li><code>Redis</code></li><li><code>Memcache</code></li><li><code>Mongdb</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> NOSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hibernate-多对多映射关系</title>
      <link href="/2018/11/24/Hibernate-05/"/>
      <url>/2018/11/24/Hibernate-05/</url>
      
        <content type="html"><![CDATA[<p>多对多关系毋庸置疑需要中间表的参与，关键在于，中间表是怎么配置产生的，多对多同时有双向和单项之分。下面通过商品的item以及分类category为例阐述多对多关系的映射以及复习数据库内、外连接,左、右连接的区别与联系。</p><a id="more"></a><p><img src="1.png" alt=""></p><h2 id="单向多对多"><a href="#单向多对多" class="headerlink" title="单向多对多"></a>单向多对多</h2><p>多对多关系必须要有中间的关联表，首先明确中间的关联表并不对应Java的一个新的类，而是配置生成。配置文件如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Categories"</span> <span class="attr">table</span>=<span class="string">"categories"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cate_id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"cate_id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--关键代码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"items"</span> <span class="attr">table</span>=<span class="string">"categories_items"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"C_ID"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Item"</span> <span class="attr">column</span>=<span class="string">"I_ID"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可见，一个Set就将中间表的关系描述的很清楚了，首先定义了参照哪张表查（categories_items）,用这张表的哪个字段查(C_ID)，Set集合的获取对象的主键从哪个字段获取（I_ID）。</p><p>下面是一些执行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line">session.beginTransaction();</span><br><span class="line">Categories categories = <span class="keyword">new</span> Categories();</span><br><span class="line">Categories categories2 = <span class="keyword">new</span> Categories();</span><br><span class="line">categories.setName(<span class="string">"C1"</span>);</span><br><span class="line">categories2.setName(<span class="string">"C2"</span>);</span><br><span class="line">Item item = <span class="keyword">new</span> Item();</span><br><span class="line">Item item2 = <span class="keyword">new</span> Item();</span><br><span class="line">item.setItem_name(<span class="string">"I1"</span>);</span><br><span class="line">item2.setItem_name(<span class="string">"I2"</span>);</span><br><span class="line"></span><br><span class="line">categories.getItems().add(item);</span><br><span class="line">categories.getItems().add(item2);</span><br><span class="line">categories2.getItems().add(item);</span><br><span class="line">categories2.getItems().add(item2);</span><br><span class="line">session.save(categories);</span><br><span class="line">session.save(categories2);</span><br><span class="line">session.save(item);</span><br><span class="line">session.save(item2);</span><br><span class="line"></span><br><span class="line">session.getTransaction().commit();</span><br></pre></td></tr></table></figure><p>查询依然有我们熟悉的懒加载。</p><p>需要注意的是，对具有Set一端查询的时候适用了内连接（inner join）</p><h2 id="双向多对多"><a href="#双向多对多" class="headerlink" title="双向多对多"></a>双向多对多</h2><p>关于双向多对多只需要注意一下几点即可</p><ul><li>在双向 n-n 关联的两边都需指定连接表的表名及外键列的列名. 两个集合元素 set 的 table 元素的值必须指定，而且必须相同。set元素的两个子元素：key 和 many-to-many 都必须指定 column 属性，其中，key 和 many-to-many 分别指定本持久化类和关联类在连接表中的外键列名，因此两边的 key 与 many-to-many 的column属性交叉相同。</li><li>对于双向 n-n 关联, 必须把其中一端的 inverse 设置为 true, 否则两端都维护关联关系可能会造成主键冲突</li></ul><h2 id="内连接、左外连接、右外连接、交叉连接"><a href="#内连接、左外连接、右外连接、交叉连接" class="headerlink" title="内连接、左外连接、右外连接、交叉连接"></a>内连接、左外连接、右外连接、交叉连接</h2><blockquote><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录<br>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>inner join(等值连接) 只返回两个表中联结字段相等的行</p><p>交叉连接，这个没有具体参照，只要列出全部的关系，也就是笛卡尔积</p></blockquote><p>有一张图诠释的很好：</p><p><img src="2.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hibernate-一对一关联关系</title>
      <link href="/2018/11/22/Hibernate-04/"/>
      <url>/2018/11/22/Hibernate-04/</url>
      
        <content type="html"><![CDATA[<p>今天学习的是一对一映射关系，一对一映射关系分为两种</p><ul><li>基于外键的一对一映射关系</li><li>基于主键的一对一映射关系</li></ul><p>其中，基于外键的一对一映射关系的数据库视图上基本与单项多对一一样，而在javabean的角度上看都持有对方的引用。其中有许多需要注意的细节，基于主键的一对一映射关系需要再一个表中的主键加上外键约束。</p><a id="more"></a><p>下面的例子主要描述的是Leader与Department的关系，一个Leader只能领导一个部门，这种关系的数据表关系主要是如下的形式：</p><p><img src="1.png" alt=""></p><p>可以看出双方都持有对方的引用，而关系模型却与一对多的情况基本一样。下面开始总结两种映射关系</p><h2 id="基于外键的1对1映射关系"><a href="#基于外键的1对1映射关系" class="headerlink" title="基于外键的1对1映射关系"></a>基于外键的1对1映射关系</h2><p><img src="2.png" alt=""></p><p>都是其中一张表中有指向另外一张表主键的外键，这个外键如果不设置unique的话，那么就是典型的单向多对一的关系，因此，必须对外键加上unique约束，如何配置这个unique？如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"One2One"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Department"</span> <span class="attr">table</span>=<span class="string">"department"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"departmentName"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"department_name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置多对一关联，只不过将unique属性设置位true--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"leader"</span> <span class="attr">class</span>=<span class="string">"Leader"</span> <span class="attr">column</span>=<span class="string">"leader_id"</span> <span class="attr">unique</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可见是在原来基础上的<code>&lt;many-to-one&gt;</code>下配置unique。这样，对于Department这张表，它知道自己是一对一关系，但是对于Leader这张表的操作，它自己从表的字段就无从得知了，这个时候，需要明确指明其关系。“告诉他”自己是和谁（哪张表）有怎样的关系，这就用到了<code>&lt;one-to-one&gt;</code>标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"One2One"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Leader"</span> <span class="attr">table</span>=<span class="string">"leader"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关键在于property--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"department"</span> <span class="attr">class</span>=<span class="string">"Department"</span> <span class="attr">property-ref</span>=<span class="string">"leader"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不配置property-ref其整个一对一映射关系是错的，因为Leader不知道自己和Department是怎样建立关系的，只知道和谁，却不知道和哪个字段建立关系（默认是和主键建立关系的），这个时候需要property-ref来明确，这里的<code>property-ref=&quot;leader&quot;</code>这个leader指的是另外一张表中名为leader的字段，通过这样建立关系。</p><blockquote><p>property-ref 属性指定使用被关联实体主键以外的字段作为关联字段</p></blockquote><p>这样关系就明确了。</p><p>还有几个问题需要解释：</p><ul><li>为什么从department一端去获取leader的时候可以进行懒加载，而leader却是直接获取到department？<ul><li>这主要是因为department持有leader的主键，反之却没有，因此需要左外链接来获取。</li></ul></li><li>建立实体之间关系时发现，只要是关系（外键）都用实体类来联系</li><li>需要注意的是一边使用<code>many-to-one</code>一边使用<code>one to one</code></li></ul><h2 id="基于主键的1对1关系"><a href="#基于主键的1对1关系" class="headerlink" title="基于主键的1对1关系"></a>基于主键的1对1关系</h2><p>什么是基于主键的一对一关系呢？就是说两张表的主键需要保持一致，这就需要其中一张表去建立一个主键约束。其关系如下图：</p><p><img src="3.png" alt=""></p><p>既然是主键作为外键势必对其中一张需要建立外键的表中建立关系，其SQL语句为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department (</span><br><span class="line">        <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">        department_name <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">        primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">    ) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> department </span><br><span class="line">       <span class="keyword">add</span> <span class="keyword">constraint</span> FKkp74p62nnqrxs8compagd3qkd </span><br><span class="line">       foreign <span class="keyword">key</span> (<span class="keyword">id</span>) </span><br><span class="line">       <span class="keyword">references</span> leader (<span class="keyword">id</span>)</span><br></pre></td></tr></table></figure><p>双方的XML分别为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"One2One"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Department"</span> <span class="attr">table</span>=<span class="string">"department"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这里对主键的生成策略有了不一样的约束--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>leader<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"departmentName"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"department_name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意这里使用了constrained=true--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"leader"</span> <span class="attr">class</span>=<span class="string">"Leader"</span> <span class="attr">constrained</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>constrained(约束):指定为当前持久化类对应的数据库表的主键添加一个外键约束，引用被关联的对象(“对方”)所对应的数据库表主键</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hibernate-多对一关联</title>
      <link href="/2018/11/21/Hibernate-03-1/"/>
      <url>/2018/11/21/Hibernate-03-1/</url>
      
        <content type="html"><![CDATA[<p>今天自学Hibernate的多对一关联，整体来说，多对一关联分为单向多对一和双向多对一，这两种从数据库视图中完全没有区别，区别在于编码的数据访问层视图，单向多对一在多的那边的每一个实体持有”一“端这边的引用，获取可以直接获取，通过代理模式实现懒加载来提供一个看似“直接操作”的效果，而所谓双向，就是“一“这一端持有一个集合类型的引用，来描述多的一方，当然这个集合类型也是懒加载的，因此需要注意Set类型的引用必须是接口。当然这在数据访问层的不同是通过Hibernate的配置文件设置的。下面将会对一个具体的例子来总结。</p><a id="more"></a><p>这里介绍的还是一个订单”orders(注意order是数据库关键字)“和”顾客customer“间的例子</p><p><img src="1.png" alt="关系"></p><h2 id="单向一对一"><a href="#单向一对一" class="headerlink" title="单向一对一"></a>单向一对一</h2><p>单向一对一中，主要是”多“这一端持有”一“这一端的引用，那么在其实体类就变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//orders,忽略Getter&amp;Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;<span class="comment">//引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在其hbm.xml自然会去指明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Order"</span> <span class="attr">table</span>=<span class="string">"orders"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"productName"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"product_name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--一对多映射--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--本表的name指向外表的哪个column--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"consumer"</span> <span class="attr">class</span>=<span class="string">"Consumer"</span> <span class="attr">column</span>=<span class="string">"consumer_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这里使用many-to-map,自己这一端是many，对的是one，这个标签整体的语义是</p><ul><li>首先是一个多对一映射</li><li>自己这一端的类字段名是consumer</li><li>这个类字段名对应的类是Consumer</li><li>通过consumer_id字段值去找对应的实体</li></ul><h2 id="双向一对一"><a href="#双向一对一" class="headerlink" title="双向一对一"></a>双向一对一</h2><p>双向一对多，这里的类添加了一个set类型的引用，需要注意的是这个set引用提前被初始化，以防止空指针异常这个错误:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向一对多</span></span><br><span class="line"><span class="comment">     * 需要将集合初始化，防止发生空指针异常</span></span><br><span class="line"><span class="comment">     * 注意声明接口类型，因为其返回的是Hibernate实现的集合类型</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样hbm.xml文件需要一些操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Consumer"</span> <span class="attr">table</span>=<span class="string">"consumer"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--双向一对多增加项目--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指明本表的哪个字段（默认是ID）作为哪张表的外键，其类型是什么--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span> <span class="attr">table</span>=<span class="string">"orders"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"consumer_id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"Order"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是set标签其内容。注意其中包含的是one-to-many的标签，这样就可以获得对应多端的集合了，但是在此，务必要明白以下几个关键点：</p><ul><li><p>是否只要将Order的Set集合赋值给一个新的Consumer实例，之后调用Session保存就可以都添加进去(不行，除非添加级联)</p></li><li><p>为什么先保存Order再保存Consumer发送的SQL个数的条数不一样？（调用了update方法，刚开始插入那几条外键为空）</p></li><li><p>为什么如下代码发送SQL如此啰嗦，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMany2OneSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session session =sessionFactory.openSession();</span><br><span class="line">    session.beginTransaction();</span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">    consumer.setName(<span class="string">"Maoxin"</span>);</span><br><span class="line">    <span class="comment">//这里多的一方建立与1的一方的关系</span></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setProductName(<span class="string">"YunDongDian"</span>);</span><br><span class="line">    order1.setConsumer(consumer);</span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setProductName(<span class="string">"PS4"</span>);</span><br><span class="line">    order2.setConsumer(consumer);</span><br><span class="line">    <span class="comment">//这里是consumer主动管理n的乙方</span></span><br><span class="line">    consumer.getOrders().add(order1);</span><br><span class="line">    consumer.getOrders().add(order2);</span><br><span class="line">  </span><br><span class="line">    session.save(consumer);</span><br><span class="line">    session.save(order1);</span><br><span class="line">    session.save(order2);</span><br><span class="line">    session.getTransaction().commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送的SQL为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        consumer</span><br><span class="line">        (<span class="keyword">name</span>) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        orders</span><br><span class="line">        (product_name, consumer_id) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?)</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">insert</span> </span><br><span class="line">    <span class="keyword">into</span></span><br><span class="line">        orders</span><br><span class="line">        (product_name, consumer_id) </span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">        (?, ?)</span><br><span class="line"># 下面的<span class="keyword">update</span>是什么意思？        </span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        orders </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        consumer_id=? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">id</span>=?</span><br><span class="line">Hibernate: </span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">        orders </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        consumer_id=? </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">id</span>=?</span><br></pre></td></tr></table></figure><p>由于默认情况下是双方维护关联关系，也就是说1这一方也得去维护，这就导致了以上结果，详情在下面，最终应该使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span> <span class="attr">table</span>=<span class="string">"orders"</span> <span class="attr">inverse</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"consumer_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"Order"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="inverse属性"><a href="#inverse属性" class="headerlink" title="inverse属性"></a>inverse属性</h3><ul><li><p>其是SET的属性</p></li><li><p>在hibernate中通过对 inverse 属性的来决定是由双向关联的哪一方来维护表和表之间的关系. inverse = false 的为主动方，inverse = true 的为被动方, 由主动方负责维护关联关系在没有设置 inverse=true 的情况下，父子两边都维护父子关系 </p></li><li>在 1-n 关系中，将 n 方设为主控方将有助于性能改善(如果要国家元首记住全国人民的名字，不是太可能，但要让全国人民知道国家元首，就容易的多)</li><li>在 1-N 关系中，若将 1 方设为主控方会额外多出 update 语句。插入数据时无法同时插入外键列，因而无法为外键列添加非空约束</li></ul><h3 id="关于级联"><a href="#关于级联" class="headerlink" title="关于级联"></a>关于级联</h3><ul><li><p>在对象 – 关系映射文件中, 用于映射持久化类之间关联关系的元素, <code>&lt;set&gt;</code>, <code>&lt;many-to-one&gt;</code> 和 <code>&lt;one-to-one&gt;</code> 都有一个 cascade 属性, 它用于指定如何操纵与当前对象关联的其他对象. </p></li><li><p>级联的详情</p><p><img src="2.png" alt="级联属性"></p></li></ul><h3 id="order-By属性"><a href="#order-By属性" class="headerlink" title="order By属性"></a>order By属性</h3><p><set> 元素有一个 order-by 属性, 如果设置了该属性, 当 Hibernate 通过 select 语句到数据库中检索集合对象时, 利用 order by 子句进行排序</set></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring总结-AOP</title>
      <link href="/2018/11/20/Spring-Summary-1/"/>
      <url>/2018/11/20/Spring-Summary-1/</url>
      
        <content type="html"><![CDATA[<p>AOP名词在Spring学习中已经听的不能再熟了，但是不能保证所有的概念都了然于胸，对于什么通知，增强，切面等概念含糊的不行，对于什么时候使用<code>advice</code>相关的标签，什么时候使用<code>aspect</code>相关的标签，他们有什么区别与联系？从这里起就开始总结，博文书写的过程就是加深理解的过程。</p><a id="more"></a><h2 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h2><h2 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hibernate配置项</title>
      <link href="/2018/11/19/Hibernate-03/"/>
      <url>/2018/11/19/Hibernate-03/</url>
      
        <content type="html"><![CDATA[<p>记录一些常见的<code>hibernate.cfg.xml</code>的配置项，会随着后续学习不断更新。目前配置项内容包括</p><ul><li>jdbc驱动</li><li>C3P0数据源</li><li>fetch与Batch的大小(Mysql不起作用)</li><li>其他例如数据库方言等等配置项目</li></ul><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Configuration DTD//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置链接数据库的基本信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/Hibernate?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置C3P0数据源--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接池最大连接数(大量并发)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.max_size"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接池最小连接数(保持)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.min_size"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接增长的步长--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.acquire_increment"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--idle 空闲，指的是多长时间检测是否超时--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.idle_test_period"</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--缓存Statment对象的数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.max_statements"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定时检测多长时间没有使用过就会被销毁--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.timeout"</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置hibernate的基本信息--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--hibernate所使用的数据库方言--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQL55Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--执行时候是否在控制台打印SQL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--是否对SQL进行格式化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定自动生成数据表的策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设定JDBC的statement读取数据库每次从数据库中取出的记录数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbc.fetch_size"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置批量更新的批次的大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbc.batch_size"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指明自动关联的.hbm.xml文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"entity/NewsEntity.hbm.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring事务相关</title>
      <link href="/2018/11/15/Spring-06/"/>
      <url>/2018/11/15/Spring-06/</url>
      
        <content type="html"><![CDATA[<p>该博文主要正对Spring提供的事务支持功能的总结，其主要包含以下内容：</p><ul><li>事务的配置</li><li>事务的传播行为</li><li>事务的特性复习以及隔离级别的设置</li><li>事务属性的配置</li><li>事务如何使用XML方式进行配置</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用注解的方式配置Bean</title>
      <link href="/2018/11/15/Spring-05/"/>
      <url>/2018/11/15/Spring-05/</url>
      
        <content type="html"><![CDATA[<p>使用注解配置的方式,其是通过包扫描的方式获得哪些类需要装配，Spring启动的起点是一个配置文件，那么该配置文件必然指定了从哪里扫描，怎样去扫描，扫描那些对象被IOC容器所管理等等，下面主要针对基本的步骤进行总结。<br><a id="more"></a></p><h2 id="扫描哪些组件？"><a href="#扫描哪些组件？" class="headerlink" title="扫描哪些组件？"></a>扫描哪些组件？</h2><p>扫描的组件是由以下注解指定的，其都能被Spring的IOC容器所管理，不同的是其语义不同，如下：</p><table><thead><tr><th>注解</th><th>含义</th></tr></thead><tbody><tr><td>@Component</td><td>基本注解, 标识了一个受 Spring 管理的组件</td></tr><tr><td>@Respository</td><td>标识持久层组件</td></tr><tr><td>@Service</td><td>标识持久层组件</td></tr><tr><td>@Controller</td><td>标识表现层组件</td></tr></tbody></table><p>类被以上注解修饰即可被扫描到并装入IOC容器内进行管理</p><h2 id="组件如何装配？"><a href="#组件如何装配？" class="headerlink" title="组件如何装配？"></a>组件如何装配？</h2><p>我们之前通过XML方式来装配大致有如下几种方法：</p><ol><li>直接定义其值（基本类型）</li><li>用ref引用来引用IOC容器管理的其他的对象</li><li>集合的装配</li></ol><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><h3 id="AutoWired-注解"><a href="#AutoWired-注解" class="headerlink" title="@AutoWired 注解"></a>@AutoWired 注解</h3><h3 id="Resource-与-Inject"><a href="#Resource-与-Inject" class="headerlink" title="@Resource 与@ Inject"></a>@Resource 与@ Inject</h3><h3 id="组件如何被装配的？"><a href="#组件如何被装配的？" class="headerlink" title="组件如何被装配的？"></a>组件如何被装配的？</h3><h2 id="确定如何扫描？"><a href="#确定如何扫描？" class="headerlink" title="确定如何扫描？"></a>确定如何扫描？</h2><h3 id="指定扫描什么位置？"><a href="#指定扫描什么位置？" class="headerlink" title="指定扫描什么位置？"></a>指定扫描什么位置？</h3><h3 id="指明排除项目"><a href="#指明排除项目" class="headerlink" title="指明排除项目"></a>指明排除项目</h3><h3 id="指明包含项目"><a href="#指明包含项目" class="headerlink" title="指明包含项目"></a>指明包含项目</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hibernate-02</title>
      <link href="/2018/11/11/Hibernate-02/"/>
      <url>/2018/11/11/Hibernate-02/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Spring-SPEL&amp;Bean的生命周期&amp;从工厂中装配Bean</title>
      <link href="/2018/11/11/Spring-04/"/>
      <url>/2018/11/11/Spring-04/</url>
      
        <content type="html"><![CDATA[<p>今天主要关注以下内容：</p><ul><li>如何给更好的给Bean的属性赋值，甚至将简单的赋值逻辑加入-&gt;SPEL</li><li>如何更细粒度的管理对象在IOC容器中的生命周期-&gt;初始化+销毁方法+初始化方法前后进行处理</li><li>通过工厂方法对Bean进行配置-&gt;静态工厂+实例工厂+FactoryBean方式</li></ul><a id="more"></a><h2 id="SPEL"><a href="#SPEL" class="headerlink" title="SPEL"></a>SPEL</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。其使用<code>#{}</code>作为界定符，所有在大括号内的字符都被认为是SpEL</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><p>整数<code>#{1}</code>，浮点数<code>#{89.7}</code>,科学计数法<code>#{1e4}</code>字符串<code>#{&#39;Hello&#39;}</code>或者<code>#{&quot;Hello&quot;}</code>，布尔值<code>#{false}</code></p><h4 id="引用对象、属性与方法"><a href="#引用对象、属性与方法" class="headerlink" title="引用对象、属性与方法"></a>引用对象、属性与方法</h4><p>引用其他对象<code>#{objName}</code>,对象的属性<code>#{objName.property}</code>,调用方法<code>#{objName.function()}</code>,链式调用方法<code>#{objName.toString().toUpperCase()}</code></p><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>加减乘除不在赘述，这里最关键的是调用静态方法或者字段:<code>#{T(java.lang.Math).PI}</code>比较运算符</p><p>&lt;,&gt;,==,&lt;=,&gt;=,lt,gt,eq,le,ge 例如<code>#{counter.total le 100}</code></p><h4 id="逻辑运算-amp-三目表达式-amp-正则"><a href="#逻辑运算-amp-三目表达式-amp-正则" class="headerlink" title="逻辑运算&amp;三目表达式&amp;正则"></a>逻辑运算&amp;三目表达式&amp;正则</h4><p>逻辑运算：and,or,not,|<code>#{!product.available}</code></p><p>三目表达形式:<code>#{obj.name==&#39;maoxin&#39;?&#39;item1&#39;,&#39;item2&#39;}</code></p><p>正则表达式:<code>#{admin.email matchs &#39;[a-zA-z0-9._%+=]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}&#39;}</code></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>首先在Bean的标签中可以配置两个属性，分别代表Bean的初始化方法以及销毁方法，例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">class</span>=<span class="string">"LifeCircle.SomeWhat"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"value"</span> <span class="attr">value</span>=<span class="string">"123"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过对一下代码的单步执行得到生命周期的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在初始化的IOC容器的时候就执行了构造函数以及init方法</span></span><br><span class="line">ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans-lifecircle.xml"</span>);</span><br><span class="line"><span class="comment">//此时直接从容器中得到</span></span><br><span class="line">SomeWhat someWhat = (SomeWhat) applicationContext.getBean(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">//在容器关闭的时候执行close方法</span></span><br><span class="line">applicationContext.close();</span><br></pre></td></tr></table></figure><p>大致总结下，实例的生命周期</p><ul><li>容器初始化，执行构造方法以及指定的初始化方法</li><li>容器关闭得到时候，执行指定的销毁方法</li></ul><p>在Spring，还可以对Bean的生命周期执行更加细粒度的管理，通过实现<code>BeanPostProcessor</code></p><p>接口。</p><h3 id="BeanPostProcessor接口"><a href="#BeanPostProcessor接口" class="headerlink" title="BeanPostProcessor接口"></a>BeanPostProcessor接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(beanName.toString()+beanName);</span><br><span class="line">        System.out.println(<span class="string">"postProcessAfter"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessBefore"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在XML中配置并且启用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"LifeCircle.MyBeanPostProcessor"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样在IOC容器初始化的过程中就执行完了上述初始化</p><h2 id="从工厂中配置Bean"><a href="#从工厂中配置Bean" class="headerlink" title="从工厂中配置Bean"></a>从工厂中配置Bean</h2><p>从静态方法中配置使用<code>factory-method</code>配合<code></code></p><h3 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h3><p>首先创建静态工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Car&gt; resp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        resp.put(<span class="string">"BMW"</span>,<span class="keyword">new</span> Car(<span class="string">"BMW"</span>,<span class="number">1</span>));</span><br><span class="line">        resp.put(<span class="string">"CCC"</span>,<span class="keyword">new</span> Car(<span class="string">"CCC"</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resp.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方式创建：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car1"</span>  <span class="attr">class</span>=<span class="string">"LifeCircle.CarFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getCar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"BMW"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h3><p>实例工厂首先要创建出这么一个工厂，之后在这个工厂进行配置Bean的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceCarFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Car&gt; cars = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceCarFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cars = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cars.put(<span class="string">"audi"</span>,<span class="keyword">new</span> Car(<span class="string">"audi"</span>,<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cars.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--首先创建实例方法Bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"carFactory"</span> <span class="attr">class</span>=<span class="string">"LifeCircle.InstanceCarFactory"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--再创建实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car2"</span> <span class="attr">factory-bean</span>=<span class="string">"carFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getCar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"audi"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Factory-Bean形式"><a href="#Factory-Bean形式" class="headerlink" title="Factory Bean形式"></a>Factory Bean形式</h2><blockquote><p>参阅<a href="http://book.51cto.com/art/201311/419081.htm" target="_blank" rel="noopener">http://book.51cto.com/art/201311/419081.htm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hibernate起步</title>
      <link href="/2018/11/10/hibernate-01/"/>
      <url>/2018/11/10/hibernate-01/</url>
      
        <content type="html"><![CDATA[<p>之前也多多少少接触过Hibernate框架，只限于简单的使用，没有深入的去理解学习，这次从头开始，踏踏实实完成Hibernate的系统学习，起步部分主要完成如何配置环境，大致操作流程，一些注意点。</p><a id="more"></a><h2 id="导入jar"><a href="#导入jar" class="headerlink" title="导入jar"></a>导入jar</h2><ul><li>从官方网站下载对应的jar包，导入压缩文件中<code>lib/required</code>的全部jar包</li><li>导入数据库驱动</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>总而言之，Hibernate的配置和MyBatis这样的持久层框架的使用可以说是很相似，首先有一个主的配置文件，完成框架属性的配置、数据库驱动的指定、连接池的配置等等。其次，在主的配置文件中也得引入对实体类与数据表的映射文件，是XML格式的。在之下的内容主要是借助与idea这样的IDE工具完成最基本项目的搭建。</p><h3 id="idea中生成主配置文件"><a href="#idea中生成主配置文件" class="headerlink" title="idea中生成主配置文件"></a>idea中生成主配置文件</h3><ol><li>导包完成之后，在ide中项目文件夹中右键-&gt;<code>add  Frameworks Support</code>-&gt; 选中<code>Hibernate</code> </li><li>应用之后打开<code>project structure</code>后转到<code>Modules</code>找到<code>Hibernate</code>点击加号添加主配置文件，成功之后在<code>src</code>下就创建了<code>hibernate.cfg.xml</code></li></ol><h3 id="配置主配置文件"><a href="#配置主配置文件" class="headerlink" title="配置主配置文件"></a>配置主配置文件</h3><ul><li>配置数据库信息</li><li>配置hibernate 信息</li><li>关联的映射信息</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置链接数据库的基本信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/Hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span>???<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置hibernate的基本信息--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--hibernate所使用的数据库方言--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQL55Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--执行时候是否在控制台打印SQL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--是否对SQL进行格式化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定自动生成数据表的策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指明自动关联的.hbm.xml文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"entity/NewsEntity.hbm.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之上配置了一些例如是否在控制台打印SQL的象，格式化SQL等等，需要关注的配置是hbm2ddl.auto：</p><p>该配置名的含义是Hibernate Mapping to Data Define Language(Hibernate 映射转数据定义语言)，其能够帮助我们完成从映射文件到生成数据库实体的过程，取值为</p><table><thead><tr><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>create</td><td>每次运行都会生成表</td></tr><tr><td>create-drop</td><td>除了创建SessionFactory创建生成表之外，关闭的时候删除</td></tr><tr><td>update</td><td>最常用，表结构不同将会输出</td></tr><tr><td>validate</td><td>初始化发现表结构的列不存在会抛出异常</td></tr></tbody></table><h3 id="逆向生成实体对象以及配置文件"><a href="#逆向生成实体对象以及配置文件" class="headerlink" title="逆向生成实体对象以及配置文件"></a>逆向生成实体对象以及配置文件</h3><p>打开 <code>Persistence</code>-&gt;右键-&gt;<code>Generate Persistence Mapping</code>-&gt;<code>By Database Schema</code></p><p><img src="1.png" alt="实例"></p><p>接下来就照提示操作了。</p><p>生成的Bean(只包含字段)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的关系映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"entity.NewsEntity"</span> <span class="attr">table</span>=<span class="string">"news"</span> <span class="attr">schema</span>=<span class="string">"hibernate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"Id"</span> <span class="attr">sql-type</span>=<span class="string">"int(11)"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指明主键的生成方式，native:使用数据库本地的方式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span> <span class="attr">not-null</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"author"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">sql-type</span>=<span class="string">"varchar(255)"</span> <span class="attr">not-null</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"date"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"date"</span> <span class="attr">sql-type</span>=<span class="string">"date"</span> <span class="attr">not-null</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总得来事其中描述了以下关键信息</p><ol><li>数据库列名与字段名的关系</li><li>数据库字段的数据库类型（为了与Java类型进行自动转换）</li><li>字段其他属性</li></ol><h2 id="Hibernate-写入数据库流程"><a href="#Hibernate-写入数据库流程" class="headerlink" title="Hibernate 写入数据库流程"></a>Hibernate 写入数据库流程</h2><ol><li>创建<code>SessionFactory</code>对象(读取配置文件)</li><li>创建Session对象</li><li>开启事务</li><li>执行操作</li><li>提交事务</li><li>关闭Session</li><li>关闭<code>SessionFactory</code></li></ol><p>其中关键点是创建<code>SessionFactory</code>,官方文档给出的创建方式(Hibernate5.0)，之后是对文档内容的翻译。自己翻译的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 一个SessionFactory 在一个应用中启动一次</span></span><br><span class="line"><span class="keyword">final</span> StandardServiceRegistry registry = <span class="keyword">new</span> StandardServiceRegistryBuilder()</span><br><span class="line">.configure() <span class="comment">//依据hibernate.cfg.xml来配置</span></span><br><span class="line">.build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sessionFactory = <span class="keyword">new</span> MetadataSources(registry).buildMetadata().buildSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// registry would be destroyed by the SessionFactory, but we had trouble building the SessionFactory</span></span><br><span class="line"><span class="comment">// so destroy it manually.</span></span><br><span class="line">StandardServiceRegistryBuilder.destroy( registry );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个<code>SetUp</code>方法首先构建了一个<code>org.hibernate.boot.registry.StandardServiceRegistry</code></li></ul><p>实例将配置信息合并到一组工作服务中以供<code>SessionFactory</code>去使用。</p><ul><li><p>使用<code>StandardServiceRegistry</code>我们创建的<code>org.hibernate.boot.MetadataSources</code>是我们告诉Hibernate关于我们领域模型的起点，由于我们是通过<code>hibernate.cfg.xml</code>去配置的，所以这里没有什么特别的需要关注</p></li><li><p><code>org.hibernate.boot.Metadata</code>代表着一个完整的，部分验证过的领域模型视图，而<code>SessionFactory</code>也正是基于此的</p></li><li>在启动过程的最后一步是去构建一个<code>SessionFactory</code>,这个<code>SessionFactory</code>是一个线程安全的对象只实例化一次而服务整个应用</li><li>这个<code>SessionFactory</code>表现的像是一个<code>org.hibernate.Session</code>对象的工厂</li></ul><p>在得到了Session之后，我们就可以进行简单的增删查改了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开Session</span></span><br><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">session.beginTransaction();</span><br><span class="line"><span class="comment">//保存对象实体</span></span><br><span class="line">session.save( <span class="keyword">new</span> Event( <span class="string">"Our very first event!"</span>, <span class="keyword">new</span> Date() ) );</span><br><span class="line">session.save( <span class="keyword">new</span> Event( <span class="string">"A follow up event"</span>, <span class="keyword">new</span> Date() ) );</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">session.getTransaction().commit();、</span><br><span class="line"><span class="comment">//关闭Session</span></span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-Bean的自动装配&amp;关系&amp;作用域&amp;导入外部属性文件</title>
      <link href="/2018/11/10/Spring-03/"/>
      <url>/2018/11/10/Spring-03/</url>
      
        <content type="html"><![CDATA[<p>第三天的内容主要继续了解配置beans的方方面面，包括以下内容：</p><ul><li>自动装配(Auto Wire)</li><li>Bean之间的关系(继承&amp;依赖)</li><li>Bean的作用域(scope=singleton|prototype)</li><li>使用外部属性文件</li></ul><a id="more"></a><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>自动装配是虽不明确指明属性装配什么，但是通过Bean内部属性的名字或者类型自动装配的一种方式，其有三种，最常见的有两种</p><h3 id="自动装配的方式"><a href="#自动装配的方式" class="headerlink" title="自动装配的方式"></a>自动装配的方式</h3><p>装配的方式通过Bean标签的<code>aurowire</code>来指明的</p><h4 id="By-Name"><a href="#By-Name" class="headerlink" title="By Name"></a>By Name</h4><p>By Name方式是通过Bean内部Setter的名字部分去找到id进行装配的，实例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Address address;</span><br><span class="line">    private Car car1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Address"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:city</span>=<span class="string">"BeiJin"</span> <span class="attr">p:street</span>=<span class="string">"Wangfujin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Car"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:brand</span>=<span class="string">"Audi"</span> <span class="attr">p:price</span>=<span class="string">"300000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car1"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Car"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:brand</span>=<span class="string">"NoBrand"</span> <span class="attr">p:price</span>=<span class="string">"20000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Person"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:name</span>=<span class="string">"Tom"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>注意上面设置了两个Car对象，id分别为car1，car，因此预测通过属性名car1应该得到的是car1的内容：运行结果如下</p><p><code>Person(name=Tom, address=Address(city=BeiJin, street=Wangfujin), car1=Car(brand=NoBrand, price=20000.0))</code></p><p>符合预期</p><h4 id="By-Type"><a href="#By-Type" class="headerlink" title="By Type"></a>By Type</h4><p>By Type是通过Class类型来装配的，这也意味着在配置文件中不能有两个相同的作为属性的类配置</p><h3 id="自动装配的缺点"><a href="#自动装配的缺点" class="headerlink" title="自动装配的缺点"></a>自动装配的缺点</h3><p>不够灵活</p><h2 id="Bean之间的关系"><a href="#Bean之间的关系" class="headerlink" title="Bean之间的关系"></a>Bean之间的关系</h2><p>Bean之间的关系主要是：继承和依赖，被继承的父Bean可以充当模版，而交给子Bean去重写，当然也可以设置Bean的abstract属性为true，为抽象Bean，抽象Bean不可以被实例化，如果一个Bean的Class属性没有设置，则必须设置位抽象Bean,子Bean继承可以使用parent属性</p><p>依赖关系主要是在创建对象前指明自己需要依赖的Bean必须加载完成。而不代表设置了依赖自己就会在对应的属性中装载</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"abstractAddreass"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Address"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">p:city</span>=<span class="string">"Beijin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"AutoWareTest.Address"</span> <span class="attr">parent</span>=<span class="string">"abstractAddreass"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:street</span>=<span class="string">"Wangfujin"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>此时创建的Address对象的city自动有了city</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>依赖通过append-on来设置依赖，前置依赖的Bean会在本Bean实例化之前创建好</p><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>通过Bean的scope属性来设置</p><ul><li>scope=”singleton” 默认值，是单例的</li><li>scope=”prototype” 可以创建多个</li></ul><h2 id="整合外部属性文件"><a href="#整合外部属性文件" class="headerlink" title="整合外部属性文件"></a>整合外部属性文件</h2><p>以整合c3p0连接池为例：不使用外部配置文件直接配置搭配bean中，每次修改配置必须打开spring配置文件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"?????"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/struts?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>将具体的配置放置在外部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user=root</span><br><span class="line">password=?????</span><br><span class="line">driverclass=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbcurl=jdbc:mysql://localhost:3306/struts?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC</span><br></pre></td></tr></table></figure></p><p>使用<code>&lt;context:property-placeholder&gt;</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;user&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;driverclass&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbcurl&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-属性注入</title>
      <link href="/2018/11/08/Spring-02/"/>
      <url>/2018/11/08/Spring-02/</url>
      
        <content type="html"><![CDATA[<p>自学Spring框架第二天，今天主要是更加深入的学习了Spring Bean的配置方式（XML形式的）使用方式以及一些注意的点。简而言之就是如何配置一个Bean，属性如何去注入？引用类型如何去注入？集合属性如何去注入，以及Properties属性如何去注入等等。需要注意的是之下的实例代码为了简化使用了 <code>lombok</code>开源工具。</p><a id="more"></a><h2 id="普通属性注入方式"><a href="#普通属性注入方式" class="headerlink" title="普通属性注入方式"></a>普通属性注入方式</h2><p>下面总结的是一般的属性注入方式，普通类型以及引用类型，不包括集合类型，其分为三种，最后一种不常用，暂时没有总结。</p><h3 id="属性名注入"><a href="#属性名注入" class="headerlink" title="属性名注入"></a>属性名注入</h3><p>属性名注入的前提是对应Bean类属性值对应着<code>setter</code>方法，并且创建对象的方式必然通过无参构造方法，因此在Bean类必须保留无参构造方法。首先建立实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String corp;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">    <span class="comment">//无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, String corp, Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.corp = corp;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入对应的XML:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car1"</span> <span class="attr">class</span>=<span class="string">"Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--value在标签内部--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span> <span class="attr">value</span>=<span class="string">"audi"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--value在标签外部--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corp"</span> <span class="attr">value</span>=<span class="string">"my"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>property</code>标签注入，并且<code>value</code>字段可以放在外面也可以放在属性的位置上，由于是在XML中写对应的属性值，因此需要注意如果写特殊字符应该使用<code>&lt;!CDATA[..]]&gt;</code>的方式来引用，例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;AUDI&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后的输出为：</p><p><code>Car(brand=&lt;AUDI&gt;, corp=my, price=2000.0)</code></p><p>如果需要注入一个引用,使用ref来引用id即可注入,首先创建一个需要注入引用的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML相关配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"car1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"maoxin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>打印输出：</p><p><code>User(car=Car(brand=&lt;AUDI&gt;, corp=my, price=2000.0), name=maoxin)</code></p><p>如果不想引用的话，可以创建内部Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"Car"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corp"</span> <span class="attr">value</span>=<span class="string">"corp"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"200"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span> <span class="attr">value</span>=<span class="string">"audi"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"maoxin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打印输出：</p><p><code>User(car=Car(brand=audi, corp=corp, price=200.0), name=maoxin)</code></p><h3 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h3><p>构造方法注入方式关注的是构造函数，而识别构造函数的关键是参数的类型，这也是识别重载的关键，因此使用构造方法注入对应的标签有<code>type</code>属性，同时也有<code>index</code>属性来指明位置，这里列一个两者同时使用的例子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"new_car"</span> <span class="attr">class</span>=<span class="string">"Car"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"brand"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"corp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span> <span class="attr">type</span>=<span class="string">"java.lang.Double"</span> <span class="attr">value</span>=<span class="string">"12.00"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然也可以其在注入引用类型的时候也可以使用<code>ref</code>也可以使用内部Beans</p><h3 id="工厂方法注入"><a href="#工厂方法注入" class="headerlink" title="工厂方法注入"></a>工厂方法注入</h3><p>待续..</p><h2 id="集合属性的赋值"><a href="#集合属性的赋值" class="headerlink" title="集合属性的赋值"></a>集合属性的赋值</h2><p>在Spring中对集合类型的赋值有一系列标签的支持，在这里将User类修改以做一下的Demo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,String&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Car&gt; cars;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>填充cars</p><p>需要指定<code>&lt;list&gt;</code>  标签, 在标签里包含一些元素. 这些标签可以通过 <code>&lt;value&gt;</code> 指定简单的常量值, 通过<code>&lt;ref&gt;</code>指定对其他 Bean 的引用. 通过<code>&lt;bean&gt;</code> 指定内置 Bean 定义. 通过<code>&lt;null/&gt;</code> 指定空元素. 甚至可以内嵌其他集合.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"new_user"</span> <span class="attr">class</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"maoxin"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"car1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"Car"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span> <span class="attr">value</span>=<span class="string">"A"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corp"</span> <span class="attr">value</span>=<span class="string">"B"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map的概念包含Entry、Key和Value，其均对应着标签或者属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maps"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"one"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"two"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"3"</span> <span class="attr">value</span>=<span class="string">"three"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"name"</span>&gt;</span>maoxin<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"password"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"xxx"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="集合信息的外部配置"><a href="#集合信息的外部配置" class="headerlink" title="集合信息的外部配置"></a>集合信息的外部配置</h3><p>之前集合的配置都是在内部实现了，现在配置独立的集合对象，使用util标签，其他都差不多</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"mycars"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"car1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring-的IOC容器简介"><a href="#Spring-的IOC容器简介" class="headerlink" title="Spring 的IOC容器简介"></a>Spring 的IOC容器简介</h2><p>在使用Spring读取Bean之前必须先实例化Spring IOC容器，而Spring 提供了两种类型的IOC容器的实现</p><ul><li>Bean Factory IOC容器的基本实现，面向Spring本身</li><li>Application Context 提供了更多的高级特性，面向使用Spring框架的开发者</li></ul><p>而ApplicationContext也有具体的实现，最常用的是ClassPathXmlApplicationContext以及FileSystemXmlApplicationContext</p><p><img src="1.png" alt="ApplicationContext的继承结构"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring HelloWorld</title>
      <link href="/2018/11/07/Spring-01/"/>
      <url>/2018/11/07/Spring-01/</url>
      
        <content type="html"><![CDATA[<p>自学Spring第一天，主要目的是使用Spring中的Beans完成依赖注入或者叫做控制反转，之后对所学的内容做一个总结。</p><a id="more"></a><h2 id="安装Spring与HelloWorld"><a href="#安装Spring与HelloWorld" class="headerlink" title="安装Spring与HelloWorld"></a>安装Spring与HelloWorld</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>Spring 项目本身托管到Github上，官方首页有通往Github的链接，但是这里提供更为方便的方式去获取Spring相关的jar包<a href="https://repo.spring.io/webapp/#/home" target="_blank" rel="noopener">https://repo.spring.io/webapp/#/home</a></p><h3 id="将jar包添加到目录"><a href="#将jar包添加到目录" class="headerlink" title="将jar包添加到目录"></a>将jar包添加到目录</h3><p><img src="1.png" alt="需要的jar包"></p><p>其中<code>commons-logging.jar</code>需要另外下载</p><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><h3 id="建立一个简单的Bean"><a href="#建立一个简单的Bean" class="headerlink" title="建立一个简单的Bean"></a>建立一个简单的Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello:"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置Spring-Bean容器配置文件"><a href="#配置Spring-Bean容器配置文件" class="headerlink" title="配置Spring Bean容器配置文件"></a>配置Spring Bean容器配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"HelloWorld"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Spring"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是IDEA添加的方式是<code>src上右键</code>-&gt;<code>XMLConfigurationFile</code>-&gt;<code>SpringConfig</code></p><h3 id="实现IOC"><a href="#实现IOC" class="headerlink" title="实现IOC"></a>实现IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//交给Spring完成，依赖于Spring的Beans容器</span></span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"appclicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line">        HelloWorld helloWorld = (HelloWorld) ctx.getBean(<span class="string">"helloWorld"</span>);</span><br><span class="line"></span><br><span class="line">        helloWorld.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对于依赖处理方式的演变"><a href="#对于依赖处理方式的演变" class="headerlink" title="对于依赖处理方式的演变"></a>对于依赖处理方式的演变</h2><h3 id="分类接口与实现"><a href="#分类接口与实现" class="headerlink" title="分类接口与实现"></a>分类接口与实现</h3><p><img src="2.png" alt="阶段1"></p><p>这种方式虽用面向对象的处理方式，抽象出接口，并有其不同的实现类，但是导致依赖于其接口的业务类太过复杂,图中Report Service需要与三个组件打交道</p><h3 id="工厂模式的引入"><a href="#工厂模式的引入" class="headerlink" title="工厂模式的引入"></a>工厂模式的引入</h3><p><img src="3.png" alt="阶段2"></p><p>引入工厂模式，加入了中间层，由工厂去管理依赖，而Report直接依赖与工厂，这样大大简化了阶段一Report Service的职责，由工厂保证是否是单例等等，依赖变少，组织结构变得更加清晰</p><h3 id="IOC方式的引入"><a href="#IOC方式的引入" class="headerlink" title="IOC方式的引入"></a>IOC方式的引入</h3><p><img src="4.png" alt="阶段3"></p><p>由之前需要什么找工厂去“生产”到需要什么让管理器去注入，容器管理对象的完整声明周期。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CORS跨域问题的认识与解决</title>
      <link href="/2018/11/04/HTTP-02/"/>
      <url>/2018/11/04/HTTP-02/</url>
      
        <content type="html"><![CDATA[<p>之前曾经见过跨域问题的解决方式，一个是CORS，一个是JSONP，但是就是处于知其然，不知其所以然的阶段，因此在这里借助网上资料和Node.js来分析和解决如上问题<br><a id="more"></a></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>除去一些常用标签的<code>src</code>，<code>image</code>以及<code>link</code>等属性是可以进行跨域的，一般的其他请求尤其是<code>json</code>请求是不能进行跨域的，否则会出现问题，按照如下方式初始化<code>node.js</code>代码，进行跨域测试：</p><ul><li>Server.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"get request form"</span>,request.url)</span><br><span class="line">    response.end(<span class="string">"HelloWorld"</span>)</span><br><span class="line">&#125;).listen(<span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Server listening on 8887"</span>)</span><br></pre></td></tr></table></figure><ul><li>Server2.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request,responce</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Server2 request form"</span>,request.url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> html = fs.readFileSync(<span class="string">'test.html'</span>,<span class="string">"utf-8"</span>)</span><br><span class="line">    responce.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>:<span class="string">'text/html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    responce.end(html)</span><br><span class="line">&#125;).listen(<span class="number">8889</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Server 2 Listening..."</span>)</span><br></pre></td></tr></table></figure><p>在Server2.js中无论请求如何都会返回一个html页面，该页面主要包含如下请求代码</p><ul><li>html中的js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'http://127.0.0.1:8888/'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>向服务器2进行Http请求控制台信息如图所示</p><p><img src="1.png" alt="错误信息"></p><p>可见，其提示<code>No Access-Control-Allow-Origin</code> ,表示没有Access-Control-Allow-Origin头部信息，无法访问资源</p><p>我们修改服务器添加头信息为<code>Access-Control-Allow-Origin:*</code>在Server1中添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">       <span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>之后就不会报错了，打开控制台的NetWork栏，可以查看到”HelloWorld”字符串</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>由于浏览器允许如文章开始描述的在标签内部访问，所以就可以实现跨域，这也是JSONP的原理，而只要服务器返回的信息满足json这样可以被js原生支持，客户端就会很容易的去处理，在这里我们模拟一种JSONP的方式返回信息</p><p>修改Server1的代码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.end(<span class="string">'&#123;"result":2018&#125;'</span>)</span><br></pre></td></tr></table></figure><p>查看浏览器NetWork，发现返回成功</p><p><img src="2.png" alt="成功"></p><h2 id="CORS跨域的限制"><a href="#CORS跨域的限制" class="headerlink" title="CORS跨域的限制"></a>CORS跨域的限制</h2><p>不是只要设置了<code>Access-Control-Allow-Origin</code>头部就可以随意跨域了</p><ul><li>允许方法<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>允许的Content-Type<ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li><li>请求头。。</li></ul><h3 id="预请求"><a href="#预请求" class="headerlink" title="预请求"></a>预请求</h3><p>之上描述了CORS种种限制，如果想要使用自定义头或者其他Method，浏览器采用了预请求的方式，先发送一个Method=OPTION的请求，根据返回的头信息来判断请求是否合法，而服务器返回如下字段来判断<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span>,</span><br><span class="line"><span class="string">'Access-Control-Allow-Headers'</span>:<span class="string">'X-Test-Cors'</span>,</span><br><span class="line"><span class="string">'Access-Control-Allow-Method'</span>:<span class="string">'POST,PUT,DElete'</span>,</span><br><span class="line"><span class="string">'Access-Control-Max-Age'</span>:<span class="string">'1000'</span><span class="comment">//代表1000s之内不用发送预请求</span></span><br></pre></td></tr></table></figure></p><h2 id="练习代码地址"><a href="#练习代码地址" class="headerlink" title="练习代码地址"></a>练习代码地址</h2><blockquote><p><a href="https://gitee.com/lumaoxin/DemoHouse/tree/master/CORS" target="_blank" rel="noopener">https://gitee.com/lumaoxin/DemoHouse/tree/master/CORS</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP协议的三次握手</title>
      <link href="/2018/11/04/HTTP-01/"/>
      <url>/2018/11/04/HTTP-01/</url>
      
        <content type="html"><![CDATA[<p>HTTP协议是基于TCP的，一个TCP请求可以传送多个请求，在HTTP0.9/1.0中，连接建立，请求发送得到响应之后，HTTP链接就被关闭了。而在HTTP/1.1中链接会得到一定的保持（长链接),之所以会有这样的改进是因为创建链接的开销太大，需要三次握手（TCP的三次握手）<br><a id="more"></a></p><h2 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h2><ol><li>Client发出请求，传递到服务器（此时客户端不知道Server能否联通）</li><li>Server得到了请求，向Client发出一个确认，此时服务器不知道Client能否收到数据</li><li>客户端收到请求之后，知道Client和Server通信没问题，问题是Server不知道自己的信送到了没？所以Client再次发送一个确认包。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>7种方式去重构Java的Switch语句</title>
      <link href="/2018/10/27/design-1/"/>
      <url>/2018/10/27/design-1/</url>
      
        <content type="html"><![CDATA[<p>自己翻译的，英语渣，其实看代码意思就都能理解，这里放上原网址<br><a id="more"></a></p><blockquote><p><a href="https://www.developer.com/java/data/seven-ways-to-refactor-java-switch-statements.html" target="_blank" rel="noopener">https://www.developer.com/java/data/seven-ways-to-refactor-java-switch-statements.html</a></p></blockquote><h2 id="1-通过Java的枚举实现策略模式"><a href="#1-通过Java的枚举实现策略模式" class="headerlink" title="1.通过Java的枚举实现策略模式"></a>1.通过Java的枚举实现策略模式</h2><p>一个典型的例子涉及到一个Java的枚举，并且在枚举的基础上有一个或者多个switch语句，让我们假设有如下简单的Java枚举，代表不同的运动员类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PlayerTypes &#123;</span><br><span class="line">    TENNIS,FOOTBALL,SNOOKER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的switch语句用来创建不同类型的“运动员”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerCreator</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Player <span class="title">createPlayer</span><span class="params">(PlayerTypes playerType)</span></span>&#123; </span><br><span class="line">        <span class="keyword">switch</span> (playerType) &#123;</span><br><span class="line">            <span class="keyword">case</span> TENNIS:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TennisPlayer();</span><br><span class="line">            <span class="keyword">case</span> FOOTBALL:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FootballPlayer();</span><br><span class="line">            <span class="keyword">case</span> SNOOKER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SnookerPlayer();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid player type: "</span></span><br><span class="line">                    + playerType);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>想要创建网球运动员，就使用<code>PlayerTypes.TENNIS</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PlayerCreator playerCreator = <span class="keyword">new</span> PlayerCreator();</span><br><span class="line">Player tennisPlayer =</span><br><span class="line">   playerCreator.createPlayer(PlayerTypes.TENNIS);</span><br></pre></td></tr></table></figure></p><h3 id="依赖使用常量特定方法实现的枚举"><a href="#依赖使用常量特定方法实现的枚举" class="headerlink" title="依赖使用常量特定方法实现的枚举"></a>依赖使用常量特定方法实现的枚举</h3><p>但是，这里有一种更好的方式去将每个枚举常量本身和其行为联系在一起，这种方式被称为：具有常量特定方法实现的枚举类型（enum type with constant-specific method implementation）并且它在Joshua Bloch的《Effective Java 第二版》中被描述。遵循着这一思想，我们可以通过增加一个抽象的方法来丰富我们的<code>playertypes</code>枚举类，而对于枚举类中的每个值，我们提供一个实现，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PlayerTypes &#123; </span><br><span class="line">TENNIS &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Player <span class="title">createPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TennisPlayer();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br><span class="line">FOOTBALL &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Player <span class="title">createPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FootballPlayer();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br><span class="line">SNOOKER &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Player <span class="title">createPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> SnookerPlayer();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Player <span class="title">createPlayer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果想要创建一个足球运动员,使用<code>PlayersType.FOOTBLL</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Player footballPlayer =</span><br><span class="line">   PlayerTypes.valueOf(<span class="string">"FOOTBALL"</span>).createPlayer();</span><br></pre></td></tr></table></figure></p><h2 id="2-实现命令模式"><a href="#2-实现命令模式" class="headerlink" title="2.实现命令模式"></a>2.实现命令模式</h2><p>现在，让我们写一个同样的<code>switch</code>逻辑，但是是基于字符串类型的，在Java 7及以上，我们是可以使用一个字符串对象放在switch语句中，毕竟，大多数的Java编译器将会针对这种实现方式生成比类似<code>if-else-if</code>链更加高效的字节码，当然，这并不是太坏:),但是，一个siwtch仍然使得类与类之间的关系错综复杂，并且缺点也是一样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Player <span class="title">createPlayer</span><span class="params">(String playerType)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (playerType) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"TENNIS"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TennisPlayer();</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"FOOTBALL"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FootballPlayer();</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"SNOOKER"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SnookerPlayer();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">               (<span class="string">"Invalid player type: "</span> + playerType);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建一个网球运动员只需要一个“TENNIS”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PlayerCreator playerCreator = <span class="keyword">new</span> PlayerCreator();</span><br><span class="line">Player tennisPlayer = playerCreator.createPlayer(<span class="string">"TENNIS"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="实现命令模式"><a href="#实现命令模式" class="headerlink" title="实现命令模式"></a>实现命令模式</h3><p>另外，我们可以依赖“命令”模式，我们可以通过两步来构建命令模式，首先，我们定义一个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">   <span class="function">Player <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着，我们为每个运动员类型类型提供对应该接口的具体实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatePlayerCommand</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Command&gt; PLAYERS;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Map&lt;String, Command&gt; players = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      players.put(<span class="string">"TENNIS"</span>, <span class="keyword">new</span> Command() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Player <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TennisPlayer();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      players.put(<span class="string">"FOOTBALL"</span>, <span class="keyword">new</span> Command() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Player <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FootballPlayer();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      players.put(<span class="string">"SNOOKER"</span>, <span class="keyword">new</span> Command() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Player <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SnookerPlayer();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      PLAYERS = Collections.unmodifiableMap(players);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Player <span class="title">createPlayer</span><span class="params">(String playerType)</span> </span>&#123;</span><br><span class="line">      Command command = PLAYERS.get(playerType);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid player type: "</span></span><br><span class="line">            + playerType);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> command.create();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，创建一个斯诺克运动员<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CreatePlayerCommand createCommand = <span class="keyword">new</span> CreatePlayerCommand();</span><br><span class="line">Player snookerPlayer = createCommand.createPlayer(<span class="string">"SNOOKER"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="3-使用Java8以及之后版本的Supplier接口"><a href="#3-使用Java8以及之后版本的Supplier接口" class="headerlink" title="3.使用Java8以及之后版本的Supplier接口"></a>3.使用Java8以及之后版本的Supplier接口</h2><p>将Switch语句的内容转换为一个<code>Map</code>类型是一种常用方法，这个想法的关键是将每一个<code>case</code>分支作为<code>Map</code>的值并且使用<code>case</code>的条件作为key，在Java 8以及之后的版本，我们可以充分利用<code>Supplier</code>和构造器引用，因此，让我们创建一个Map通过使用类的名字和关键字new一个构造器的引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerSupplier</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Supplier&lt;Player&gt;&gt;</span><br><span class="line">      PLAYER_SUPPLIER;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Map&lt;String, Supplier&lt;Player&gt;&gt;</span><br><span class="line">         players = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      players.put(<span class="string">"TENNIS"</span>, TennisPlayer::<span class="keyword">new</span>);</span><br><span class="line">      players.put(<span class="string">"FOOTBALL"</span>, FootballPlayer::<span class="keyword">new</span>);</span><br><span class="line">      players.put(<span class="string">"SNOOKER"</span>, SnookerPlayer::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">      PLAYER_SUPPLIER = Collections.unmodifiableMap(players);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Player <span class="title">supplyPlayer</span><span class="params">(String playerType)</span> </span>&#123;</span><br><span class="line">      Supplier&lt;Player&gt; player = PLAYER_SUPPLIER.get(playerType);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (player == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid player type: "</span></span><br><span class="line">            + playerType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> player.get();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样创建一个斯诺克运动员：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PlayerSupplier playerSupplier = <span class="keyword">new</span> PlayerSupplier();</span><br><span class="line">Player snookerPlayer = playerSupplier.supplyPlayer(<span class="string">"SNOOKER"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="4-定义一个通用的函数式接口"><a href="#4-定义一个通用的函数式接口" class="headerlink" title="4.定义一个通用的函数式接口"></a>4.定义一个通用的函数式接口</h2><p>与第三点几乎相似的实现如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputeTennisPlayerStatistics</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">ComputeTennisPlayerStatistics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">computeTrend</span><span class="params">(TennisPlayer tennisPlayer,</span></span></span><br><span class="line"><span class="function"><span class="params">         Period period, String owner, String trend)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (trend) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"SERVE"</span>:</span><br><span class="line">            <span class="keyword">return</span> Statistics.computeServeTrend(tennisPlayer,</span><br><span class="line">               period, owner);</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"FOREHAND"</span>:</span><br><span class="line">            <span class="keyword">return</span> Statistics.computeForehandTrend(tennisPlayer,</span><br><span class="line">               period, owner);</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"BACKHAND"</span>:</span><br><span class="line">            <span class="keyword">return</span> Statistics.computeBackhandTrend(tennisPlayer,</span><br><span class="line">               period, owner);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">               (<span class="string">"Invalid trend attribute: "</span> + trend);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到SERVE趋势(我们使用了伪参数，在这里他们并不相关):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String serveTrend = ComputeTennisPlayerStatistics.</span><br><span class="line">computeTrend(<span class="keyword">new</span> TennisPlayer(), Period.ZERO, <span class="string">"TENNIS MAGAZINE"</span>,</span><br><span class="line">   <span class="string">"SERVE"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="实现-TriFunction-接口"><a href="#实现-TriFunction-接口" class="headerlink" title="实现 TriFunction 接口"></a>实现 TriFunction 接口</h3><p>这次，每个case语句执行一个接受三个参数的静态方法并且返回一个字符串类型，在这样的情况下，一个<code>Supplier</code>不能使用，因为我们有多于两个参数，我们不能使用<code>BiFunction</code>,在这里有一个方法将会通过我们定义自己的函数式接口，之后和我们之前使用Map一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TriFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">V</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">R <span class="title">apply</span><span class="params">(T t, U u, V v)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalStatistics</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">FunctionalStatistics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, TriFunction&lt;TennisPlayer,</span><br><span class="line">         Period, String, String&gt;&gt;</span><br><span class="line">      STATISTICS = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      STATISTICS.put(<span class="string">"SERVE"</span>, Statistics::computeServeTrend);</span><br><span class="line">      STATISTICS.put(<span class="string">"FOREHAND"</span>, Statistics::computeForehandTrend);</span><br><span class="line">      STATISTICS.put(<span class="string">"BACKHAND"</span>, Statistics::computeBackhandTrend);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">computeTrend</span><span class="params">(TennisPlayer tennisPlayer,</span></span></span><br><span class="line"><span class="function"><span class="params">      Period period, String owner, String trend)</span> </span>&#123;</span><br><span class="line">      TriFunction&lt;TennisPlayer, Period, String, String&gt;</span><br><span class="line">            function = STATISTICS.get(trend);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (function == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid trend type: "</span></span><br><span class="line">            + trend);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> function.apply(tennisPlayer, period, owner);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到 FOREHAND 趋势 (我们使用了伪参数，在这里他们并不相关):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String forehandTrend = FunctionalStatistics.</span><br><span class="line">computeTrend(<span class="keyword">new</span> TennisPlayer(), Period.ZERO, <span class="string">"SPORT TV"</span>,</span><br><span class="line">   <span class="string">"FOREHAND"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="5-依赖抽象工厂"><a href="#5-依赖抽象工厂" class="headerlink" title="5. 依赖抽象工厂"></a>5. 依赖抽象工厂</h2><p>在这个小结，我们将会遵循Robert C. Martin的代码整洁之道的相关内容，我们以一个可以通过抽象工厂设计模式来隐藏的<code>switch</code>开始<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassicPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> delta;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ClassicPlayer</span><span class="params">(Type type, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.type = type;</span><br><span class="line">      <span class="keyword">this</span>.delta = delta;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDelta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delta;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Statistics</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">playerEndurance</span><span class="params">(ClassicPlayer player)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> delta = player.getDelta();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (player.getType()) &#123;</span><br><span class="line">         <span class="keyword">case</span> TENNIS:</span><br><span class="line">            <span class="keyword">return</span> ComputeEnduranceAlgorithm.basicEndurance(delta)</span><br><span class="line">               + ComputeEnduranceAlgorithm.hardEndurance(delta);</span><br><span class="line">         <span class="keyword">case</span> FOOTBALL:</span><br><span class="line">            <span class="keyword">return</span> ComputeEnduranceAlgorithm.hardEndurance(delta)</span><br><span class="line">               * ComputeEnduranceAlgorithm.factorEndurance(delta);</span><br><span class="line">         <span class="keyword">case</span> SNOOKER:</span><br><span class="line">            <span class="keyword">return</span> ComputeEnduranceAlgorithm.basicEndurance(delta);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">               (<span class="string">"Invalid player type: "</span> + player.getType());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>计算一个网球运动员的耐力如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Statistics statistics = <span class="keyword">new</span> Statistics();</span><br><span class="line"></span><br><span class="line">ClassicPlayer player = <span class="keyword">new</span> ClassicPlayer(Type.TENNIS, <span class="number">54</span>);</span><br><span class="line"><span class="keyword">int</span> tennisPlayerEndurance = statistics.playerEndurance(player);</span><br></pre></td></tr></table></figure></p><p>当然，这是一个混乱的实现，想象一下你需要去添加另外一个方法去计算一个运动员的反应速度，这将需要另外一个<code>switch</code>语句，也许你将在每个case分支中嵌套更多的if并且重命名之前的方法名类似playerStatistics,每次一个新的方法将被增加，代码就需要进行相应的调整</p><h2 id="实现抽象工厂模式"><a href="#实现抽象工厂模式" class="headerlink" title="实现抽象工厂模式"></a>实现抽象工厂模式</h2><p>我们可以重写这个代码通过使用多态性性并且和一个抽象工厂方法的实线，首先，我们删除<code>ClasssicPlayer</code>类并且创建一个抽象类<code>player</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> delta;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(Type type, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.type = type;</span><br><span class="line">      <span class="keyword">this</span>.delta = delta;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDelta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delta;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">playerEndurance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// More similar methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们可以实现一个足球,网球，和斯诺克等运动员类，比如，一个斯诺克运动员类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnookerPlayer</span> <span class="keyword">extends</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SnookerPlayer</span><span class="params">(Type type, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(type, delta);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">playerEndurance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ComputeEnduranceAlgorithm.basicEndurance</span><br><span class="line">         (<span class="keyword">this</span>.getDelta());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更进一步，我们创建一个运动员工厂(AbstractPlayerFactory)接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractPlayerFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Player <span class="title">createPlayer</span><span class="params">(Type type, <span class="keyword">int</span> delta)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终，我们将switch的实现埋在这个接口的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerFactory</span> <span class="keyword">implements</span> <span class="title">AbstractPlayerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Player <span class="title">createPlayer</span><span class="params">(Type type, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">         <span class="keyword">case</span> TENNIS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TennisPlayer(type, delta);</span><br><span class="line">         <span class="keyword">case</span> FOOTBALL:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FootballPlayer(type, delta);</span><br><span class="line">         <span class="keyword">case</span> SNOOKER:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SnookerPlayer(type, delta);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid player type: "</span></span><br><span class="line">            + type);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>计算一个斯诺克运动员的耐力<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PlayerFactory playerFactory = <span class="keyword">new</span> PlayerFactory();</span><br><span class="line">Player snookerPlayer = playerFactory.createPlayer(Type.SNOOKER, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> snookerPlayerEndurance = snookerPlayer.playerEndurance();</span><br></pre></td></tr></table></figure></p><p>或者，我们可以直接初始化一个正确的Player类，而完全不使用Switch<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SnookerPlayer snookerPlayer = <span class="keyword">new</span> SnookerPlayer(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span> snookerPlayerEndurance  = snookerPlayer.playerEndurance();</span><br></pre></td></tr></table></figure></p><h2 id="6-实现状态模式"><a href="#6-实现状态模式" class="headerlink" title="6.实现状态模式"></a>6.实现状态模式</h2><p>让我们假设我们有如下两个相互依存的switch<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassicPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         state = <span class="number">1</span>; System.out.println(<span class="string">"Registering ..."</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         System.out.println(<span class="string">"Aready Registered ..."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            state = <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">"Un-registering ..."</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">"Aready Unregistered ..."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简而言之，在这个例子中，我们只有两个相互依存的switch结构，并且我们可以调用他们按照如下方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassicPlayer classicPlayer = <span class="keyword">new</span> ClassicPlayer();</span><br><span class="line">classicPlayer.register();</span><br><span class="line">classicPlayer.unregister();</span><br><span class="line"><span class="comment">// Causes "Already Unregistered ..." message</span></span><br><span class="line">classicPlayer.unregister();</span><br></pre></td></tr></table></figure></p><h3 id="实现状态模式"><a href="#实现状态模式" class="headerlink" title="实现状态模式"></a>实现状态模式</h3><p>跟进一步，让我们应用状态模式去消除这些<code>switch</code>语句，我们首先创建一个接口为我们的状态定义一些方法（动作）接口，<code>register</code>and<code>unregister</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlayerState</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们定义一个<code>Player</code>类来实现<code>PlayerState</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">PlayerState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> PlayerState registered;</span><br><span class="line">   <span class="keyword">private</span> PlayerState unregistered;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> PlayerState state;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.registered = <span class="keyword">new</span> PlayerRegister(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">this</span>.unregistered = <span class="keyword">new</span> PlayerUnregister(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.state = <span class="keyword">this</span>.unregistered;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      state.register();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      state.unregister();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下为Registered、unregistered、state的getter和setter</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PlayerState <span class="title">getRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> registered;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegistered</span><span class="params">(PlayerState registered)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.registered = registered;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PlayerState <span class="title">getUnregistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> unregistered;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnregistered</span><span class="params">(PlayerState unregistered)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.unregistered = unregistered;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PlayerState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(PlayerState state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PlayerRegister</code>和<code>PlayerUnregister</code>的代码列举在下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerRegister</span> <span class="keyword">implements</span> <span class="title">PlayerState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Player player;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PlayerRegister</span><span class="params">(Player player)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.player = player;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Already Registered ..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Unregistering ..."</span>);</span><br><span class="line">      player.setState(player.getUnregistered());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerUnregister</span> <span class="keyword">implements</span> <span class="title">PlayerState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Player player;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PlayerUnregister</span><span class="params">(Player player)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.player = player;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Registering ..."</span>);</span><br><span class="line">      player.setState(player.getRegistered());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Already Unregistered ..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以创建一个Player并且完成如下状态的切换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Player player = <span class="keyword">new</span> Player();</span><br><span class="line">player.register();</span><br><span class="line">player.unregister();</span><br><span class="line"><span class="comment">// Causes an "Already Unregistered ..." message</span></span><br><span class="line">player.unregister();</span><br></pre></td></tr></table></figure><h2 id="7-通过Predicate来实现"><a href="#7-通过Predicate来实现" class="headerlink" title="7. 通过Predicate来实现"></a>7. 通过Predicate来实现</h2><p>在最后一个例子中，让我们假设在switch语句中的每个case包含多个if分支，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Player <span class="title">createPlayer</span><span class="params">(String playerType, <span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (playerType) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"TENNIS"</span>:</span><br><span class="line">            <span class="keyword">if</span> (rank == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> TennisPlayer(<span class="string">"Rafael Nadal"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rank &gt; <span class="number">1</span> &amp;&amp; rank &lt; <span class="number">5</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> TennisPlayer(<span class="string">"Roger Federer"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rank &gt;= <span class="number">5</span> &amp;&amp; rank &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> TennisPlayer(<span class="string">"Andy Murray"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> <span class="string">"FOOTBALL"</span>:</span><br><span class="line">            <span class="keyword">if</span> (rank == <span class="number">1</span> || rank == <span class="number">2</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> FootballPlayer(<span class="string">"Lionel Messi"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rank &gt; <span class="number">2</span> &amp;&amp; rank &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> FootballPlayer(<span class="string">"Cristiano Ronaldo"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> <span class="string">"SNOOKER"</span>:</span><br><span class="line">            <span class="keyword">if</span> (rank == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> SnookerPlayer(<span class="string">"Ronnie O'Sullivan"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rank == <span class="number">2</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> SnookerPlayer(<span class="string">"Mark Selby"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rank &gt; <span class="number">3</span> &amp;&amp; rank &lt; <span class="number">7</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> SnookerPlayer(<span class="string">"John Higgins"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rank &gt;= <span class="number">7</span> &amp;&amp; rank &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> SnookerPlayer(<span class="string">"Neil Robertson"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">               (<span class="string">"Invalid player type: "</span> + playerType);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得一个输出: <code>Tennis player: Andy Murray</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PlayerCreator playerCreator = <span class="keyword">new</span> PlayerCreator();</span><br><span class="line">Player tennisPlayer = playerCreator.createPlayer(<span class="string">"TENNIS"</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>如果我们假设if语句可以被视作是<code>Predicate&lt;Integer&gt;</code>我们可以重写这个工具类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerSupplier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">PlayerSupplier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,</span><br><span class="line">      Map&lt;Predicate&lt;Integer&gt;,</span><br><span class="line">      Supplier&lt;Player&gt;&gt;&gt; PLAYER_CREATOR;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Map&lt;String, Map&lt;Predicate&lt;Integer&gt;,</span><br><span class="line">         Supplier&lt;Player&gt;&gt;&gt; playerCreator = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Map&lt;Predicate&lt;Integer&gt;,</span><br><span class="line">         Supplier&lt;Player&gt;&gt; tennisPlayers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      tennisPlayers.put(rank -&gt; rank == <span class="number">1</span>, () -&gt;</span><br><span class="line">         <span class="keyword">new</span> TennisPlayer(<span class="string">"Rafael Nadal"</span>));</span><br><span class="line">      tennisPlayers.put(rank -&gt; rank &gt; <span class="number">1</span> &amp;&amp; rank &lt; <span class="number">5</span>, () -&gt;</span><br><span class="line">         <span class="keyword">new</span> TennisPlayer(<span class="string">"Roger Federer"</span>));</span><br><span class="line">      tennisPlayers.put(rank -&gt; rank &gt;= <span class="number">5</span> &amp;&amp; rank &lt;= <span class="number">10</span>, () -&gt;</span><br><span class="line">         <span class="keyword">new</span> TennisPlayer(<span class="string">"Andy Murray"</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Map&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt;</span><br><span class="line">         footballPlayers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      footballPlayers.put(rank -&gt; rank == <span class="number">1</span> || rank == <span class="number">2</span>,()-&gt;</span><br><span class="line">         <span class="keyword">new</span> TennisPlayer(<span class="string">"Lionel Messsi"</span>));</span><br><span class="line">      footballPlayers.put(rank -&gt; rank &gt; <span class="number">2</span> &amp;&amp; rank &lt;= <span class="number">10</span>,()-&gt;</span><br><span class="line">         <span class="keyword">new</span> TennisPlayer(<span class="string">"Cristiano Ronaldo"</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Map&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt;</span><br><span class="line">         snookerPlayers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      snookerPlayers.put(rank -&gt; rank == <span class="number">1</span>, () -&gt;</span><br><span class="line">         <span class="keyword">new</span> TennisPlayer(<span class="string">"Ronnie O'Sullivan"</span>));</span><br><span class="line">      snookerPlayers.put(rank -&gt; rank == <span class="number">2</span>, () -&gt;</span><br><span class="line">         <span class="keyword">new</span> TennisPlayer(<span class="string">"Mark Selby"</span>));</span><br><span class="line">      snookerPlayers.put(rank -&gt; rank &gt; <span class="number">3</span> &amp;&amp; rank &lt; <span class="number">7</span>, () -&gt;</span><br><span class="line">         <span class="keyword">new</span> TennisPlayer(<span class="string">"John Higgins"</span>));</span><br><span class="line">      snookerPlayers.put(rank -&gt; rank &gt;= <span class="number">7</span> &amp;&amp; rank &lt;= <span class="number">10</span>, () -&gt;</span><br><span class="line">         <span class="keyword">new</span> TennisPlayer(<span class="string">"Neil Robertson"</span>));</span><br><span class="line"></span><br><span class="line">      playerCreator.put(<span class="string">"TENNIS"</span>, tennisPlayers);</span><br><span class="line">      playerCreator.put(<span class="string">"FOOTBALL"</span>, footballPlayers);</span><br><span class="line">      playerCreator.put(<span class="string">"SNOOKER"</span>, snookerPlayers);</span><br><span class="line"></span><br><span class="line">      PLAYER_CREATOR = Collections.unmodifiableMap(playerCreator);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Player <span class="title">supplyPlayer</span><span class="params">(String playerType,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rank &lt; <span class="number">1</span> || rank &gt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid rank: "</span> +</span><br><span class="line">            rank);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!PLAYER_CREATOR.containsKey(playerType)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid player type: "</span></span><br><span class="line">            + playerType);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Map&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt; players =</span><br><span class="line">         PLAYER_CREATOR.get(playerType);</span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;Predicate&lt;Integer&gt;, Supplier&lt;Player&gt;&gt;</span><br><span class="line">            entry : players.entrySet()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (entry.getKey().test(rank)) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry.getValue().get();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The players map is</span></span><br><span class="line"><span class="string">         corrupted"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下的使用方式可以获取到 <code>Football player: Cristiano Ronaldo</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Player footballPlayer = PlayerSupplier.supplyPlayer(<span class="string">"FOOTBALL"</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>其他方法可以使用枚举来构成，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PlayerTypes &#123;</span><br><span class="line"></span><br><span class="line">   TENNIS(Collections.unmodifiableList(Arrays.asList(</span><br><span class="line">      () -&gt; <span class="keyword">new</span> TennisPlayer(<span class="string">"Rafael Nadal"</span>),</span><br><span class="line">      () -&gt; <span class="keyword">new</span> TennisPlayer(<span class="string">"Roger Federer"</span>),</span><br><span class="line">      () -&gt; <span class="keyword">new</span> TennisPlayer(<span class="string">"Andy Murray"</span>))</span><br><span class="line">   ),</span><br><span class="line">   Collections.unmodifiableList(Arrays.asList(</span><br><span class="line">      rank -&gt; rank == <span class="number">1</span>, rank -&gt; rank &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">      rank &lt; <span class="number">5</span>, rank -&gt; rank &gt;= <span class="number">5</span> &amp;&amp; rank &lt;= <span class="number">10</span>))</span><br><span class="line">   ),</span><br><span class="line">   FOOTBALL(Collections.unmodifiableList(Arrays.asList(</span><br><span class="line">      () -&gt; <span class="keyword">new</span> FootballPlayer(<span class="string">"Lionel Messi"</span>),</span><br><span class="line">      () -&gt; <span class="keyword">new</span> FootballPlayer(<span class="string">"Cristiano Ronaldo"</span>))</span><br><span class="line">   ),</span><br><span class="line">   Collections.unmodifiableList(Arrays.asList(</span><br><span class="line">      rank -&gt; rank == <span class="number">1</span> || rank == <span class="number">2</span>,</span><br><span class="line">      rank -&gt; rank &gt; <span class="number">2</span> &amp;&amp; rank &lt;= <span class="number">10</span>))</span><br><span class="line">   ),</span><br><span class="line">   SNOOKER(Collections.unmodifiableList(Arrays.asList(</span><br><span class="line">      () -&gt; <span class="keyword">new</span> SnookerPlayer(<span class="string">"Ronnie O'Sullivan"</span>),</span><br><span class="line">      () -&gt; <span class="keyword">new</span> SnookerPlayer(<span class="string">"Mark Selby"</span>),</span><br><span class="line">      () -&gt; <span class="keyword">new</span> SnookerPlayer(<span class="string">"John Higgins"</span>),</span><br><span class="line">      () -&gt; <span class="keyword">new</span> SnookerPlayer(<span class="string">"Neil Robertson"</span>))</span><br><span class="line">   ),</span><br><span class="line">   Collections.unmodifiableList(Arrays.asList(</span><br><span class="line">      rank -&gt; rank == <span class="number">1</span>, rank -&gt; rank == <span class="number">2</span>,</span><br><span class="line">      rank -&gt; rank &gt; <span class="number">3</span> &amp;&amp; rank &lt; <span class="number">7</span>,</span><br><span class="line">      rank -&gt; rank &gt;= <span class="number">7</span> &amp;&amp; rank &lt;= <span class="number">10</span>))</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Supplier&lt;Player&gt;&gt; names;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Predicate&lt;Integer&gt;&gt; conditions;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">PlayerTypes</span><span class="params">(List&lt;Supplier&lt;Player&gt;&gt; names,</span></span></span><br><span class="line"><span class="function"><span class="params">         List&lt;Predicate&lt;Integer&gt;&gt; conditions)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.names = names;</span><br><span class="line">      <span class="keyword">this</span>.conditions = conditions;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Player <span class="title">supplyPlayer</span><span class="params">(String playerType,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rank &lt; <span class="number">1</span> || rank &gt; <span class="number">10</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid rank: "</span> +</span><br><span class="line">            rank);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      List&lt;Predicate&lt;Integer&gt;&gt; selectors =</span><br><span class="line">         PlayerTypes.valueOf(playerType).conditions;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectors.size(); i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (selectors.get(i).test(rank)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PlayerTypes.valueOf(playerType)</span><br><span class="line">               .names.get(i).get();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The enum is corrupted"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到如下输出:<code>Snooker player: Neil Robertson</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Player snookerPlayer = PlayerTypes.supplyPlayer(<span class="string">"SNOOKER"</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，你看到了七种方法去解决switch结构，如下</p><ul><li>用枚举的形式实现策略模式</li><li>实现命令模式</li><li>使用Java8 之后的 Supplier</li><li>定义一个通用的函数式接口</li><li>使用抽象工厂</li><li>实现状态模式</li><li>通过Predicate</li></ul><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>几种方式都离不开表驱动，如何构成这张表，第一个枚举形式是将枚举值本身构成了表</p><p>命令模式是将表项抽象了一个接口”命令“来放到Map中构成表</p><p>之后包括Java8的函数式接口等等只是表的填充方式不同</p><p>抽象工厂还是以Switch来实现的，这个表只不过被抽象层压在下面，抽象工厂接口提供了工厂的统一访问方式，而具体类去实现这个接口，由工厂类去实现管理</p><p>状态模式适用于状态之间关系相互依赖，相对复杂，将依赖项揪出来，将依赖项的状态独立出来，依赖项影响的方法作为接口交给具体类去实现</p><p>最后一个通过Predicate感觉略有鸡肋。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NIO-Selector</title>
      <link href="/2018/10/13/NIO-02/"/>
      <url>/2018/10/13/NIO-02/</url>
      
        <content type="html"><![CDATA[<p>此博客是对知乎海纳文章的理解与总结</p><h2 id="引入多路复用的原因"><a href="#引入多路复用的原因" class="headerlink" title="引入多路复用的原因"></a>引入多路复用的原因</h2><ol><li>服务器与客户端通信时，原来的场景需要大量的服务线程，连接时间很短，数据量发送很小，大量的服务线程使得竞争加剧，大量的开销会严重影响OS的效率</li><li>IO多路复用，可以解决线程切换的问题，可以同在很少的线程中管理多路IO</li><li>不是说IO多路复用效率一定高，要看具体场景，如果是两个对等机器之间建立了TCP连接，并且通过TCP连接来发送一个大文件，有大量的数据传输。在这种场景中，阻塞式的写法简单高效。</li><li>另外加深理解，需要明白一台服务器能创建的线程数是十分有限的，在Java中创建线程，一个线程默认就会预留1M的空间，那么1G的内存也不过只能支持1000个线程创建而已。<h2 id="Linux中的Poll"><a href="#Linux中的Poll" class="headerlink" title="Linux中的Poll"></a>Linux中的Poll</h2><h3 id="什么是poll"><a href="#什么是poll" class="headerlink" title="什么是poll?"></a>什么是poll?</h3>poll系统调用让操作系统管理多个链接，监视其发生的事件，并</li></ol><blockquote><p>参考资料: <a href="https://zhuanlan.zhihu.com/p/27419141" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27419141</a> 海纳<br>问题与实现: select poll epoll <a href="https://blog.csdn.net/davidsguo008/article/details/73556811" target="_blank" rel="noopener">https://blog.csdn.net/davidsguo008/article/details/73556811</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NIO-Buffer</title>
      <link href="/2018/10/13/NIO-01/"/>
      <url>/2018/10/13/NIO-01/</url>
      
        <content type="html"><![CDATA[<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer实现了一个缓存区读写区域，通过四个”指针”的灵活运用，完成在缓冲区内部的读写变换<br><a id="more"></a><br>这四个指针分别是:</p><ol><li>Capacity 容量，在创建时就定下的，代指缓冲区容量</li><li>Limit 限制，指的是在读写两个操作中缓存区能操作的上界</li><li>Position 代指下一个要读写元素的位置</li><li>mark 一个标记，用于恢复到上一次读写位置<br>从上面的描述很容易看出，Limit与position是有两个不同的语义的，在不同操作的情况下，其指向的位置必须做出改变：</li></ol><ul><li>在写操作时，position指向的是下一个要写的位置，limit与capacity相等，表示能写的极限</li><li>在读操作时，position会置为0,limit表示最多能读到的位置<h2 id="Buffer的操作"><a href="#Buffer的操作" class="headerlink" title="Buffer的操作"></a>Buffer的操作</h2><h3 id="存取数据"><a href="#存取数据" class="headerlink" title="存取数据"></a>存取数据</h3><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hb是字节数组的实体，ix函数用于计算偏移</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回下标</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调整指针位置的方法"><a href="#调整指针位置的方法" class="headerlink" title="调整指针位置的方法"></a>调整指针位置的方法</h3><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查参数正确性</span></span><br><span class="line">    <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//设定新参数</span></span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="comment">//如果标记在修改的位置之后则重置标记</span></span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="filp-读写转换"><a href="#filp-读写转换" class="headerlink" title="filp 读写转换"></a>filp 读写转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，连续调用flip就会使得buffer的limit变成0，既不能读也不能写</p><h4 id="mark与reset"><a href="#mark与reset" class="headerlink" title="mark与reset"></a>mark与reset</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他功能实现"><a href="#其他功能实现" class="headerlink" title="其他功能实现"></a>其他功能实现</h3><p>方法在Buffer抽象类中</p><h4 id="clear-恢复到写模式，重新写"><a href="#clear-恢复到写模式，重新写" class="headerlink" title="clear 恢复到写模式，重新写"></a>clear 恢复到写模式，重新写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rewind-重绕-不修改limit的值"><a href="#rewind-重绕-不修改limit的值" class="headerlink" title="rewind 重绕-不修改limit的值"></a>rewind 重绕-不修改limit的值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remaining"><a href="#remaining" class="headerlink" title="remaining"></a>remaining</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到缓冲区剩下的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit - position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isRemaining"><a href="#isRemaining" class="headerlink" title="isRemaining"></a>isRemaining</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>简而言之，分配一块Java不老动的内存区域，当在保存大量的数据我们只是用于IO操作或者说暂时不去处理的时候，GC操作的到来将这么大一块区域搬来搬去，是很耗时而没有意义的，当然，解决的方式就是分配一块堆外内存，这块区域JVM对其进行引用计数，如果没有引用了才进行回收</p><h2 id="Zero-Copy-0拷贝"><a href="#Zero-Copy-0拷贝" class="headerlink" title="Zero-Copy 0拷贝"></a>Zero-Copy 0拷贝</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6异步编程</title>
      <link href="/2018/10/06/js-08/"/>
      <url>/2018/10/06/js-08/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ucore Lab1</title>
      <link href="/2018/10/03/ucore-Lab1/"/>
      <url>/2018/10/03/ucore-Lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统实验报告"><a href="#操作系统实验报告" class="headerlink" title="操作系统实验报告"></a>操作系统实验报告</h1><a id="more"></a><h2 id="实验1-bootloader的启动"><a href="#实验1-bootloader的启动" class="headerlink" title="实验1: bootloader的启动"></a>实验1: bootloader的启动</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p>要求：</p><ol><li>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</li><li>一个被认为是符合规范的硬盘主引导扇区的特征是什么？<br>实验过程:</li><li><p>在构建过程中使用<code>make V=</code>来查看具体执行过程，具体执行过程如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下均为将各个文件编译为目标文件</span></span><br><span class="line">+ cc kern/init/init.c  //编译 init.c</span><br><span class="line">+ kern/libs/readline.c //编译 readline.c</span><br><span class="line">+ cc kern/libs/stdio.c //编译 stdio.c</span><br><span class="line">+ cc kern/debug/kdebug.c//编译 kdebug.c </span><br><span class="line">+ cc kern/debug/kmonitor.c //编译 kmonitor</span><br><span class="line">+ cc kern/debug/panic.c//编译 panic.c</span><br><span class="line">+ cc kern/driver/clock.c //编译 clock.c</span><br><span class="line">+ cc kern/driver/console.c //编译 console.c</span><br><span class="line">+ cc kern/driver/intr.c//编译 intr.c</span><br><span class="line">+ cc kern/driver/picirq.c //编译 picirq.c</span><br><span class="line">+ cc kern/<span class="built_in">trap</span>/trap.c //编译 trap.c</span><br><span class="line">+ cc kern/<span class="built_in">trap</span>/trapentry.S //编译 trapentry.S</span><br><span class="line">+ cc kern/<span class="built_in">trap</span>/vectors.S //编译 vector.S</span><br><span class="line">+ cc kern/mm/pmm.c//编译 pmm.c</span><br><span class="line">+ cc libs/printfmt.c // printgmt.c</span><br><span class="line">+ cc libs/string.c //编译 string.c</span><br><span class="line">+ ld bin/kernel//接下来用ld合并目标文件(object) 和 库文件(archive),生成kernel程序</span><br><span class="line">+ cc boot/bootasm.S //编译 bootasm.S</span><br><span class="line">+ cc boot/bootmain.c //编译 bootmain.c</span><br><span class="line">+ cc tools/sign.c //编译 sign.c</span><br><span class="line"><span class="comment"># 以上执行过程均附加了gcc参数如下,以第一行init.c为例</span></span><br><span class="line">gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br><span class="line"><span class="comment"># gcc -I 指明包含路径名称 -fno-builtin表明不使用内建函数 -Wall开启所有警告  -ggdb生成GDB调试信息 -gstabs此选项以stabs格式声称调试信息,但是不包括gdb调试信息，-m32生成32位机器的汇编代码 -nostdincgcc编译的时候不要在标准系统目录中找头文件 -fnostack-protector 不启用溢出检测机制 </span></span><br><span class="line">+ ld bin/bootblock //链接生成block文件</span><br><span class="line">//最后将bootloader放入虚拟硬盘ucore.img中去。</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line">dd <span class="keyword">if</span>=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line">dd <span class="keyword">if</span>=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br><span class="line"><span class="comment"># 这里用到了dd命令，if是输入of是输出count是块大小，关于conv参数可以参考 https://www.cnblogs.com/dkblog/archive/2009/09/18/1980715.html  https://blog.csdn.net/u011616400/article/details/41575745 ,其作用睡觉哦不截断输出文件</span></span><br></pre></td></tr></table></figure></li><li><p>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</p></li></ol><p>查看tools/sign.c文件如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="comment">//检查输入参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: &lt;input filename&gt; &lt;output filename&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//stat函数传入文件名和结构体对象可以返回一个结构体信息，检测是否是吧</span></span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error opening file '%s': %s\n"</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"'%s' size: %lld bytes\n"</span>, argv[<span class="number">1</span>], (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">    <span class="comment">//检测是否超过510个字节</span></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%lld &gt;&gt; 510!!\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立缓冲区，将缓冲区置0</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">//读取文件，填充缓冲区</span></span><br><span class="line">    FILE *ifp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">int</span> size = fread(buf, <span class="number">1</span>, st.st_size, ifp);</span><br><span class="line">    <span class="comment">//判断文件大小是否如文件信息所述</span></span><br><span class="line">    <span class="keyword">if</span> (size != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read '%s' error, size is %d.\n"</span>, argv[<span class="number">1</span>], size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭流</span></span><br><span class="line">    fclose(ifp);</span><br><span class="line">    <span class="comment">//写入标识</span></span><br><span class="line">    buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line">    buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="comment">//打开新文件，写出</span></span><br><span class="line">    FILE *ofp = fopen(argv[<span class="number">2</span>], <span class="string">"wb+"</span>);</span><br><span class="line">    size = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp);</span><br><span class="line">    <span class="comment">//再次检测大小是否符合要求</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"write '%s' error, size is %d.\n"</span>, argv[<span class="number">2</span>], size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"build 512 bytes boot sector: '%s' success!\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><p>要求：<br>使用qemu执行并调试lab1中的软件。（要求在报告中简要写出练习过程）</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">V=@</span><br><span class="line">BINDIR=bin</span><br><span class="line"><span class="section">lab1-mon: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line"><span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">"<span class="variable">$(QEMU)</span> -S -s -d in_asm -D <span class="variable">$(BINDIR)</span>/q.log -monitor stdio -hda <span class="variable">$&lt;</span> -serial null"</span></span><br><span class="line"><span class="variable">$(V)</span>sleep 2</span><br><span class="line"><span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">"gdb -q -x tools/lab1init"</span></span><br></pre></td></tr></table></figure><p>第一行参数表</p><ul><li>-S 在启动时不启动 CPU， 需要在 monitor 中输入 ‘c’，才能让qemu继续模拟工作</li><li>-s 等待gdb连接到端口1234</li><li>-d 输出日志到 qemu</li><li>-hda 指明使用file作为硬盘0镜像</li><li>-serial dev 重定向虚拟串口到主机设备dev中</li></ul><p>第三行参数表</p><ul><li>-x 指明预设命令文件,预设文件如下<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file bin/kernel #加载符号信息 </span><br><span class="line">target remote :1234 #与qemu进行链接</span><br><span class="line">set architecture i8086 #设置处理器架构</span><br><span class="line">b *0x7c00 #在0x7c00设置断点</span><br><span class="line">continue #继续</span><br><span class="line">x /2i $pc #显示PC之后的两条指令</span><br></pre></td></tr></table></figure></li></ul><p>使用GDB命令完成以下工作:</p><ol><li>查看PC之后的10行命令<code>x/10i $pc</code></li><li>查看具体位置的内存数据<code>x/</code></li><li>查看GDTR寄存器的值</li><li>断点<code>b *0x7c0a</code></li><li>打印所有寄存器<code>info register</code>，也可以是<code>i r</code></li><li>在开启保护模式后设置架构<code>set architecture i386</code></li><li>单步源代码的下一行，不进入函数<code>next</code></li><li>单步一条机器指令，不进入函数<code>nexti</code></li><li>单步到下一个不同的源代码行,进入函数<code>step</code></li><li>单步到一条机器指令，进入函数<code>stepi</code><h4 id="从CPU加电执行的第一条指令开始，单步跟踪BIOS的执行"><a href="#从CPU加电执行的第一条指令开始，单步跟踪BIOS的执行" class="headerlink" title="从CPU加电执行的第一条指令开始，单步跟踪BIOS的执行"></a>从CPU加电执行的第一条指令开始，单步跟踪BIOS的执行</h4>由于开机时处于实模式，开机的时候CS:IP=0xf000:fff0因此应该查看这里的指令</li></ol><p><img src="1.png" alt="输出"></p><p>之后执行一系列BIOS操作最够将控制权转交给0x7c00的bootloader部分</p><h3 id="练习3-分析bootloader进入保护模式的过程"><a href="#练习3-分析bootloader进入保护模式的过程" class="headerlink" title="练习3 分析bootloader进入保护模式的过程"></a>练习3 分析bootloader进入保护模式的过程</h3><h4 id="步骤-关键步骤前加"><a href="#步骤-关键步骤前加" class="headerlink" title="步骤(关键步骤前加*)"></a>步骤(关键步骤前加*)</h4><ol start="0"><li>准备基本的GDT表项以供使用进入保护模式之后使用</li><li>初始化寄存器</li><li>*检测并发送A20开启信号来开启A20</li><li>*通过修改CR0寄存器的保护模式使能位进入保护模式</li><li>*用保护模式的寻址机制跳转到初始化保护寄存器的代码段(protcseg)长跳转指令进入</li><li>*初始化堆栈部分一便于C语言程序的调用堆栈区域是从0–start(0x7c00)<h4 id="代码阅读"><a href="#代码阅读" class="headerlink" title="代码阅读"></a>代码阅读</h4><a href="https://github.com/PickDream/OSPratice/blob/master/uCore/sourcecode/boot/bootasm.S" target="_blank" rel="noopener">代码注释</a><h3 id="练习4：分析bootloader加载ELF格式的OS的过程。"><a href="#练习4：分析bootloader加载ELF格式的OS的过程。" class="headerlink" title="练习4：分析bootloader加载ELF格式的OS的过程。"></a>练习4：分析bootloader加载ELF格式的OS的过程。</h3>bootloader在前面可以看到，分为两部分，一部分是汇编代码写的，主要完成进入保护模式并初始化寄存器，第二部分是C代码写的，主要完成加载ELF格式的内核文件到内存中，这里就涉及到原生的C并不能完成的任务，例如读取硬盘扇区，在这里使用的是GCC内联汇编来完成基本功能被C代码使用的。<h4 id="读取硬盘部分"><a href="#读取硬盘部分" class="headerlink" title="读取硬盘部分"></a>读取硬盘部分</h4>读取扇区(readsect)的操作可以分为如下几部分</li><li>等待磁盘准备好       (<code>whitdisk(void)</code>)</li><li>发出读取磁盘的命令   (向硬盘的IO端口输出读取信息)</li><li>等待磁盘准备好       (<code>whitdisk(void)</code>)</li><li>将磁盘扇区的数据读到指定的内存中去<blockquote><p>0号磁盘的IO端口详细信息:<br>1F0H 0号硬盘数据寄存器<br>1F1H 0号硬盘错误寄存器(读时),0号硬盘Features寄存器(写时)<br>1F2H 0号硬盘数据扇区计数<br>1F3H 0号硬盘扇区数<br>1F4H 0号硬盘柱面(低字节)<br>1F5H 0号硬盘柱面(高字节)<br>1F6H 0号磁盘驱动器/磁头寄存器<br>1F7H 0号硬盘状态寄存器(读时)，0号硬盘命令寄存器(写时)</p></blockquote></li></ol><p><a href="https://github.com/PickDream/OSPratice/blob/master/uCore/sourcecode/boot/bootmain.c" target="_blank" rel="noopener">读取硬盘的详细阅读代码注释</a></p><h4 id="装载ELF格式内核"><a href="#装载ELF格式内核" class="headerlink" title="装载ELF格式内核"></a>装载ELF格式内核</h4><p><img src="Elf-layout.svg" alt="ELF布局"><br>在这里需要简单的了解ELF文件布局如下</p><p><img src="ELF.png" alt="ELF部分功能"></p><p>使用<code>objdump -h</code>查看ELF文件信息，可以查看在相关节的信息<br><img src="objdump.png" alt="objdumo查看信息"></p><ul><li>链接地址(Virtual Memory Address)和加载地址(Load Memory Address):程序在链接的时候会确定链接地址，这个地址是逻辑上的，代码中绝对的跳转都按照此基准进行，而加载地址是事实加载的地址。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bootmain - bootloader的入口 */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// 将文件的前4KB读取内存</span></span><br><span class="line">    readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测加载进内存的内核模块是否是ELF文件</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;  </span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过结构体的偏移找到程序头表的入口，并加载程序段(ignores ph flags)</span></span><br><span class="line">    ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    <span class="comment">// 通过指针的偏移,找到程序头表结束的地址</span></span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="comment">//开始对程序头表包含的具体的信息进行遍历处理</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        <span class="comment">//用readreg这个函数将文件的每一个段都读到内存中由程序头表的相应位置</span></span><br><span class="line">        <span class="comment">//由于kernel 程序的链接地址太高，而实际内存没有那么大的情况下，实际地址就是&amp;0xFFFFFF的结果(Mark，这个还不是太懂)</span></span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用elf文件格式指明的程序入口点地址，转交控制权</span></span><br><span class="line">    <span class="comment">// note: 不会返回</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*加载失败跳转到这里*/</span></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 无限循环 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现函数调用堆栈跟踪函数-（需要编程）"><a href="#实现函数调用堆栈跟踪函数-（需要编程）" class="headerlink" title="实现函数调用堆栈跟踪函数 （需要编程）"></a>实现函数调用堆栈跟踪函数 （需要编程）</h4><p>一个函数调用的大致步骤分为以下阶段，由于调用约定多样，这里只总结大致步骤</p><ol><li>参数的传入，可以push参数，也可以传入具体的寄存器</li><li><code>call</code> 将返回地址压入堆栈中，ESP-4(32位)，此时ESP指向的是保存返回值的地址</li><li><code>push %ebp</code> 将上一个堆栈的栈底指针传入，ESP再次-4</li><li><code>mov %esp,%ebp</code> 设置新的栈底</li><li>提升栈空间，用于函数操作</li><li>保护现场，具体是保存将要修改的寄存器</li><li>其他初始化工作</li><li>执行函数核心内容</li><li>恢复现场</li><li><code>pop %ebp</code> 恢复堆栈</li><li><code>ret</code><br>依据上述过程易得：</li></ol><ul><li>如果函数传入参数是通过在call之前压入参数来做到了，那么其参数地址是ebp+8+4*(n+1),n=1,2,3…</li><li>函数的返回地址是ebp+4</li><li>ebp指示的位置是上一个函数调用esp的位置，ebp内保存的内容是原来ebp的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ECMAScript 6</title>
      <link href="/2018/09/27/js-07/"/>
      <url>/2018/09/27/js-07/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="历史与概念"><a href="#历史与概念" class="headerlink" title="历史与概念"></a>历史与概念</h2><h3 id="Evergreen-Browsers"><a href="#Evergreen-Browsers" class="headerlink" title="Evergreen Browsers"></a>Evergreen Browsers</h3><p>长期浏览器，支持最新标准</p><ul><li>Microsoft Edge</li><li>Firefox</li><li>Chrome</li><li>Opera</li><li>Safari<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3></li><li>node  </li><li>npm js的包管理工具</li><li>babel 针对ES标准的转译器，将新版本的语法转换为老版本<h3 id="shim-amp-polyfill"><a href="#shim-amp-polyfill" class="headerlink" title="shim&amp;polyfill"></a>shim&amp;polyfill</h3></li><li>提供API来在旧的基础之上支持类似的新标准的功能</li><li>polyfill 更贴近标准，扩展原生对象来提供几乎一样的新标准支持<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h3></li></ul><ol><li>let和const不可以重复声明</li><li><p>let和const都在块级作用域有效</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">return</span> a*<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">(a)=&gt;&#123;<span class="keyword">return</span> a*<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">(a)=&gt;a*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">a =&gt; a*<span class="number">2</span></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//返回对象，注意｛｝的语义可能冲突</span></span><br><span class="line"><span class="keyword">const</span> funObj = <span class="function"><span class="params">name</span> =&gt;</span>&#123;&#123;name,<span class="attr">age</span>:<span class="number">27</span>&#125;&#125;</span><br><span class="line"><span class="comment">//不能作为构造函数</span></span><br><span class="line"><span class="keyword">const</span> A =<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> A()</span><br><span class="line"><span class="comment">//this指向问题</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="keyword">this</span>.c);</span><br><span class="line">    &#125;,</span><br><span class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="keyword">this</span>.c)</span><br><span class="line">    &#125;</span><br><span class="line">    c:<span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.a();<span class="comment">//undefined</span></span><br><span class="line">obj.b();<span class="comment">//123</span></span><br></pre></td></tr></table></figure></li><li><p>箭头函数只能替换函数表达式，不能替换函数声明，因为它是匿名的</p></li><li>不能赋值常量作为构造函数</li><li>this指向是在定义时决定的而不是之前普通函数调用时定义的，this取决于父执行上下文的this<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">moduleMethod</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//module</span></span><br><span class="line"><span class="keyword">import</span> method form <span class="string">'./moduleA'</span></span><br><span class="line">method();</span><br></pre></td></tr></table></figure><p>引入多个函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module A</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">methodA</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">methodB</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//module B</span></span><br><span class="line"><span class="keyword">import</span> &#123;methodA,methodB&#125; <span class="keyword">from</span> <span class="string">'./moduleA'</span></span><br><span class="line">methodA()</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> util <span class="keyword">from</span> <span class="string">"./moduleA"</span></span><br><span class="line">util.methodA()</span><br></pre></td></tr></table></figure></p><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>ES5中的方法推荐挂载到原型中，在ES6可以直接申明<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options = options ||&#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.name = options.name ||<span class="string">'stefan'</span></span><br><span class="line">&#125;</span><br><span class="line">Teacher.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher1</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"stefan"</span></span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> teacher1 = <span class="keyword">new</span> Teacher1();</span><br></pre></td></tr></table></figure></p><p>深入理解类<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.info(<span class="keyword">typeof</span> Teacher1)<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.info(Teacher1.prototype.constructor==Teacher1)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.assign(Teacher1.prototype,&#123;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//区别</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">Object</span>.keys(Teacher.prototype));<span class="comment">//['getName']</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">Object</span>.keys(Teacher1.prototype))<span class="comment">//[]</span></span><br><span class="line"><span class="comment">//说明ES6是不可枚举的</span></span><br></pre></td></tr></table></figure></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>extends关键字<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PangTeacher</span> <span class="keyword">extends</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args)&#123;</span><br><span class="line">        <span class="comment">//子类没有自己的this对象，通过继承父类的this对象进行扩充的</span></span><br><span class="line">        <span class="keyword">super</span>(...args);</span><br><span class="line">        <span class="keyword">this</span>.weight = <span class="number">180</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> PangTeacher();</span><br></pre></td></tr></table></figure></p><h2 id="ES6高级特性"><a href="#ES6高级特性" class="headerlink" title="ES6高级特性"></a>ES6高级特性</h2><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>解构赋值(Destructuring Assignment)，学习Python<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.info(a,b,c);<span class="comment">//1 2 3</span></span><br><span class="line"><span class="keyword">var</span>[a,,b]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.info(a,b)<span class="comment">//1 3</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;a,b&#125;= o;</span><br><span class="line"><span class="built_in">console</span>.info(a,b);<span class="comment">//1.2</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;b,a&#125;=o;</span><br><span class="line"><span class="built_in">console</span>.info(a,b);<span class="comment">//1,2</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">&#123;a,b,c&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.info(test(&#123;<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>,<span class="attr">c</span>:<span class="number">1</span>&#125;))</span><br></pre></td></tr></table></figure></p><p>解构赋值很方便的将声明和传参结合在了一起</p><h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3><ul><li>Spread Elements &amp; Properties<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> spread = [<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> n = [x,y,...spread];</span><br><span class="line"><span class="built_in">console</span>.log(n)<span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> spread = &#123;<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123;x,y,...spread&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(n);<span class="comment">//&#123;x:1,y:2,a:3,b:4&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spreadFunc</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(a+b+c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">spreadFunc(...args)</span><br></pre></td></tr></table></figure><ul><li>Rest Element &amp; Properties<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,...rest] = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="built_in">console</span>.log(rest)<span class="comment">//[30,40,50]</span></span><br><span class="line"><span class="comment">//-----------------</span></span><br><span class="line"><span class="keyword">let</span>&#123;x,y,..rest&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br><span class="line"><span class="built_in">console</span>.log(rest);<span class="comment">//&#123;a:3,b:4&#125;</span></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restFunc</span>(<span class="params">a,...args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><p>针对字符串拼接<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'stefan'</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'My name is'</span>+ name+<span class="string">'.'</span>);</span><br><span class="line"><span class="comment">//这里第一个\是转义，最后一个\是换行链接字符串</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'My name is'</span>+ name+<span class="string">'.\n\</span></span><br><span class="line"><span class="string">I love this world'</span>)</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>.`</span>);</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>。</span></span><br><span class="line"><span class="string">I love this world.`</span>);</span><br></pre></td></tr></table></figure></p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.info(<span class="built_in">Symbol</span>(<span class="string">'a'</span>)==<span class="built_in">Symbol</span>(<span class="string">'a'</span>))<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="Map-amp-Set"><a href="#Map-amp-Set" class="headerlink" title="Map&amp;Set"></a>Map&amp;Set</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.info([...set])<span class="comment">//[1,2,3,4]</span></span><br><span class="line">set.add(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.info([...set])<span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'a'</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="string">'b'</span>,<span class="number">2</span>]</span><br><span class="line">])</span><br><span class="line"><span class="built_in">console</span>.info(a.get(<span class="string">'a'</span>),a.get(<span class="string">'b'</span>));</span><br><span class="line">a.set(<span class="string">'c'</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="Generator-amp-Iterator"><a href="#Generator-amp-Iterator" class="headerlink" title="Generator &amp; Iterator"></a>Generator &amp; Iterator</h3><p>Generator 函数是一个状态机，封装了多个内部状态<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用function* 标明是一个Generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//进行求斐波那契数列的迭代</span></span><br><span class="line">        [v1,v2] = [v2,v1+v2];</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">let</span> reset = <span class="keyword">yield</span> v1;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(reset)&#123;</span><br><span class="line">            v1 = <span class="number">0</span>;</span><br><span class="line">            v2 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用迭代器函数，返回一个对象，带有next方法</span></span><br><span class="line"><span class="keyword">let</span> a = fibonacci();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a)</span><br><span class="line"><span class="comment">//调用对象的next方法返回一个对象带有value属性和done属性,next语义会生成下一个值</span></span><br><span class="line"><span class="comment">//value属性代表的是每次执行到yield的状态值</span></span><br><span class="line"><span class="comment">//down属性代表的是迭代是否结束</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'1'</span>,a.next());</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'1111'</span>,a.next());</span><br><span class="line"><span class="comment">//如果不取值，就不会生产值</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'2'</span>,a.next().value);</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'3'</span>,a.next().value);</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'4'</span>,a.next().value);</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'5'</span>,a.next().value);</span><br><span class="line"><span class="comment">//next传入的值会返回到yield 执行之后的返回值</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'6'</span>,a.next(<span class="literal">true</span>).value);</span><br></pre></td></tr></table></figure></p><p>迭代器<br>迭代器希望提供一致的迭代方式，那么对于不同对象，我们需要指明的是</p><ul><li>迭代的下一个对象是什么？</li><li><p>迭代什么时候结束<br>正是因为有了迭代器，ES6可以使用统一的访问机制for …of循环来遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        next:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex&lt;array.length?</span><br><span class="line">            &#123;<span class="attr">value</span>:array[nextIndex++],<span class="attr">done</span>:<span class="literal">false</span>&#125;:</span><br><span class="line">            &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(it.next())<span class="comment">//&#123; value: 'a', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())<span class="comment">//&#123; value: 'b', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())<span class="comment">//&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>一种数据结构只要部署了Iterator接口，我们就称为这种数据结构是”可遍历的”</p></li><li>一个数据几个只要具有Symbol.iterator属性，就认为是”可遍历的”(iterable)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">//实现接口</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]:<span class="function"><span class="params">()</span>=&gt;</span>(&#123;</span><br><span class="line">        next:<span class="function"><span class="params">()</span>=&gt;</span>(&#123;</span><br><span class="line">            value:<span class="number">1</span>,</span><br><span class="line">            done:counter++&gt;<span class="number">3</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'obj'</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>与Generator函数除了状态机，还是一个便利器对象的生成函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OddDouble</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(list)&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    *[Symble.iterator]()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.list)&#123;</span><br><span class="line">            <span class="keyword">yield</span> item%<span class="number">2</span>?item*<span class="number">2</span>:item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> <span class="keyword">new</span> OddDouble([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象的JavaScript</title>
      <link href="/2018/09/26/js-6/"/>
      <url>/2018/09/26/js-6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="定义对象属性"><a href="#定义对象属性" class="headerlink" title="定义对象属性"></a>定义对象属性</h2><h3 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.a = <span class="number">1</span>;</span><br><span class="line">person[<span class="string">"a"</span>]=<span class="number">1</span>;</span><br><span class="line">person = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="高级方法"><a href="#高级方法" class="headerlink" title="高级方法"></a>高级方法</h3><p>需要明确一下几个概念：</p><ul><li><p>数据属性:</p><ul><li>Configurable:表示能否通过delete属性而重新定义属性</li><li>enumerable:表示能否通过foreach循环来获得属性</li><li>writable:表名属性是否可以修改</li><li>value: 定义初始值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    value:<span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.info(person.name);</span><br><span class="line">person.name = <span class="string">"Greg"</span>;</span><br><span class="line"><span class="built_in">console</span>.info(person.name);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>访问器属性:</p><ul><li>访问器属性相比于数据属性没有writable和value，新增了get和set属性,一般对私有属性进行get/set方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year:<span class="number">2004</span>,</span><br><span class="line">    edition:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition+=newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>创建私有的访问器属性之后设置具体的值经过get/set方法为数据的访问增加了一个中间层，在中间层内部增加类似监听器的东西可以实现“观察者模式”,例如MVVM框架所能做到的对对象属性的修改能及时反馈到对应的界面上。</p><h3 id="创建对象-工厂模式"><a href="#创建对象-工厂模式" class="headerlink" title="创建对象-工厂模式"></a>创建对象-工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建对象-构造函数"><a href="#创建对象-构造函数" class="headerlink" title="创建对象-构造函数"></a>创建对象-构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure><ul><li>new 构造函数的执行步骤<ul><li>在内存中创建一个对象</li><li>将作用域指向这个对象</li><li>执行构造函数的代码</li><li>将该对象的引用返回<h2 id="创建对象-原型模式"><a href="#创建对象-原型模式" class="headerlink" title="创建对象-原型模式"></a>创建对象-原型模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayhello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();<span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>首先prototype是一个指针，指向这个对象</p><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3><p>检测来自实例的属性，而不是来自原型</p><h3 id="delete-Person1-name"><a href="#delete-Person1-name" class="headerlink" title="delete Person1.name"></a>delete Person1.name</h3><p>删除实例属性</p><h3 id="in-关键字"><a href="#in-关键字" class="headerlink" title="in 关键字"></a>in 关键字</h3><p>判断原型和实例中是否有</p><h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p>遍历时无差别对待原型属性和实例属性</p><h3 id="认识构造函数和原型的问题"><a href="#认识构造函数和原型的问题" class="headerlink" title="认识构造函数和原型的问题"></a>认识构造函数和原型的问题</h3><ul><li>首先，构造函数每次执行相当于创建一个全新的对象，每一个实例都有自己的属性和方法，这样在效率上消耗太高</li><li>原型的缺点在于如果修改了一个属性值，其他所有属性值都变了。<h3 id="创建对象-组合"><a href="#创建对象-组合" class="headerlink" title="创建对象-组合"></a>创建对象-组合</h3>将属性值放到实例属性中，将方法写到原型中去。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"shelby"</span>,<span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义SuperType的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Supertype的原型方法</span></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.proprety;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义子类的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指明继承关系</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">//添加子类方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重写父类方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义子类的原型方法</span></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.info(instance2.colors);<span class="comment">//[ 'red', 'blue', 'green', 'black' ]</span></span><br></pre></td></tr></table></figure><p>发现一个问题，通过原型链继承的数据对象是在原型中的，这个会最大的问题就是数据成员的共享，当然在特定的条件下可以利用该特点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承独立的数据成员的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//将构造函数的数据成员强制绑定到本地</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.info(instance1.colors)<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.info(instance2.colors)</span><br></pre></td></tr></table></figure></p><h2 id="两种方法的折中，组合继承"><a href="#两种方法的折中，组合继承" class="headerlink" title="两种方法的折中，组合继承"></a>两种方法的折中，组合继承</h2><ul><li>将想要继承的独立的数据成员使用构造函数继承方式</li><li>将函数成员或者共享的数据成员使用原型链继承<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//设置继承父类的数据成员作为自己的独立的</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>,name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以说下面的三行代码都是完善继承关系的步骤</span></span><br><span class="line"><span class="comment">//指明prototype是从supertype()，使得subType具有了继承的层次,但是这里父类中有冗余的字段,优化步骤写在[2]中</span></span><br><span class="line"><span class="comment">//[1]</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">//[2]上面代码的优化版本，通过定义空方法来</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">F.prototype = SuperType.prototype;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> F();</span><br><span class="line"><span class="comment">//添加SuperType的构造函数为Subtype</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"><span class="comment">//再添加函数成员到原型中</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>,<span class="number">29</span>);</span><br><span class="line">instance1.color.push(<span class="string">"black"</span>)</span><br><span class="line"><span class="built_in">console</span>.info(instance1.colors)</span><br><span class="line">instance1.sayName();</span><br><span class="line">instance1.sayAge();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>,<span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.info(instance1.colors)</span><br><span class="line">instance1.sayName();</span><br><span class="line">instance1.sayAge();</span><br></pre></td></tr></table></figure></li></ul><h2 id="JavaScript语言的二义性"><a href="#JavaScript语言的二义性" class="headerlink" title="JavaScript语言的二义性"></a>JavaScript语言的二义性</h2><p>动态的语言许多看似简单的东西有丰富的用法，这个需要注意，这也往往是其坑所在</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSON与AJAX和跨域通信</title>
      <link href="/2018/09/25/Server-01/"/>
      <url>/2018/09/25/Server-01/</url>
      
        <content type="html"><![CDATA[<h2 id="JSON表示值的类型"><a href="#JSON表示值的类型" class="headerlink" title="JSON表示值的类型"></a>JSON表示值的类型</h2><ul><li><strong>不能</strong>表示<code>Undefined</code></li><li><code>Null</code>,<code>Boolean</code>,<code>number</code>,<code>String</code></li><li>对象</li><li>数组<h2 id="JSON-规范"><a href="#JSON-规范" class="headerlink" title="JSON 规范"></a>JSON 规范</h2></li><li>JSON是一种规范，是一种组织数据的格式</li><li>JSON字符串不能用单引号</li><li>JSON的属性必须是一个字符串表示<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wrong in json, but right in javascript</span></span><br><span class="line">&#123;</span><br><span class="line">    name:<span class="string">"Maoxin"</span>,</span><br><span class="line">    age:<span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//right in json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"Maoxin"</span>,</span><br><span class="line">    <span class="string">"age"</span>:<span class="number">29</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="JSON-序列化"><a href="#JSON-序列化" class="headerlink" title="JSON 序列化"></a>JSON 序列化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javascript object -&gt; JSON String</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    title:<span class="string">"C++ Learn"</span>,</span><br><span class="line">    authors:[</span><br><span class="line">        <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">    ],</span><br><span class="line">    year:<span class="number">2011</span>,</span><br><span class="line">    edition:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book)</span><br><span class="line"><span class="comment">//get attributes which we need to stringify</span></span><br><span class="line"><span class="keyword">var</span> need = <span class="built_in">JSON</span>.stringfy(book,[<span class="string">"title"</span>,<span class="string">"edition"</span>])</span><br><span class="line"><span class="comment">//&#123;"title":"C++ Learn","edition":3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//execute function according to attribute</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"authors"</span>:</span><br><span class="line">            <span class="keyword">return</span> value.join(<span class="string">","</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"year"</span>:</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"edition"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//deliver the number of space to get a formated string</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book,<span class="literal">null</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><ul><li>可以在对象中添加<code>toJSON</code>的属性来控制格式化那些东西<h2 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    title:<span class="string">"Javascript"</span>,</span><br><span class="line">    releaseDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>,<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book)</span><br><span class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key==<span class="string">"releaseDate"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="XMLHttpRequest-基本"><a href="#XMLHttpRequest-基本" class="headerlink" title="XMLHttpRequest 基本"></a>XMLHttpRequest 基本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 第三个参数是是否是异步的</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"example.php"</span>,<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//注意调用的时候，不会真正的指向请求，而是准备发送，用send发送</span></span><br><span class="line"><span class="comment">//如果是GET请求，将body设置为null即可</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="XMLHttpRequest-填充属性"><a href="#XMLHttpRequest-填充属性" class="headerlink" title="XMLHttpRequest - 填充属性"></a>XMLHttpRequest - 填充属性</h3><ul><li>responseText<br>如果返回的是文本将返回结果挂载在这里</li><li>responseXML 返回的是XML</li><li>status 状态码&gt;=200时候代表能够正确返回，当status=304通知浏览器本地缓存还可以使用</li><li>statusText</li></ul><p>以下为同步情况：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步情况</span></span><br><span class="line"><span class="keyword">if</span>((chr.status&gt;=<span class="number">200</span>&amp;&amp;chr.status&lt;<span class="number">300</span>)||xhr.status==<span class="number">304</span>)&#123;</span><br><span class="line">    alert(xhr.responseText);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">"error info: "</span>+xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下为异步情况：采用注册事件的方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在open和send之前</span></span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((chr.status&gt;=<span class="number">200</span>&amp;&amp;chr.status&lt;<span class="number">300</span>)||xhr.status==<span class="number">304</span>)&#123;</span><br><span class="line">    alert(xhr.responseText);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">"error info: "</span>+xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里需要明确<code>readState</code>的变化过程</p><ul><li>0 未初始化</li><li>1 启动</li><li>2 发送</li><li>3 接收</li><li>4 完成<h3 id="abort-终止"><a href="#abort-终止" class="headerlink" title="abort 终止"></a>abort 终止</h3>使请求提前终止<h3 id="AJAX-XMLHttpRequest-Header"><a href="#AJAX-XMLHttpRequest-Header" class="headerlink" title="AJAX XMLHttpRequest Header"></a>AJAX XMLHttpRequest Header</h3></li><li>Accept: 浏览器能处理的内容类型</li><li>Accept-Charset：浏览器能显示的字符串</li><li>Accept-Encoding: 浏览器能够处理的压缩编码</li><li>Accept-Language:浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间的连接的类型</li><li>Cookie:不解释</li><li>Host:发出请求页面所在的域</li><li>Referer:发送请求的页面URL，注意这个词是拼写错了，将错就错,referrer是正确的</li><li>User-Agent：浏览器用户代理字符串<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"MyHeader"</span>,<span class="string">"MyValue"</span>)</span><br><span class="line"><span class="comment">//Demo 模拟表单发送</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"user-info"</span>);</span><br><span class="line">xhr.send(serialize(form));</span><br></pre></td></tr></table></figure></li></ul><h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line">xhr.send(serialize(form));</span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"user-info"</span>);</span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData(form);</span><br><span class="line">formData.append(<span class="string">"name"</span>,<span class="string">"Maoxin"</span>);</span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure><h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><ul><li><code>onload</code> 响应完成触发</li><li><code>onprocess</code> 接受过程中触发的事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> divStatus = <span class="built_in">document</span>.getElementById(<span class="string">"status"</span>);</span><br><span class="line">    <span class="keyword">if</span>(event.lengthComputable)&#123;</span><br><span class="line">        divStatus.innerHTML = <span class="string">"Received"</span> +event.position+<span class="string">"of"</span>+event.totalSize+<span class="string">"bytes"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="跨域通信"><a href="#跨域通信" class="headerlink" title="跨域通信"></a>跨域通信</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Server杂项 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蛋疼的JavaScript(五)引用类型</title>
      <link href="/2018/09/23/js-5/"/>
      <url>/2018/09/23/js-5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="配置式构造对象"><a href="#配置式构造对象" class="headerlink" title="配置式构造对象"></a>配置式构造对象</h2><p>常用的传入参数在不能满足成员是动态的时候的情况<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setObject</span>(<span class="params">name,age,school</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        name:name,</span><br><span class="line">        age:age,</span><br><span class="line">        school:school</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以使用配置式的来满足动态需求<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setObject</span>(<span class="params">configure</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="列表的简单操作"><a href="#列表的简单操作" class="headerlink" title="列表的简单操作"></a>列表的简单操作</h2><h3 id="栈方法和队列方法"><a href="#栈方法和队列方法" class="headerlink" title="栈方法和队列方法"></a>栈方法和队列方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.push(<span class="number">4</span>);      <span class="comment">//4加入末尾</span></span><br><span class="line"><span class="built_in">console</span>.info(a)</span><br><span class="line">a.unshift(<span class="number">0</span>)    <span class="comment">//0加入队首</span></span><br><span class="line"><span class="built_in">console</span>.info(a)</span><br><span class="line">a.pop()         <span class="comment">//4从尾部弹出</span></span><br><span class="line"><span class="built_in">console</span>.info(a)</span><br><span class="line">a.shift()       <span class="comment">//0从队首弹出</span></span><br><span class="line"><span class="built_in">console</span>.info(a)</span><br><span class="line">a.unshift(<span class="number">7</span>)    <span class="comment">//7加入在首部</span></span><br><span class="line"><span class="built_in">console</span>.info(a)</span><br><span class="line">a.unshift(<span class="number">8</span>)    <span class="comment">//8加入到首部</span></span><br><span class="line"><span class="built_in">console</span>.info(a)</span><br><span class="line">a.shift()       <span class="comment">//从首部弹出</span></span><br><span class="line"><span class="built_in">console</span>.info(a)</span><br></pre></td></tr></table></figure><p>注意JavaScript不是说队列或者栈方法将整体看作一个队列，而是说通过以上方法来实现栈和队列的操作。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>倒置:reverse()</li><li>排序:sort()<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">prev,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prec - next;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li><p>foreach方法，传入两个参数，一个是元素的值，一个是下标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">obj,index</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(obj,index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>filter方法，传入一个参数，元素值，返回数组是经过过滤为true的新的数据集</p></li><li><p>map方法，map是将迭代的元素都经过一次操作，最终返回一个新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c*<span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.info(b)</span><br><span class="line"><span class="comment">//[2,4,6]</span></span><br></pre></td></tr></table></figure></li><li><p>reduce方法</p></li></ul><p>先上代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">c,d</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c+d;</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure></p><p>就这样完成了数组相加,首先reduce接受两个参数，一个是回调，这个回调负责将问题规模减小，第二个值是初始值，而回调接受两个参数，一个是初始值，一个是当前值，将初始值与当前值相加之后返回到作为初始值继续操作。下面的代码很容易猜到就是10<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">c,d</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c+d;</span><br><span class="line">&#125;,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure></p><p>下面这个利用reduce完成map方法的功能<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">c,d</span>)</span>&#123;</span><br><span class="line">    c.push(d*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><ul><li>函数命名在递归程序的耦合<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可见这个<code>callee</code>是在该函数中被调用的方法,<code>caller</code>是调用者的方法，注意在严格模式下无法访问</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>表征函数当前作用域，详情见之前的this总结</p><h3 id="call-amp-apply"><a href="#call-amp-apply" class="headerlink" title="call&amp;apply"></a>call&amp;apply</h3><p>其都是说让函数在特定的，apply和call的区别在于call传入的是单个参数，apply是传入的数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    result:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.result = (+a + +b);</span><br><span class="line">&#125;</span><br><span class="line">sum.call(o,<span class="string">'1'</span>,<span class="string">'2'</span>)</span><br><span class="line"><span class="built_in">console</span>.info(o.result);<span class="comment">//3</span></span><br><span class="line">sum.apply(o,[<span class="string">'1'</span>,<span class="string">'3'</span>])</span><br><span class="line"><span class="built_in">console</span>.info(o.result)<span class="comment">//4</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蛋疼的JavaScript(四) 语句与函数</title>
      <link href="/2018/09/19/JS-04/"/>
      <url>/2018/09/19/JS-04/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="JavaScript中的-的语意"><a href="#JavaScript中的-的语意" class="headerlink" title="JavaScript中的()的语意"></a>JavaScript中的<code>()</code>的语意</h3><ol><li>作为函数调用运算符</li><li>函数参数占位符号</li><li>强制运算符，返回结果</li></ol><p>只要以上明白了，下面就很好理解了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>由于函数是一个作用域块，所以能够做到变量的隐藏。</p><h3 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void()运算符"></a>void()运算符</h3><p>与()的第三个语意相反，是求值但是不返回</p><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul><li>在堆中的对象在函数参数传递的时候是传递指针的值，所以能够做到共享</li><li>但是如果在栈中的值得拷贝就需要注意没有修改原值。</li></ul><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><ul><li>在严格模式下(严格模式下在函数前使用<code>&quot;use strict&quot;;</code>) arguments与传入的形参是没有联系的，修改arguments下的值是不会反映到形参的变化的</li><li>在非严格模式下，有联系</li><li>JS没有函数重载，使用arguments可以模拟重载</li><li>arguments不是数组，想要转换为数组可以使用数组原型对应的方法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].slice.call(<span class="built_in">arguments</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蛋疼的JavaScript(三)数据类型&amp;运算符</title>
      <link href="/2018/09/18/js-03/"/>
      <url>/2018/09/18/js-03/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="typeof-探测类型"><a href="#typeof-探测类型" class="headerlink" title="typeof 探测类型"></a>typeof 探测类型</h2><ul><li>type探测的类型是基本的数据类型，对于对象，他分不清是哪种object（除了function）,也就是说它深入不到构造方法级别的类型检测，这也是与instanceof的区别</li><li><img src="1.png" alt="类型检测"></li><li>在控制台下有个好处可以很具体的看到返回的类型都是string的</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>从常见的几种转换入手：</p><ul><li>布尔类型的转换</li></ul><p><img src="2.png" alt="布尔类型转换"></p><ul><li>数字类型的强制类型转换</li></ul><p><img src="3.png" alt="整数类型转换"></p><p>注意其可以做数值的进制转换</p><ul><li>转换为字符串</li></ul><p><img src="4.png" alt="字符串类型转换"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="一元"><a href="#一元" class="headerlink" title="一元+"></a>一元+</h3><p>如果后面是字符串那么就变为数字</p><h3 id="快捷转换为字符串"><a href="#快捷转换为字符串" class="headerlink" title="快捷转换为字符串"></a>快捷转换为字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>+<span class="string">""</span>;</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符-布尔类型的强制转换"><a href="#逻辑运算符-布尔类型的强制转换" class="headerlink" title="逻辑运算符:布尔类型的强制转换"></a>逻辑运算符:布尔类型的强制转换</h3><ul><li><p>两个逻辑非可以将其他类型转换为布尔类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.info(!!<span class="string">""</span>)<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.info(!<span class="string">""</span>)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.info(![])<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.info(![<span class="number">1</span>])<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p>完成代码的精，利用短路特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="literal">true</span> &amp;&amp; (a=<span class="number">2</span>);<span class="comment">//加括号是运算符优先级的问题</span></span><br></pre></td></tr></table></figure></li><li><p>用于给一个默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认5分</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">score</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s || <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5_1</title>
      <link href="/2018/09/18/HTML5-1/"/>
      <url>/2018/09/18/HTML5-1/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5新增的语义化元素"><a href="#HTML5新增的语义化元素" class="headerlink" title="HTML5新增的语义化元素"></a>HTML5新增的语义化元素</h2><a id="more"></a><p><img src="1.png" alt="HTML的语义化元素"></p><h2 id="HTML的最佳实践"><a href="#HTML的最佳实践" class="headerlink" title="HTML的最佳实践"></a>HTML的最佳实践</h2><ul><li>选择标记元素要有代表性，不要老是<code>&lt;div&gt;&lt;/div&gt;</code></li><li>不要忘记文档类型申明</li><li>不要忘记字符编码申明，在<code>&lt;head&gt;</code>元素中应该有<code>&lt;meta charset=&#39;UTF=8&#39;&gt;</code></li><li>不要使用HTML5不再支持的标记，如<code>&lt;center&gt;</code>,<code>&lt;font&gt;</code>,<code>&lt;basefont&gt;</code>,<code>&lt;big&gt;</code></li><li>不要使用HTML5不再支持的Tag属性 如<code>table</code>、<code>img</code>等标记的<code>align</code>和<code>border</code>属性，能用CSS就用CSS</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WindowsAPI常用概念&amp;结构体&amp;工具函数（一）</title>
      <link href="/2018/09/16/WindowsAPI_01/"/>
      <url>/2018/09/16/WindowsAPI_01/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h3><ul><li>进程更像是一个空间上的概念，而线程是真正的代码执行过程，利用进程的的资源，所以在Windows调用<code>CreateProcess</code>来创建一个进程的时候返回的<code>_PROCESS_INFOMATION</code>结构体包含了进程标识和线程标识两方面的信息</li><li>进程在执行过程中可能创建多个新的进程。创建进程成为称为父进程，而新的进程称之为子进程，构成的是一个“进程树”的结构<h3 id="ID与句柄"><a href="#ID与句柄" class="headerlink" title="ID与句柄"></a>ID与句柄</h3></li><li><p>在windows下内核对象的种类很多，物理是文件、进程、线程、事件、管道、互斥锁、信号量等等都是都是内核对象的，具体可以查阅MSDN文档关于<code>CloseHandle</code>函数的解释：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">点击前往</a></p></li><li><p>在内核中管理这些对象是通过内核对象ID的来维护的，能够通过ID来指向内核区具体的数据结构，不会将地址直接暴露给应用层。</p></li><li>句柄表是进程所拥有的，每个进程都有一个句柄表来维护这个进程所创建&amp;打开的内核对象</li><li>之前提到了进程树，子进程是可以共享父进程的资源（内核对象），共享的方式是继承，在创建进程的时候可以选择继承进程句柄和线程句柄</li><li>内核对象在内核中的ID是一定的，但是句柄中的值是不一定的，就好比两个进程同时打开同一个对象，在进程中记录的句柄表同一个的对象对应的句柄是不一样的，但是ID是一样的。</li><li>每个内核对象都有对应的表示标明是否可以被继承<h2 id="内核对象的生命周期"><a href="#内核对象的生命周期" class="headerlink" title="内核对象的生命周期"></a>内核对象的生命周期</h2>内核对象都有个计数器，计数器计数的值代表的是被引用的次数，一般的内核对象只需要</li><li>内核对象计数器为0</li></ul><p>就可以关闭，但是对于Thread以及Process内核对象情况有些特殊它要满足：</p><ul><li>内核对象计数器为０</li><li>执行流程结束</li></ul><h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><h3 id="STARTUPINFO"><a href="#STARTUPINFO" class="headerlink" title="STARTUPINFO"></a>STARTUPINFO</h3><p>从名字也可以看出，StartUpInfo保存着一些启动的信息</p><h3 id="PROCESS-INFOMATION"><a href="#PROCESS-INFOMATION" class="headerlink" title="_PROCESS_INFOMATION"></a>_PROCESS_INFOMATION</h3><p>进程结构体类型，具体的内容如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">  HANDLE hProcess;<span class="comment">//进程句柄</span></span><br><span class="line">  HANDLE hThread;<span class="comment">//线程句柄</span></span><br><span class="line">  DWORD  dwProcessId;<span class="comment">//进程ID</span></span><br><span class="line">  DWORD  dwThreadId;<span class="comment">//线程ID</span></span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure></p><h3 id="SECURITY-ATTRIBUTES"><a href="#SECURITY-ATTRIBUTES" class="headerlink" title="SECURITY_ATTRIBUTES"></a>SECURITY_ATTRIBUTES</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SECURITY_ATTRIBUTES</span> &#123;</span></span><br><span class="line">  DWORD  nLength;<span class="comment">//结构体长度</span></span><br><span class="line">  LPVOID lpSecurityDescriptor;<span class="comment">//指向安全描述符，指明当前对象的用户权限信息等等，默认与父进程相同</span></span><br><span class="line">  BOOL   bInheritHandle;<span class="comment">//当前内核对象是否允许继承</span></span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure><p>如果在创建内核对象的时候不想继承，那么传入该项结构体的值只需要填写<code>NULL</code>即可<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa379560%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">文档地址</a></p><h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><h3 id="GetStartupInfo"><a href="#GetStartupInfo" class="headerlink" title="GetStartupInfo()"></a>GetStartupInfo()</h3><p>获取当前进程的初始化信息，由父进程负责填充相关的<code>STARTUPINFO</code>结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO si;</span><br><span class="line">GetStartupInfo(&amp;si)</span><br></pre></td></tr></table></figure></p><p>由于我们即使填写了部分内容也不会都作用到最终的进程创建，我们常规的初始化步骤是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO si;</span><br><span class="line">ZeroMemory(&amp;si,sizeod(si))</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si)</span><br></pre></td></tr></table></figure></p><h3 id="CloseHandle"><a href="#CloseHandle" class="headerlink" title="CloseHandle()"></a>CloseHandle()</h3><p>将内核对象计数器的值减一</p><h3 id="GetStdHandle"><a href="#GetStdHandle" class="headerlink" title="GetStdHandle()"></a>GetStdHandle()</h3><p><a href="https://docs.microsoft.com/en-us/windows/console/getstdhandle" target="_blank" rel="noopener">文档地址</a></p><h3 id="WaitForSingleObject"><a href="#WaitForSingleObject" class="headerlink" title="WaitForSingleObject()"></a>WaitForSingleObject()</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C中sizeof的实现</title>
      <link href="/2018/09/14/C-1/"/>
      <url>/2018/09/14/C-1/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言中Sizeof的实现"><a href="#C语言中Sizeof的实现" class="headerlink" title="C语言中Sizeof的实现"></a>C语言中Sizeof的实现</h2><p>今天群里面提了一个问题，sizeof这个功能是怎么实现的，自己一时半会儿也没有思路，上网找了找实现，发现非常的巧妙，总结如下：<br><a id="more"></a></p><ul><li>sizeof不是一个函数，是一个宏</li><li>对于非数组的实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#defne _sizeof(T) ( (size_t)((T*)0 + 1))</span></span><br></pre></td></tr></table></figure></li></ul><p>首先将对应类型转换为指针地址，通过指针加一地址自动移动位置之后确定位置</p><ul><li>数组类型的实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> array_sizeof(T)   ( (size_t)(&amp;T+1)  - (size_t)(&amp;T)  )</span></span><br></pre></td></tr></table></figure></li></ul><p>假设传入的是一个<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></p><p>求地址操作会返回一个类型为<code>int[10]*</code>的指针，那么它一次移动的位数就是一个<code>int[10]</code>的长度</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>其都是通过指针移位的步长来解决的</li><li>对具体类型，用具体类型的指针</li><li>对于数组，用指向数组的指针</li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Type类型</title>
      <link href="/2018/09/12/Type%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/09/12/Type%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="从泛型到Type类型接口"><a href="#从泛型到Type类型接口" class="headerlink" title="从泛型到Type类型接口"></a>从泛型到Type类型接口</h2><p>众所周知，Java的泛型都是通过类型擦除来完成的，也就是说当Javac编译之后，所以的泛型参数都被打回原型，而之所以使用类型擦除实现泛型的原因主要是为了向下兼容。那么这样会有如下的问题：</p><ul><li>Java不能描述通过参数化之后的泛型类型，里面怎么参数化的一概不知</li></ul><p>但是在有些场景我们需要对传入的具体的参数化类型进行检测处理，之前的类型系统都依赖与<code>Class</code>本身描述信息，现在Java需要能够描述泛型的参数化过程，通过参数化泛型产生的新类型无非不过是基本的<code>Class</code>类型的组合,Java最后引入了Type接口以及一些子类来统一引入泛型之后的类型系统。</p><h2 id="Type是怎样统一Java的类型系统的"><a href="#Type是怎样统一Java的类型系统的" class="headerlink" title="Type是怎样统一Java的类型系统的"></a>Type是怎样统一Java的类型系统的</h2><p><strong>以下为个人的理解</strong></p><p>在泛型之前，Java类型除了原生类型都可以使用Class来描述，在泛型之后，新增了许多“新”的类型：</p><ol><li>参数化泛型类的类型，如<code>Collection&lt;T&gt;</code></li><li>参数化泛型类型构成的数组类型，如<code>Animal&lt;T&gt;[]</code></li><li>泛型参数构成的类型（泛型方法），如<code>&lt;E&gt;void method(E e){}</code>中的<code>E e</code>又或者是<code>ArrayList&lt;E&gt;</code>中的<code>E</code></li><li>通配符表达的类型，如<code>void printColl(ArrayList&lt;? extends Number&gt;al)</code>中的<code>? extends Number</code><br>上面四种类型和Class为了统一都实现了<code>Type</code>接口<h2 id="Type类型的关系"><a href="#Type类型的关系" class="headerlink" title="Type类型的关系"></a>Type类型的关系</h2><h3 id="Parameterizedtype"><a href="#Parameterizedtype" class="headerlink" title="Parameterizedtype"></a>Parameterizedtype</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.MalformedParameterizedTypeException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">   Type[] getActualTypeArguments();</span><br><span class="line">   <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>由于对于参数化泛型类对象中的泛型是可以嵌套的，所以需要注意返回的是除去一个嵌套之后的Type子类型。</p><ol><li>对于ArrayList&lt;ArrayList<integer>&gt; al,执行该方法去掉&lt;&gt;返回的是ArrayList<integer>所以还是参数化类型。如果再执行一次返回的就是Class类型</integer></integer></li><li>对于传入的不是具体如ArrayList<e>返回的就是TypeVariable</e></li><li>对于<code>ArrayList&lt;? extends Number&gt;</code>返回的是<code>? extends Number</code> 是WildcardType</li><li>对于<code>ArrayList&lt;E[]&gt;</code>返回<code>E[]</code>是GenericArrayType</li></ol><ul><li>getRawType()<br>简单的说就是得到&lt;&gt;前的原始类型</li><li>getOwnerType();得到类型的所有者类型，例如Map.Entry就是Map的所有者类型</li><li>getActualTypeArguments()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码来自https://segmentfault.com/q/1010000000655631</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Method method = <span class="keyword">new</span> GenericDemo().getClass().getMethod(<span class="string">"applyMethod"</span>,Map.Entry.class);</span><br><span class="line">    Type[] types = method.getGenericParameterTypes();</span><br><span class="line">    ParameterizedType pType = (ParameterizedType)types[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回所有者类型，打印结果是interface java.util.Map</span></span><br><span class="line">    System.out.println(pType.getOwnerType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; <span class="function"><span class="keyword">void</span> <span class="title">applyMethod</span><span class="params">(Map.Entry&lt;T,U&gt; mapEntry)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="认识具体的Type类型以及相关方法"><a href="#认识具体的Type类型以及相关方法" class="headerlink" title="认识具体的Type类型以及相关方法"></a>认识具体的Type类型以及相关方法</h2><p>### </p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p> <a href="https://blog.csdn.net/gdutxiaoxu/article/details/68926515" target="_blank" rel="noopener">java Type详解</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/z69183787/article/details/54314169" target="_blank" rel="noopener">Java类型中ParameterizedType，GenericArrayType，TypeVariabl，WildcardType详解</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 学习</title>
      <link href="/2018/09/10/Git/"/>
      <url>/2018/09/10/Git/</url>
      
        <content type="html"><![CDATA[<h2 id="GIT精简教程"><a href="#GIT精简教程" class="headerlink" title="GIT精简教程"></a>GIT精简教程</h2><p>简单记录<br><a id="more"></a></p><h3 id="集中式和分布式"><a href="#集中式和分布式" class="headerlink" title="集中式和分布式"></a>集中式和分布式</h3><p>集中式类似CVS必须联网工作，这样对带宽有要求，在网络环境下缺陷显著。而分布式管理系统没有“中央服务器”之称，每个人的电脑是一个完整的版本库。“单点失败”的问题可以被解决，每个人在自己的电脑上修改了文件，相互之间将各自的修改推送给对方即可<br>其他要点：</p><ul><li><p>CVS是最早开源的集中式版本控制系统，本身有缺陷，同样是开源且免费的SVN修正CVS稳定性问题，是目前使用最多的集中式版本控制系统</p><h3 id="安装之后的配置"><a href="#安装之后的配置" class="headerlink" title="安装之后的配置"></a>安装之后的配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"maoxin"</span></span><br><span class="line">git config --global user.email <span class="string">"lumaoxin@aliyun.com"</span></span><br></pre></td></tr></table></figure></li><li><p>其中–global 表示所以的git仓库都使用该配置</p></li></ul><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>在文件夹内部使用<code>git init</code>命令将当前文件夹变为git仓库，这时会创建隐藏目录<code>.git</code></p><h3 id="添加文件到仓库"><a href="#添加文件到仓库" class="headerlink" title="添加文件到仓库"></a>添加文件到仓库</h3><p>首先需要明确，所有的版本控制系统，只能跟踪文本文件的改动，而二进制文件的改动不能被跟踪<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure></p><p>没有消息就是最好的消息，</p><h3 id="提交文件到仓库"><a href="#提交文件到仓库" class="headerlink" title="提交文件到仓库"></a>提交文件到仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"wrote a readme file"</span></span><br></pre></td></tr></table></figure><ul><li>使用commit来提交 -m之后是本次提交的说明</li><li>可以add多个文件之后一次性commit<h3 id="管理版本"><a href="#管理版本" class="headerlink" title="管理版本"></a>管理版本</h3>使用git log来查看版本的变更，提交的信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><p>这样会输入大量多行信息，如果想要精简信息，就需要：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=online</span><br></pre></td></tr></table></figure></p><ul><li>在信息会看到commitid是一串16进制值，这主要是git生成的Hash码，这样可以有效防止冲突</li><li>在git中HEAD表示当前版本，上一个是HEAD^,再上一个是HEAD^^,上100个版本是HEAD~100<h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3>使用git reset来完成回退<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li></ul><p>这个时候再去看log已经找不到来自属于“未来”的信息了，要想回到未来，就需要使用commitid去寻找，没有必要写全<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1094a</span><br></pre></td></tr></table></figure></p><p>而如何找到版本号，可以使用git reflog来查看每一次记录的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></p><h3 id="工作区和暂存区的概念"><a href="#工作区和暂存区的概念" class="headerlink" title="工作区和暂存区的概念"></a>工作区和暂存区的概念</h3><p>由于对于git这样的分布式版本管理工具，在本机有Master库，我们做的每一次修改如果都作为Master库的修改的话是不应该的，应该是我们先做一定的修改，确定后提交给Master库。那么在commit之前保存修改信息就是非常需要的，在git中使用stage，暂存区的概念。而我们再未add到暂存区之前对文件所做的所有操作，都是到“工作区”<br>我们通过以下命令来查看暂存区的状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>git管理的是修改而不是文件，修改之后首先得add进storge中才会被之后的commit提交。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>当修改的文件已经被add进缓存区中，可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure></p><p>这个时候是从撤销了该文件在暂存区的记录，同时注意它还会将在暂存取的记录还原到工作区</p><p><strong>总之以上命令相当于将文件恢复到add或者commit之前</strong><br>但是如果已经提交到暂存区，上面得到修改方式就不灵了，只能回到add之后的状态<br>我们可以使用一下命令将暂存区的修改撤销掉<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD readme.txt</span><br></pre></td></tr></table></figure></p><p>之后再丢弃工作区的修改即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure></p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>文件的删除本身也是修改，我们再add到git之后在工作区删除文件之后，用<code>git status</code>命令也可以找到本次的修改,使用如下的<code>git rm</code>来从版本库中删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt</span><br></pre></td></tr></table></figure></p><p>之后再去commit<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure></p><p>如果删除错了，可以时候check来回到commit之前的状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure></p><h3 id="SSH加密认证原理"><a href="#SSH加密认证原理" class="headerlink" title="SSH加密认证原理"></a>SSH加密认证原理</h3><p><strong>对称加密</strong>：加密解密用同一个密钥，使用同一套加密算法，只是密钥不同（只要在网上传输这个密钥就是不安全的）</p><p><strong>RSA 非对称加密</strong>：这里不探讨非对称加密的原理，但是非对称加密有如下有意思的特点：</p><ul><li>用私钥加密的数据，只有对应的公钥才能够解密</li><li>用公钥加密的数据，只有对应的私钥才能解密</li><li>只要互相公布自己的公钥，即可完成双方信息的加密传输</li></ul><p>例如：B向A发送数据，A公布自己的公钥，B拿着公钥加密数据，传输到A之后A拿自己的私钥去解密。反之亦然，</p><p>稍微详细的过程如下：</p><ol><li>首先A、B双方，在通信前构建专属于自己的密钥对，假设分别是公钥A，私钥A，公钥B，私钥B； </li><li>A将自己的公钥A暴露给B，B通过私钥B和公钥A经过一定的运算产生出本地的密钥B； </li><li>同样，B将自己的公钥B暴露给A，A通过私钥A和公钥B经过一定的运算产生出本地的密钥A； </li><li>最后，这个算法有意思的一点就是，密钥A和密钥B是一致的，这样A、B双方就拥有了一个属于双方的“秘密”口令</li></ol><p><strong>非对称加密+对称加密</strong></p><p>RSA非对称加密速度很慢，每次都要采用非对称加密的方式传输太浪费资源，而对称加密速度比RSA快上数百倍，不如将对称加密密钥通过RSA传输之后通过对称加密方式。</p><p><strong>中间人劫持问题</strong></p><p>对于非对称加密，B要向A发送加密之后的信息首先要获取A的公钥，A在发送的时候被截取之后被中间人替换为中间人的公钥，这时，B就会拿着中间人的公钥去加密数据，再返回中间人，中间人用自己的私钥去解密，之后再用A的公钥加密。这种方式叫做中间人劫持</p><p><strong>问题的解决策略</strong>：CA 数字签名与证书（略）</p><p><strong>SSH简介</strong></p><p>简单说，SSH（Secure Shell）是一种<strong>非对称加密与对称加密算法相结合的安全网络协议</strong>，用于计算机通信加密。一个SSH会话的建立过程分为两个阶段：第一阶段，双方沟通并同意建立一个加密连接通道以供后续信息传输用；第二阶段，对请求接入的用户进行身份验证以确定服务器端是否要给该用户开放访问权限。</p><p><strong>SSH步骤</strong></p><ul><li><p>首先通过非对称加密来建立一条加密通道，通过得知双方的公钥和私钥可以获得这一特殊的密钥来加密数据</p></li><li><p>SSH密钥对的验证过程起始于上一部分加密通道建立之后，其具体执行步骤如下：客户端发送自己的密钥ID给服务器端，服务器在自己的authorized_keys文件中检查是否有此ID的公钥。如果有，则服务器生成一个随机数，用该公钥加密之后，服务器将加密后的随机数发给客户端。客户端用私钥解密该随机数，然后在本地为随机数做MD5哈希，客户端将该MD5哈希发给服务器端，服务器端为一开始自己生成的随机数也做一个MD5哈希，然后用通讯通道“公共的密钥”将该哈希加密，再跟客户端发来的内容进行对比。如果双方内容一致，则通过验证，开放访问权限给客户端</p><p>简单来说，服务器端用公钥加密信息，客户端用私钥解密信息以证明自己持有私钥。</p></li></ul><blockquote><p>参考：</p><p>CSDN博客  <a href="https://blog.csdn.net/u014206910/article/details/54691886" target="_blank" rel="noopener">啊塔-SSH加密认证原理</a></p><p>刘欣 《码农翻身》-机械工业出版社</p></blockquote><h3 id="使用远程仓库"><a href="#使用远程仓库" class="headerlink" title="使用远程仓库"></a>使用远程仓库</h3><p>创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><h3 id="添加到远程库"><a href="#添加到远程库" class="headerlink" title="添加到远程库"></a>添加到远程库</h3><ol><li>首先在github中创建远程库</li><li>在本地仓库中链接</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add orgin git@github.com:XXXX/XXXX.git</span><br></pre></td></tr></table></figure><p>这样设置远程库的名字就是origin</p><ol start="3"><li>推送到远程库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><h3 id="从远程库拉取"><a href="#从远程库拉取" class="headerlink" title="从远程库拉取"></a>从远程库拉取</h3><p>使用<code>git clone</code>克隆本地库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:xxx/xxx.git</span><br></pre></td></tr></table></figure><blockquote><p>参考廖雪峰老师的GIT教程  <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374027586935cf69c53637d8458c9aec27dd546a6cd6000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374027586935cf69c53637d8458c9aec27dd546a6cd6000</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蛋疼的JavaScript(二)this</title>
      <link href="/2018/09/10/js2/"/>
      <url>/2018/09/10/js2/</url>
      
        <content type="html"><![CDATA[<h3 id="烦人的this"><a href="#烦人的this" class="headerlink" title="烦人的this"></a>烦人的this</h3><p>JavaScript的表现与之前学的任何传统的语言都不一样，这个就很烦人，这几天把这个坑扫除了<br><a id="more"></a></p><h3 id="this到底指向什么"><a href="#this到底指向什么" class="headerlink" title="this到底指向什么"></a>this到底指向什么</h3><p>总的来说，总结下，this其实取决于调用者的上下文环境，好比直接调用函数，是在全局作用域下的，就是直接this就是Window<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()<span class="comment">//Window</span></span><br></pre></td></tr></table></figure></p><p>而如果将作为对象中的属性，objA.objB.fun（）这个时候this就是objB<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">objA=&#123;</span><br><span class="line">    a:<span class="number">123</span>,</span><br><span class="line">    myfun:fun</span><br><span class="line">&#125;</span><br><span class="line">objA.fun()<span class="comment">//objA</span></span><br></pre></td></tr></table></figure></p><p>同样的道理可以延伸到对象的事件，注册事件其实就是将对应对象的上下文环境中的某个属性例如click绑定一个函数，这样的话，函数内部的this就是调用者本身<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#btn"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;<span class="comment">//&lt;input type="button"/&gt;</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是，理解什么是上下文环境，千万不要把上下文环境错认为就是所谓的作用域<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnChain_1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    fnChain_2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnChain_2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    fnChain_3()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnChain_3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnChain_1()</span><br><span class="line"><span class="comment">//三个都是Window</span></span><br></pre></td></tr></table></figure></p><p>上面实例代码是错误理解上下问环境的典范</p><h3 id="new-操作符创建时的this"><a href="#new-操作符创建时的this" class="headerlink" title="new 操作符创建时的this"></a>new 操作符创建时的this</h3><p>首先看一个简单的函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()<span class="comment">//Window</span></span><br><span class="line"><span class="keyword">new</span> foo()<span class="comment">//foo</span></span><br></pre></td></tr></table></figure></p><p>在这里需要校正的观念是这里不存在类似其他语言的new调用构造函数，而是使用了“构造调用”，使用构造调用的方式来创建一个新的对象<br><code>new</code>操作符执行的步骤如下：</p><ol><li>首先创建一个新的对象</li><li>这个新对象执行[[原型]]链接</li><li>新对象会被绑定到执行函数调用的this<br>简而言之，new操作的this有点类似其他语言的this<br>下面是实例代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> foo(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> foo(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//foo&#123;a:2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b)<span class="comment">//foo&#123;a:1&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="ES6的this"><a href="#ES6的this" class="headerlink" title="ES6的this"></a>ES6的this</h3><p>ES6引入了箭头函数，这时this的表现与我们之前接触的又不一样了，具体不同点如下:</p><ul><li>普通的函数的this取决于调用上下文</li><li>而ES6里面的this是继承父执行上下文的this<br>实例代码如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码来自于https://blog.csdn.net/qq_38563845/article/details/78145814</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span>,</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    one: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//箭头函数</span></span><br><span class="line">    two: <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//普通函数中的箭头函数</span></span><br><span class="line">    three: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    (<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">   &#125;)()</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">//多层箭头函数</span></span><br><span class="line">    four: <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    (<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">   &#125;)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.one();    <span class="comment">//obj  </span></span><br><span class="line">obj.two();  <span class="comment">//window </span></span><br><span class="line">obj.three();  <span class="comment">//obj</span></span><br><span class="line">obj.four()    <span class="comment">//window</span></span><br></pre></td></tr></table></figure></li></ul><p>下面分析我们的想法来个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">         &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo()()()()<span class="comment">//Window</span></span><br></pre></td></tr></table></figure></p><p>如果将上面的代码改为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo().call(&#123;<span class="attr">a</span>:<span class="string">"HelloWorld"</span>&#125;)()()()</span><br><span class="line"><span class="comment">//&#123;a:"HelloWorld"&#125;</span></span><br></pre></td></tr></table></figure></p><p>至于call是干什么的，接下来来解释</p><h3 id="主动修改this？call-amp-apply-amp-bind"><a href="#主动修改this？call-amp-apply-amp-bind" class="headerlink" title="主动修改this？call&amp;apply&amp;bind"></a>主动修改this？call&amp;apply&amp;bind</h3><p>call 和 apply 的效果都是一样的，只是参数不同，他们显式的修改要执行函数的this指向，如果将这种指向被一个函数包起来，那么这个绑定就被不会被解绑了，例如这个<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a</span><br><span class="line">    &#125;.call(obj)<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而apply就是有了参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单bind函数的实现，argument是参数列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply( obj, <span class="built_in">arguments</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在 ES5 中提供了内置的方法 Function.prototype.bind，它的用法如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( obj );</span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p><code>bind(..)</code> 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDBC设计思想</title>
      <link href="/2018/08/29/JDBC%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
      <url>/2018/08/29/JDBC%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>更有利于了解JDBC建立链接过程的API<br><a id="more"></a></p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>从《码农翻身》，作者：刘欣   一书中了解JDBC的设计思想：</p><ul><li>首先，为了统一各大数据库不同数据库的具体实现，应该加一个抽象层，统一出一个一致的访问方式，利用接口规范方法，各大数据库厂商实现接口，这个问题可以解决。但是也引入了一个新的问题，这个问题就是在代码中要使用接口首先得声明具体实现，这就出现了违背了面向接口编程，是面向实现编程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="keyword">new</span> MySqlConnectionImpl(info)；</span><br><span class="line"><span class="comment">//如果数据库厂商除了一个新的版本并且修改了名字是，MySqlConnectionJDBC4Impl,以上代码就无法编译通过</span></span><br></pre></td></tr></table></figure><ul><li>解决上面的问题就是再增加一个抽象层，类比我们计算机的外界设备的接口都是相同的，例如USB，但对不同的实现例如U盘，键盘只需安装不同的驱动即可，这样抽象出了一个驱动层，而JDBC吸收了这样的思想，抽象出一个Driver层。这个Driver层是一个简单工厂，其具体实现可以类比如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String dbType,Properties info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"mysql"</span>.equals(dbType))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MySqlConnectionImpl(info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"oracle"</span>.equals(dbType))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> OracleConnectionImpl(info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"unsupported db type:"</span>+dbType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样其实是将原来的问题提升了个层次，在原来的代码中是不需要修改了，但是需要着重修改工厂方法中的具体实现，是相当于将问题转移。到目前为止我们是可以通过一下的方式来获取驱动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = Driver.getConnection(<span class="string">"mysql"</span>,info);</span><br></pre></td></tr></table></figure><ul><li>正如上面所说，问题转移到了Driver这个静态工厂中，如果这个Driver是JDK提供的，那么就无法修改，除了修改又增加了一个问题。最后的解决方法是使用配置文件的方式，用配置文件这样“数据驱动”方式可以有效解决这样一个问题。但是这样的方式为用户暴露了太多东西，本身也是比较Low的，下面引入一种“工厂方法”的设计模式。</li><li>工厂方法与简单工厂最大的区别就是，工厂本身也变成了接口，将简单工厂中创建具体对象的责任通过厂商实现Driver接口来分配到各大厂商的JDBC实现类中去了，连创建都交给了数据库厂商的驱动中实现，这样对于我们自己写的程序就很少了，只需要使用类加载器加载驱动之后创建实例强转成Driver了类似与以下代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(Properties info)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlDriver</span> <span class="keyword">implements</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(Properties info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MySqlConnection(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>创建过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;clz = Class.forName(<span class="string">"com.coderising.mysql.MySqlDriver"</span>);</span><br><span class="line">Driver driver = (Driver)clz.newInstace();</span><br><span class="line">Connection conn = driver.getConnection(info);</span><br></pre></td></tr></table></figure><ul><li>上面的代码已经相当于把职责分清楚了，数据库厂商负责Driver的具体实现，已经可以做到不用修改源代码了。这个时候唯一的问题就是将反射创建以及强转的过程暴露给开发者了，想办法再将反射隐藏操作隐藏起来，将Driver隐藏起来。这个时候就需要一个类来完成，通过这个类能够得到具体的Connection，而些Connection能来自不同的数据库厂商，因此它能够管理众多的数据库驱动。而数据库驱动本身也应该到这样一个类中注册。实现代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DriverManager&#123;</span><br><span class="line">    List&lt;Driver&gt; lists = <span class="keyword">new</span> ArrayList&lt;Driver&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Driver driver)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!registeredDrivers.contains(driver))&#123;</span><br><span class="line">            registeredDrivers.add(driver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,String user,String password)</span></span>&#123;</span><br><span class="line">        Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">        info.put(<span class="string">"user"</span>,user);</span><br><span class="line">        info.put(<span class="string">"password"</span>,password);</span><br><span class="line">        <span class="keyword">for</span>(Driver driver:registeredDrivers)&#123;</span><br><span class="line">            Connection conn = driver.getConnection(url,info);</span><br><span class="line">            <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't create a connection"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过程回顾"><a href="#过程回顾" class="headerlink" title="过程回顾"></a>过程回顾</h3><p>JDBC如何从面向实现编程到完全的面向接口编程的。</p><ol><li>在出现面向实现编程的问题时，首先使用简单工厂这样一个抽象层使得通具体实现的解耦</li><li>在简单工厂需要频繁在代码中修改的时候使用数据驱动的方式使得修改的内容与类解耦</li><li>这样各大厂商的<code>Connection</code>的创建是由第三方来维护的，没有体现职责分明，就需要使用工厂方法，由<code>JDBC</code>定义接口<code>Driver</code>，将创建<code>Connection</code>的方法交给具体厂商实现。</li><li>上面已经可以解耦了，但是为了屏蔽反射细节，就使用<code>DriverManager</code>来统一管理驱动</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> jdbc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从Java泛型谈起</title>
      <link href="/2018/08/29/%E4%BB%8EJava%E6%B3%9B%E5%9E%8B%E8%B0%88%E8%B5%B7/"/>
      <url>/2018/08/29/%E4%BB%8EJava%E6%B3%9B%E5%9E%8B%E8%B0%88%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h2><p>在泛型出现之前，要想实现一个类型通用的实现必须要使用Object，而Object本身就是所有对象的父类，这就难免会由于类型检查的缺乏而影响程序本身。这些规范完全依赖于程序员的自律。这个时候如果既能保留C++泛型能创建通用代码的特性，又能对类型做到一定的检查就好了，而Java泛型应运而生，需要注意的是，Java语言是本身能够实现通用代码的编写的，而现在只需要对类型做一些限制，这和C++的泛型的思想有很大的不同，这就导致了Java的泛型采用了类型擦除的思路。</p><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>与C++语言每次根据传入类型生成代码的“膨胀”法不同，Java使用了类型擦除机制来实现泛型，本质上还是Object，只不过就是增加了编译器检查，正因为如此，可以总结如下两个特性：</p><ul><li>所写的泛型代码在最后都被擦除成Object</li><li>泛型可以不写强制转换的原因是编译的时候编译器加了自动的转型</li></ul><h2 id="精确的泛型"><a href="#精确的泛型" class="headerlink" title="精确的泛型"></a>精确的泛型</h2><h3 id="泛型类与泛型方法"><a href="#泛型类与泛型方法" class="headerlink" title="泛型类与泛型方法"></a>泛型类与泛型方法</h3><p>总之就是一个<code>&lt;T&gt;</code>里面填写具体的泛型参数的表示,在类上申明就是泛型类，在方法上申明就是泛型方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDao</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tools</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copyOf</span><span class="params">(T ori)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个类被实例化参数话之后，T全部变成了具体的类型</p><h3 id="再加点限制-super-amp-extends"><a href="#再加点限制-super-amp-extends" class="headerlink" title="再加点限制: super &amp; extends"></a>再加点限制: super &amp; extends</h3><p>泛型类或者泛型方法中的泛型逻辑需要利用一些特殊的类，例如需要某接口实现的方法等等，这个时候需要对这样一个具体的类进行限制，这种限制分为两种，上界和下界</p><ul><li><p>extends</p><ul><li><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] array)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>extends指定了上界，传入的元素会检查是否是Comparable的子类</p></li></ul></li><li><p>super</p><ul><li>super指定上界。</li></ul></li></ul><h2 id="精确泛型满足不了的场景"><a href="#精确泛型满足不了的场景" class="headerlink" title="精确泛型满足不了的场景"></a>精确泛型满足不了的场景</h2><p>这写情况发生再泛型参数赋值的情景。</p><p>我们上面讨论的都是精确的泛型，“精确的泛型”是我根据自己理解来描述的，它满足不了不需要精确泛型的应用场景：下面用码农翻身公众号的例子来说明：</p><h3 id="当泛型遇到了继承的场景"><a href="#当泛型遇到了继承的场景" class="headerlink" title="当泛型遇到了继承的场景"></a>当泛型遇到了继承的场景</h3><p><img src="从Java泛型谈起/1.png" alt="类图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ArrayList&lt;Fruit&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Fruit e:list)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Apple());</span><br><span class="line">list.add(<span class="keyword">new</span> Apple());</span><br><span class="line"></span><br><span class="line">print(list)<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>为什么会出现这个问题，说到底就是传入的参数类型不符，我们想要去做到一个不精确的匹配，为了达到这个目的，Java引入了通配符<code>?</code> </p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>Java引入的通配符来满足不精确匹配的场景，刚才由于<code>List&lt;Fruit&gt;</code>和<code>List&lt;Apple&gt;</code>是两个完全不同的类型，因此编译失败，两个不同的类型是不能直接赋值的，虽然<strong>里面的成分</strong>有继承关系。为了解决这个问题，引入了通配符，通配符就表示这个泛型实例的类型是未知的，那么，完成下面的赋值操作就是再正常不过的了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br></pre></td></tr></table></figure><h3 id="的使用"><a href="#的使用" class="headerlink" title="? 的使用"></a>? 的使用</h3><p>简单的说，？的使用场景</p><h3 id="extends-amp-super"><a href="#extends-amp-super" class="headerlink" title="extends &amp; super"></a>extends &amp; super</h3><blockquote><p><a href="https://segmentfault.com/a/1190000008423240#articleHeader0" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008423240#articleHeader0</a></p></blockquote><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><blockquote><p><a href="https://www.cnblogs.com/shadowdoor/p/6817346.html" target="_blank" rel="noopener">https://www.cnblogs.com/shadowdoor/p/6817346.html</a></p><p><a href="http://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html" target="_blank" rel="noopener">http://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html</a></p><p><a href="https://blog.csdn.net/u010884123/article/details/78189395" target="_blank" rel="noopener">https://blog.csdn.net/u010884123/article/details/78189395</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>保护模式笔记</title>
      <link href="/2018/08/17/ProtectMod/"/>
      <url>/2018/08/17/ProtectMod/</url>
      
        <content type="html"><![CDATA[<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[0x123456],eax</span><br></pre></td></tr></table></figure><p>ds就是段寄存器，真正读写的地址是：ds.base + 0x123456</p><p>其中段寄存器有8个</p><p>ES（）CS（）SS（）DS（）FS（）GS（）LDTR（）TR（Task Register）</p><h3 id="段寄存器的结构"><a href="#段寄存器的结构" class="headerlink" title="段寄存器的结构"></a>段寄存器的结构</h3><p>32位的段寄存器一共96位，16位可见，80位不可见（12个字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegMent</span>&#123;</span></span><br><span class="line">    WORD Selector;<span class="comment">//16位的Selector（2字节）[可见部分]</span></span><br><span class="line">    WORD Attribute;<span class="comment">//16位Attribute 属性，标识可读可写可执行（2字节）</span></span><br><span class="line">    DWORD Base;<span class="comment">//32位Base 偏移地址（4字节）</span></span><br><span class="line">    DWORD Limit;<span class="comment">//32位Limit 段允许的地址偏移（4字节）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是用结构体来描述段寄存器的内容。</p><h3 id="段寄存器的读写"><a href="#段寄存器的读写" class="headerlink" title="段寄存器的读写"></a>段寄存器的读写</h3><p><strong>READ</strong></p><p>段寄存器读取的时候只能读可见部分，16位，因此读的时候只能读16位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,ES</span><br></pre></td></tr></table></figure><p><strong>WRITE</strong></p><p>段寄存器写入的时候是要写96位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV DS,AX</span><br></pre></td></tr></table></figure><p>那么一个问题浮出水面，段寄存器赋值的时候可以写入96位，但是传递给的是一个16位的寄存器，那么另外的80位从哪里得到呢？</p><h3 id="GDT-表和-LDT表"><a href="#GDT-表和-LDT表" class="headerlink" title="GDT 表和 LDT表"></a>GDT 表和 LDT表</h3><p>GDT是全局描述符表，LDT是局部描述符表，要想填写完整段寄存器，需要拿着一个索引到GDT表或者LDT表去查找、这个索引就在传递的16位寄存器的数据当中。而这16位的数据对应到段寄存器的部分是段选择子。</p><p><strong>段选择子</strong></p><p><img src="ProtectMod/Selecter.png" alt="段选择子结构"></p><p>段选择子分为三部分，一个是Index，一个是Table Indicator 还有一个是请求特权级别RPL</p><ul><li>Index <ul><li>13位，起到索引的作用，从GDT表或者LDT表中查找数据</li><li>索引查找的规则是将索引值乘以8再加上GDT或者LDT表的基地址，就是要加载的段描述符位置，也相当于2进制左移三位再加上基地址。</li></ul></li><li>Table Indicator 表指示器<ul><li>用来选择是从哪张表去选取</li></ul></li><li>RPL 请求特权级别<ul><li>其有两位，表示了0,1,2,3四种CPU特权访问级别</li><li>其代表这</li></ul></li></ul><p><code>001B= 0000-0000-0001-1011</code></p><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>段描述符是64位的数据，占据了8个字节，下面是其结构：</p><p><img src="ProtectMod/02.png" alt="段描述符"></p><p>首先有个大致的印象，首先发现其Base属性和Limit被割裂到不同的部分，这主要是CPU寄存器升级为了向下兼容才形成的这样的情况。回顾段寄存器结构，</p><ul><li>Base一共32位，在段描述符描述完整</li><li>Limit一共32位，而在段描述符中只描述16+4=20位</li><li>其他部分充当段属性，应当是16位，在段描述符中描述完整，8位到第23位，23+1-8=16</li></ul><p>以上并不能构成整个80位的除去段选择子的剩下部分，这是我们的问题，留在下面解决。</p><h3 id="P位和G位"><a href="#P位和G位" class="headerlink" title="P位和G位"></a>P位和G位</h3><p>P（Segment present） 位是表示段是否有效的位，当其=1代表有效，加载段描述首先要判断的就是P位是否标识该段描述符有效</p><p>G （Granularity） n. 间隔 ，它代表的是Limit描述数值的单位，如果G=0，那么单位就是字节，Limit在段描述符保存的值一共12位，因此Limit此时的最大范围是：</p><p><code>(0000 0000-000F FFFF)</code>如果G位位1，那么其是4KB，2^12，那么此时的范围是</p><p><code>(0000 0FFF-FFFF FFF)</code></p><h3 id="S位和Type域"><a href="#S位和Type域" class="headerlink" title="S位和Type域"></a>S位和Type域</h3><p>S (Descriptor type)位是一个描述段类型的位，当其=0的时候代表的是系统段描述符，当其=1的时候是代码段或者数据段的描述符，具体的信息由type域给出。</p><p>当S=1，代指的是代码段或者数据段，其Type域的值为：</p><p><img src="ProtectMod/03.png" alt="代码段或数据段的段描述符"></p><p>简要描述下，第11位决定到底是代码段还是数据段，当位数据段的时候，第11位是0，此时</p><table><thead><tr><th>标识</th><th>解释</th></tr></thead><tbody><tr><td>A</td><td>表示是否访问(Access)过 为1代表访问过</td></tr><tr><td>W</td><td>表示是否可写是，为1代表可写</td></tr><tr><td>E</td><td>为0向上拓展，为1向下拓展</td></tr></tbody></table><p>所谓向上扩展还是向下扩展针对的是Limit限制的是向下一定范围能访问还是除了向下一部分范围不能访问。</p><p><img src="ProtectMod/04.png" alt="向上扩展和向下扩展"></p><p>如何快速判断一个段描述符描述的是代码段和数据段？就要熟悉其二进制表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DPL 不是全0就是全1</span></span><br><span class="line"><span class="comment">/32----24/23------20/19-----16/15---12/11-8/7--0/</span></span><br><span class="line"><span class="comment">/--BASE--/G|DB|0|AVL/--Limit--/P|DPL|S/TYPE/BASE/</span></span><br><span class="line"><span class="comment">-------------------------------1 00  1----------/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">只需要看倒数第三第四位就可以迅速判断</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果是代码段的话，要明确其含义是不同的：</p><table><thead><tr><th>标识</th><th>含义</th></tr></thead><tbody><tr><td>A</td><td>是否访问过</td></tr><tr><td>R</td><td>是否可读</td></tr><tr><td>C</td><td>一致代码段还是非一致代码段=1表示一致，=0表示非一致</td></tr></tbody></table><p>至于一致和非一致代码段代表的是是否可以越权访问，具体的区别在下面学习。</p><p>至于系统段描述符，先将其表格列举如下：</p><p><img src="ProtectMod/05.png" alt="系统段描述符的type域"></p><h3 id="D-B位"><a href="#D-B位" class="headerlink" title="D/B位"></a>D/B位</h3><p>D/B位代表的是(Default operation size)决定CPU的寻址方式,0代表的是16位寻址，该段也是16位段，1代表的是32位寻址，该段也是32位段，其寻址方式要对应。</p><h3 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h3><p>段权限检查是相对比较难理解的一部分，段权限的检查发生在段寄存器的变化，确定段寄存器是否能加载一个段描述符。</p><p>首先要知道的是CPU的保护模式之所以称之为保护是其有分级的制度，CPU一共4个不同的级别</p><p><img src="ProtectMod/06.png" alt="CPU特权级别"></p><p>CPU的特权级有四个，分别为0,1,2,3 windows 和 Linux操作系统都只使用了两个环，就是3环和0环，3环是应用程序的权限级别，而0环是系统内核的级别</p><p>那么如何查看当前程序跑在哪一环呢？这就需要查看CPL（Current Privilege Level）当前特权级别。</p><p><strong>CS和SS段的段选择子中的RPL就是CPL（CPU不同的特权级都有其特定的栈）</strong></p><p><strong>DPL在段描述符中，描述的是访问该段需要的最低权限</strong></p><p><strong>RPL描述的是我在能访问到DPL的前提下，我需要用怎样的权限去访问段</strong></p><h3 id="数据段的段权限检查"><a href="#数据段的段权限检查" class="headerlink" title="数据段的段权限检查"></a>数据段的段权限检查</h3><p>CPL&lt;=DPL并且RPL&lt;=DPL</p><p>需要注意的是,段描述符分为三大类，代码段和系统段的权限检查和数据段的方式</p><h3 id="代码的跨段执行"><a href="#代码的跨段执行" class="headerlink" title="代码的跨段执行"></a>代码的跨段执行</h3><p>首先代码的跳转，本身就依赖于段内跳转<code>JMP</code>，段间跳转<code>JMP FAR</code>，段内调用<code>CALL</code>，段间调用<code>CALL FAR</code>，段内返回<code>RET</code>，段间返回<code>RETF</code>，中断<code>INT</code>,中断返回<code>IRETED</code>；</p><p>代码的跨段执行，必然伴随着同时修改段寄存器以及EIP的值，同时修改CS和EIP的指令是：</p><p><code>JMP FAR</code>,<code>CALL FAR</code>,<code>RETF</code>,<code>INT</code>,<code>IRETED</code>则是同时修改寄存器和EIP的值</p><p><strong>代码的段间跳转</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 0x20:0x004183D7;操作数一共6个字节，前面两个段选择子，后面是偏移</span><br></pre></td></tr></table></figure><p>执行步骤：</p><ul><li>段选择子的拆分<ul><li><code>0x20</code>对应<code>0000 0000 0010 0000</code></li><li>由于TI=0 所以查找GDT表</li><li>Index=4 找到对应的段描述符需要将Index*8+GDT表的基地址</li><li>判断段描述符的类型，四种情况是可以跳转的：<ul><li>代码段</li><li>调用门</li><li>TSS任务段</li><li>任务门</li></ul></li></ul></li><li>权限检查，判断代码段的Type域内标明的是一致性代码段还是非一致性代码段<ul><li>如果是非一致代码段，要求CPL==DPL,RPL&lt;=DPL</li><li>如果是一致性质代码段,要求CPL&gt;=DPL,当前特权级级别可以比一致代码段要求的要低的，专门给低权限来用的，完成所谓的共享的功能。</li></ul></li><li>加载段描述符<ul><li>通过上面权限检查之后，CPU会讲段描述符加载到CS段寄存器</li></ul></li><li>代码执行<ul><li>CPU将<code>CS.BASE+OFFSET</code>的值写入到EIP然后执行对应的代码段，段间跳转执行完毕</li></ul></li></ul><h3 id="一致代码段和非一致代码段"><a href="#一致代码段和非一致代码段" class="headerlink" title="一致代码段和非一致代码段"></a>一致代码段和非一致代码段</h3><ul><li>对于一致代码段：也就是共享的段<ul><li><strong>特权级高的程序不允许访问特权级低的数据，核心态不允许访问用户态的数据</strong></li><li><strong>特权级低的程序可以访问到特权级高的数据，但是特权级不会改变：用户态还是用户态</strong></li><li>C=0表示一致，C=1表示非一致</li></ul></li><li>对于普通代码段：也就是非一致代码段<ul><li>只允许同级访问</li><li>绝对禁止不同级别的访问：核心态不是用户态</li></ul></li><li>直接对代码段进行JMP或者CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变，如果想要提升CPL的权限，只能通过调用门</li></ul><p><strong>简而言之，一致代码段高权限访问不了低权限的数据，低权限可以访问高权限的数据，但是RPL不会发生变化，非一致代码段很严格的1对1，只允许同级访问</strong></p><h3 id="长调用"><a href="#长调用" class="headerlink" title="长调用"></a>长调用</h3><p>CALL FAR要比JMP FAR 复杂，因为JMP不影响堆栈，但是CALL会同时影响堆栈和EIP</p><p><strong>情况一：跨段不提权</strong></p><p>跨段不提权表示的是段要切换，而访问的代码段对应的段描述符所对应的DPL和当前的CPL是一样的，那么这个时候相比不同的，在段内的CALL指令不同的是其还需要在栈中保存一个原来代码段的段描述符CS</p><p><img src="ProtectMod/07.png" alt="长调用跨段不提权"></p><p>堆栈段先压入调用者CS，再压入返回地址。返回的时候注意使用RETF</p><p><strong>情况二：跨段并提权</strong></p><p>长调用跨段并提权，关键的变化在于提权，在切换CPU特权级别的时候注意，堆栈段也要发生变化，也就是说，要用新的堆栈（每一个特权级对应一个堆栈），现在总结一下，在</p><p><code>CALL CS:EIP</code>这样的指令中，要在新的特权级的堆栈中保存以下内容：返回地址，原来的堆栈段描述符，原来的代码段描述符，调用者的ESP，这样就表现的原来的ESP毫无影响。</p><p><img src="ProtectMod/08.png" alt="跨段并提权"></p><p><strong>为什么说EIP是废弃的？</strong></p><p>对于跨权限调用的时候是要提权的，而提权的时候需要通过一个门，门内信息有一个段选择子，指向真正要跳转的段，门内信息还有真正的偏移，因此，对于<code>CALL CS:EIP</code>来说，其CS有用，EIP没有用，是废弃的，大致过程如下：</p><p>CALL CS:EIP  -&gt; 门描述符（偏移信息+段选择子）-&gt;高权限代码段描述符-&gt;段信息</p><p><strong>总结</strong></p><ul><li>跨段调用的时候，一旦有权限切换，就会切换堆栈</li><li>CS的权限一旦改变，SS的权限也要随着改变，CS和SS的等级必须一样</li><li><strong>JMP FAR只能跳转到同级非一致代码段，但是CALL FAR可以通过调用门提权，提升CPL的权限</strong></li><li><strong>SS与ESP从哪儿来，参见TSS段</strong></li></ul><h3 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h3><p><strong>调用门执行流程</strong></p><p>指令格式 <code>CALL CS:EIP(EIP是废弃的)</code></p><p><strong>执行步骤</strong></p><ol><li>根据CS的值，查GDT表，找到对应的段描述符，这个描述符是调用门</li><li>在调用门描述符中存储另一个代码段的段选择子</li><li>选择子指向的段的BASE+选择子内部包含的偏移地址=真正要执行的地址</li></ol><p><img src="ProtectMod/09.png" alt="门描述符"></p><p>首先调用门P=1，要想“敲门”DPL=11，第12位S=0，暂时不讨论门描述符的参数问题，Param Count = 0，而除了选择子，其也包含了32位的偏移。</p><p><code>0000EC00-00080000</code> 8:1000</p><p><strong>带有参数的调用门</strong></p><p>注意，首先要使用有参数的调用门的时候参数必须要自己先压栈的（压入三环的堆栈）</p><p>先来观察下老师给的实例代码观察下：</p><p><img src="ProtectMod/10.png" alt="示例代码片段1"></p><p><img src="ProtectMod/11.png" alt="示例代码片段1"></p><p>可以看出在通过调用门提权之前，首先PUSH进三环堆栈3个参数，之后进行调用，在执行到裸函数的函数体内已经得到了提权，之后进行了两个相对陌生的指令：</p><p><code>pushad</code>,<code>pushfd</code> 查询相关资料:</p><blockquote><p>pushad: 将所有的32位通用寄存器压入堆栈  pusha:将所有的16位通用寄存器压入堆栈 pushfd:然后将32位标志寄存器EFLAGS压入堆栈  pushf::将的16位标志寄存器EFLAGS压入堆栈 popad:将所有的32位通用寄存器取出堆栈  popa:将所有的16位通用寄存器取出堆栈 popfd:将32位标志寄存器EFLAGS取出堆栈  popf:将16位标志寄存器EFLAGS取出堆栈</p></blockquote><p><code>pushad</code> push进去的寄存器按照顺序为EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX</p><p><code>pushfd</code> push进去的寄存器是32位标志寄存器</p><p>执行玩<code>pushad</code>和<code>pushfd</code>之后的esp下降了4*9=36 -&gt;0x24 </p><p><strong>调用门总结</strong></p><ol><li>当通过门，权限不变的时候，只会push两个值。CS，返回地址新的CS的值由调用门觉得</li><li>当通过门，权限改变的时候，会PUSH四个值。SS，ESP.CS返回地址 新的CS的值由调用门决定。<strong>新的SS和ESP由TSS提供</strong></li><li>通过门调用的时候，要执行哪行代码由调用门决定，但使用RETF返回的时候，由堆栈中压入的值决定，这就是说，进门的时候只能按照指定路线走，出门的时候可以翻墙（可以想去哪就去哪）</li></ol><h3 id="中断门与陷阱门"><a href="#中断门与陷阱门" class="headerlink" title="中断门与陷阱门"></a>中断门与陷阱门</h3><p>Windows没有使用调用门，但是使用了中断门，在windowsAPI当中使用中断门进入0环（现在新的CPU使用快速调用），中断的时候其实相当于在对于汇编就是0xCC(<code>int 3</code>)int 3就是用来执行中断门。中断门查询的表不是GDT表而是IDT表，是中断描述符，与GDT不同的是，IDT都是系统段描述符，并且第一个描述符不是都是0。</p><p>同样，LDT的地址可以通过以下的windbg命令来查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r ldtr</span><br><span class="line">kd&gt; r ldtl</span><br></pre></td></tr></table></figure><p>IDT表有三种描述符：</p><ul><li>中断门描述符</li><li>任务门描述符</li><li>陷阱门描述符</li></ul><p>其中中断门的结构如下：</p><p><img src="ProtectMod/12.png" alt="中断门结构"></p><p><strong>陷阱门</strong></p><p>陷阱门基本上和中断门差不多，关键就在中断门通过修改标志寄存器的IF位来屏蔽中断，而陷阱门不屏蔽</p><h3 id="任务段"><a href="#任务段" class="headerlink" title="任务段"></a>任务段</h3><p>在调用门，中断门与陷阱门中，一旦出现权限的切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须切换。切换的时候，会有新的ESP和SS(CS是由中断门或者调用门)这两个值从哪里来呢？这些都保存到TSS(Task Stage Segment)任务状态段中，<strong>TSS是在内存当中的。</strong></p><p><img src="ProtectMod/13.bmp" alt="任务状态段TSS结构"></p><p>里面保存了所有的通用寄存器以及标志寄存器ELF，以及CR3寄存器（在后面会接触到）以及不同的CPU权限等级对应的SS段选择子的值以及对应的ESP的值。</p><p><strong>TSS注意事项</strong></p><ul><li>不要把TSS与“任务切换”联系在一起</li><li>TSS的意义就在于可以同时换掉“一堆”寄存器</li><li>TSS一共有104字节</li></ul><p><strong>CPU如何找到TSS</strong></p><p><img src="ProtectMod/14.png" alt="Task Register"></p><p><strong>TSS段描述符</strong></p><p>当type的二进制是1001 = 9 的时候，是段描述符，没有加载到段寄存器当中</p><p>当type的二进制是1011 = B 的时候，也是段描述符，表示加载到了段寄存器当中</p><p><strong>TR寄存器的读写</strong></p><ul><li>当TSS段描述符加载到TR寄存器<ul><li>指令：LTR</li><li>说明：<ul><li>用LTR指令去装载的话，仅仅是改变TR寄存器的值（96位），并不会改变TSS</li><li>LTR指令只能在系统层调用（是特权指令）</li><li>加载后TSS 段描述符的状态位会发生变化（Type从9变为b）</li></ul></li></ul></li><li>读TR寄存器<ul><li>指令 STR</li><li>说明：如果用STR去读的话，只读了TR的16位 也就是其选择子</li></ul></li></ul><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保护模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>struts2杂记（一）入门</title>
      <link href="/2018/08/16/struts2-1/"/>
      <url>/2018/08/16/struts2-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Struts2-配置文件"><a href="#Struts2-配置文件" class="headerlink" title="Struts2 配置文件"></a>Struts2 配置文件</h2><h3 id="常量配置"><a href="#常量配置" class="headerlink" title="常量配置"></a>常量配置</h3><p>一些默认配置在导入的<code>struts2-core.jar</code>下有<code>org.apache.struts2</code>包下的default.properties文件，里面包含了一些配置，这些配置包含编码，请求扩展名，想要相应的修改就通过在struts.xml设置常量的方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.name.extension"</span> <span class="attr">value</span>=<span class="string">"action,do,html"</span>&gt;</span><span class="tag">&lt;/<span class="name">constant</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="result子结点"><a href="#result子结点" class="headerlink" title="result子结点"></a>result子结点</h3><p>result子节点通过name与具体的execute方法返回值比对来完成控制器的功能，其中有隐含的type属性代表响应的类型，该默认值在<code>struts-default</code>中被指明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--struts-default.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"struts-default"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">strict-method-invocation</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result-types</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"chain"</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.ActionChainResult"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"dispatcher"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.result.ServletDispatcherResult"</span> <span class="attr">default</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"freemarker"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.views.freemarker.FreemarkerResult"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"httpheader"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.result.HttpHeaderResult"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"redirect"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.result.ServletRedirectResult"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"redirectAction"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.result.ServletActionRedirectResult"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"stream"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.result.StreamResult"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"velocity"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.result.VelocityResult"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"xslt"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.views.xslt.XSLTResult"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"plainText"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.result.PlainTextResult"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result-type</span> <span class="attr">name</span>=<span class="string">"postback"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.result.PostbackResult"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">result-types</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--省略其他的内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面对其中常用的几项做一个总结：</p><ul><li>dispatcher(默认):转发</li><li>redirect:重定向</li><li>redirectAction:重定向到一个Action</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"actionName"</span>&gt;</span>TestAction<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"namespace"</span>&gt;</span>/maoxin<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其指向的包定义为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"testPackage"</span> <span class="attr">namespace</span>=<span class="string">"/maoxin"</span> <span class="attr">extends</span>=<span class="string">"struts-defult"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"testAction"</span> <span class="attr">class</span>=<span class="string">"site.maoxin.TestAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当眼重定向到Action也可以不用这个type</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">type</span>=<span class="string">"redirect"</span>&gt;</span>/maoxin/testAction.action<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>chain:转发到一个Action</p><p>与之上同理，但是需要注意<strong>不能通过dispacter的方式转发到一个Action</strong></p></li></ul><h3 id="通配符映射"><a href="#通配符映射" class="headerlink" title="通配符映射"></a>通配符映射</h3><p>通配符映射是一种方便的写result标签的方式。</p><p><strong>通配符映射规则</strong></p><ul><li>精确的将会覆盖不精确的，就是说明确指定的和通配符方式冲突的时候精确的会有效</li><li>指定的动作不存在，Struts将会尝试讲这个URI与任何一个包含通配符*的动作名进行匹配</li><li>被通配符匹配到的URI字符串可以用｛1｝,{2}来引用</li><li>{0}匹配整个URI</li><li>在Struts找到的带有通配符的匹配不止一个，则按照先后顺序进行匹配</li><li>*可以匹配0个或者多个字符，但是不包括/字符，如果想把/字符包含在内，就需要使用**，如果想要对某个字符进行转义，则需要使用 \</li></ul><p><strong>例子</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"UserAction-*"</span> <span class="attr">class</span>=<span class="string">"site.maoxin.UserAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"&#123;1&#125;-success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"&#123;1&#125;-failed"</span>&gt;</span>/failed.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">namespace</span>=<span class="string">"/test"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"User_add"</span> <span class="attr">class</span>=<span class="string">"site.maoxin.UserAction"</span> <span class="attr">method</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/User.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"User_Delete"</span> <span class="attr">class</span>=<span class="string">"site,maoxin.UserAction"</span> <span class="attr">method</span>=<span class="string">"delete"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/User.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"Book_add"</span> <span class="attr">class</span>=<span class="string">"site.maoxin.BookAction"</span> <span class="attr">method</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/Book.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"Book_delete"</span> <span class="attr">class</span>=<span class="string">"site.maoxin.BookAction"</span> <span class="attr">method</span>=<span class="string">"delete"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/Book.action<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的类型可以通过通配符映射转换为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">namespace</span>=<span class="string">"/test"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"*_*"</span> <span class="attr">class</span>=<span class="string">"site.maoxin.&#123;1&#125;Action"</span> <span class="attr">method</span>=<span class="string">"&#123;2&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span>&gt;</span>/&#123;1&#125;.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态方法调用方式"><a href="#动态方法调用方式" class="headerlink" title="动态方法调用方式"></a>动态方法调用方式</h3><ul><li>首先需要打开动态方法调用：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.enable.DynamicMethodInvocation"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">constant</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>完成对Action的配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"site.maoxin.Test"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认执行的就是execute方法，当在请求参数后面加上!后面跟上方法名就可以</p><h2 id="Action类"><a href="#Action类" class="headerlink" title="Action类"></a>Action类</h2><p>能够处理Struts2的请求的类，通过在struts2配置文件映射的方式来完成请求与相应action之间的关系</p><ul><li>同一个Action可以有多个响应方法</li><li>Action类不同于Servlet，Servlet在内存中标只有一份拷贝，而Action一次请求创建一次</li></ul><h2 id="Action-类处理Web资源"><a href="#Action-类处理Web资源" class="headerlink" title="Action 类处理Web资源"></a>Action 类处理Web资源</h2><p>Web资源也就是：HttpServletRequest，HttpSession，ServletContext等等</p><h3 id="与Servlet-API解耦的方式"><a href="#与Servlet-API解耦的方式" class="headerlink" title="与Servlet API解耦的方式"></a>与Servlet API解耦的方式</h3><p>所谓解耦就是不直接依赖，Struts2提供了以下方式来处理Web资源，解耦方式的缺点是：</p><ul><li>一套新的，Struts2指定的操作方式</li><li>功能不够齐全，不如原生方式强大</li></ul><p>下面是两种解耦的方式：</p><p><strong>使用 Action Context方法</strong></p><p><code>ActionContext</code>对象是在请求经过过滤器的时候生成的，每一个<code>ActionContext</code>通过<code>ThreadLocal</code>容器里面获得的，其中提供了对应的方法来获取。而这一切都是在<code>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</code> 过滤器中完成转换并且装入的。</p><ul><li>获取传入的request参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActionContext ac = ActionContext.getContext();</span><br><span class="line">HttpParameters hps = ac.getParameters();</span><br></pre></td></tr></table></figure><p>其中<code>HttpParameters</code>是实现了<code>Map&lt;String,Parameter&gt;</code>，所以用Map的方式访问，将具体的参数值封装到<code>Parameter</code>这一对象中。通过<code>Parameters.getValues</code>来获取<code>String[]</code>属性的值。</p><ul><li>获取并设置HttpServletContext域对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt;contextMap =ac.getApplication();</span><br><span class="line">contextMap.put(<span class="string">"UserCount"</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>获取并设置HttpServletSession 域对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt;sessionMap = ac.getSession();</span><br><span class="line">sessionMap.put(<span class="string">"UserName"</span>, <span class="string">"Maoxin"</span>);</span><br></pre></td></tr></table></figure><p>Session有一个关闭Session的问题，要操作这个域对象失效就需要提供这个方法，由于其主体还是个Map的功能，所以推断getSession返回的是一个重新实现的Map，里面包含使得Session失效的方法，运行时进行调试，可以看出其本身返回的是<code>SessionMap</code>,查看对应的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (session.getId().intern()) &#123;</span><br><span class="line">            session.invalidate();</span><br><span class="line">            session = <span class="keyword">null</span>;</span><br><span class="line">            entries = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>设置request域属性的值</p><p>需要注意的是<code>ActionContext</code>没有直接提供对应的方法，而之上的所有域对象本身也都是从<code>ActionContext</code>的构造方法内部的构造函数中传入的context对象得到的，而这个对象是<code>OgnlMap</code>类型，里面还有很多对象，因此，如果试图想要获取request域对象的值的话，可以通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; requestMap = (Map&lt;String, Object&gt;) ac.get(<span class="string">"request"</span>);</span><br><span class="line">requestMap.put(<span class="string">"requestDispatcher"</span>, <span class="string">"转发的数据"</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>实现对应的Aware接口</strong></p><p>相对来说比较麻烦：</p><ul><li>首先要实现具体的接口，比如想对Application对象做操作，就要实现ApplicationAware对象接口</li><li>其次要在类中设置要注入对象的引用（依赖注入）</li><li>设置引用的getter和setter方法</li></ul><p><strong>如何选用</strong></p><ul><li>若Action对象包含多个Action方法，多个Action方法使用域对象的Map或者Parameters，则建议使用Aware接口的方式</li></ul><h3 id="与Servlet-API-耦合的方式"><a href="#与Servlet-API-耦合的方式" class="headerlink" title="与Servlet API 耦合的方式"></a>与Servlet API 耦合的方式</h3><p><strong>使用ServletActionContext</strong></p><ul><li><p>获取Request对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletActionContext.getRequest()</span><br></pre></td></tr></table></figure></li><li><p>获取HttpSession对象<code>getRequest().getSession()</code></p></li><li><p>获取ServletContext对象<code>getServletContext()</code></p></li></ul><p><strong>实现ServletXxxAware的方式</strong></p><p>道理同上</p><h2 id="默认的Action类：ActionSupport"><a href="#默认的Action类：ActionSupport" class="headerlink" title="默认的Action类：ActionSupport"></a>默认的Action类：ActionSupport</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">Action</span>, <span class="title">Validateable</span>, <span class="title">ValidationAware</span>, <span class="title">TextProvider</span>, <span class="title">LocaleProvider</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓默认的Action类，其实就是result标签不绑定具体class指向的具体的类，这个具体的类同样在默认继承的包<code>struts-default.xml</code>下被指明，具体如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">default-class-ref</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.ActionSupport"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>打开<code>ActionSupport</code>类查看定义首先实现了众多接口，第一个接口是<code>Action</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUCCESS = <span class="string">"success"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NONE = <span class="string">"none"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR = <span class="string">"error"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT = <span class="string">"input"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGIN = <span class="string">"login"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Validateable 需要手动实现验证</li><li>ValidateAware</li><li>TextProvider</li><li>LocaleProvider</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ClassLoader总结</title>
      <link href="/2018/08/05/ClassLoader%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/05/ClassLoader%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>在学习过程中，一次又一次的遇到类加载器的问题，一次又一次的重新去看，感觉有必要对ClassLoader的知识做一个详细的总结，以便于之后能熟练运用ClassLoader。<br><a id="more"></a></p><h3 id="ClassLoader是什么"><a href="#ClassLoader是什么" class="headerlink" title="ClassLoader是什么"></a>ClassLoader是什么</h3><p>类加载器，<code>.class</code>文件描述的具体信息在加载到JVM之后才能被运行和使用，加载这些文件到虚拟机的过程就是类加载的过程。JAVA本身相较于其他语言的灵活性与Java本身可以在运行期动态加载息息相关。</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><ul><li>类加载过程<ul><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化（Initialization）</li></ul></li><li>类使用过程<ul><li>使用（Using）</li><li>卸载（unloading）</li></ul></li></ul><p><strong>注意：</strong></p><p>类的解析阶段的顺序可能不按照上面自上而下的顺序，在某些情况下是在类的初始化之后开始</p><h3 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h3><ul><li>完成类加载过程中实线类加载的动作</li><li>类加载器和一个类本身一同确定一个类的唯一性<ul><li>判断<code>Class</code>类对象是否相等，主要包括：</li><li><code>Class</code>类对象的<code>equals()</code>方法</li><li>对象与Class类之间的<code>instanceof</code>关键字或者是<code>isInstance()</code>方法</li><li><code>Class</code>对象的<code>isAssignableForm()</code>方法（PS：Assignable 可分配的）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深入理解Java虚拟机代码清单7-7</span></span><br><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader myLoader  = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt;loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>)</span><br><span class="line">                        +<span class="string">".class"</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span>(is==<span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[]b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name,b,<span class="number">0</span>,b.length);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">"demo.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> demo.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*运行结果：</span></span><br><span class="line"><span class="comment">*class demo.ClassLoaderTest</span></span><br><span class="line"><span class="comment">*false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>上面代码注意的点是其重写的loadClass方法不满足双亲委派模型，所以能够出现不同的不同加载器加载的同名Class</li></ul><h3 id="Java的ClassLoader-分类"><a href="#Java的ClassLoader-分类" class="headerlink" title="Java的ClassLoader 分类"></a>Java的ClassLoader 分类</h3><ul><li><p>从Java虚拟机的角度而言，只存在两种ClassLoader</p><ul><li>启动类加载器（BootStrap ClassLoader）<ul><li>使用C++实现，是Java虚拟机的一部分</li><li>在Java程序中获取不到，会返回为null</li></ul></li><li>其他的类加载器<ul><li>独立于Java虚拟机之外</li><li>继承子抽象类<code>java.lang.ClassLoader</code></li><li>用Java语言描述</li></ul></li></ul></li><li><p>从开发人员角度</p><ul><li><p>启动类加载器（BootStrap ClassLoader）</p><ul><li>负责加载<code>%JAVA_HOME%\lib</code>目录中的，或者被<code>-Xbootclasspath</code>指定的路径</li><li>可以通过<code>System.getProperty(&quot;sun.boot.class.path&quot;)</code>查看路径</li></ul></li><li><p>扩展类加载器（Extension ClassLoader）</p><ul><li>由<code>sun.misc.Launcher$ExtClassLoader</code>实现</li><li>负责加载<code>%JAVA_HOME%\lib\ext</code>目录的类库</li><li><p>可以通过<code>System.getProperty(&quot;java.ext.dirs&quot;)</code>查看</p></li><li><p>可以通过参数制定路径</p></li></ul></li><li><p>应用程序类加载器（Application ClassLoader）</p><ul><li>由<code>sun.misc.Launcher$AppClassLoader</code>实现</li><li>负责加载用户路径上制定的类库</li><li>可以通过<code>System.getProperty(&quot;java.class.path&quot;)</code>查看</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看具体的路径</span></span><br><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String paths = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line"><span class="keyword">if</span>(paths!=<span class="keyword">null</span>) &#123;</span><br><span class="line">StringTokenizer st = <span class="keyword">new</span> StringTokenizer(paths, File.pathSeparator);</span><br><span class="line"><span class="keyword">int</span> count = st.countTokens();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">System.out.println(st.nextToken());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>双亲委派模型并不难，用文字解释就是：</p><blockquote><p>如果一个类加载器其收到类加载请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器返回自己无法完成这个加载请求的时候，子类才加载。–《深入理解Java虚拟机》</p></blockquote><p>上面的解释很标准，但是需要注意不是一拿到一个类加载请求就去加载，而是先在缓存中查看是否已经加载过了。</p><p>上述这些操作，在<code>ClassLoader</code>的<code>loadClass()</code>方法中定义，查看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检测是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//父加载器没有找到，则调用findclass</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                <span class="comment">//调用resolveClass()</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="为什么使用双亲委派？"><a href="#为什么使用双亲委派？" class="headerlink" title="为什么使用双亲委派？"></a>为什么使用双亲委派？</h3><ul><li>上面谈到，对JVM而言只有两种类加载器，一个是BootStrap ClassLoader，一个是Java自定义的，首先之所以分成两个正是满足Java语言在运行是时动态加载的需求。</li><li>如果不使用双亲委派机制，重要的基础类被恶意修改再加载到JVM引起混淆引发安全问题</li></ul><h3 id="违反双亲委派模型"><a href="#违反双亲委派模型" class="headerlink" title="违反双亲委派模型"></a>违反双亲委派模型</h3><p>首先需要明白，双亲委派模型的缺陷：（感谢知识星球（码农翻身）球友的解释）</p><p>补充知识：<strong>类加载器的命名空间</strong> </p><p>子能看见父，父却不能看见子，这就是双亲委派的弊端，<strong>当前类引用了其他类，当前类的类加载器就负责就在加载那些引用类</strong></p><ul><li>例如JDBC的DriverManager，这个类是由根加载器加载的，它里面需要调用厂商的实现类（mysql），但是mysql的jar包不在rt.jar 所在的目录里，一般都是放在项目的lib文件夹里面，根据JVM的加载规则根就没办法去加载mysql的驱动，压根就看不见实现类</li><li>在Thread类有个成员叫做classLoader，在<code>sun.misc.Launcher</code>类中设置该成员，其中Ext和AppClassLoader都是在这个类初始化的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath =</span><br><span class="line">        System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension class loader</span></span><br><span class="line">        ClassLoader extcl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">"Could not create extension class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">"Could not create application class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置AppClassLoader为线程上下文类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Returns the class loader used to launch the main application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The class loader used for loading installed extensions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The class loader used for loading from java.class.path.</span></span><br><span class="line"><span class="comment">     * runs in a restricted security context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li><code>loadClass(String className,boolean isInitialized)</code>的第二个参数设置为false可以提高类加载的性能</li></ul><h3 id="类加载器的应用"><a href="#类加载器的应用" class="headerlink" title="类加载器的应用"></a>类加载器的应用</h3><p>注意事项：</p><p>  如果想维持双亲委派模型，我们就不应该去覆盖<code>loadClass()</code>方法,如果仅仅是想写自己的加载逻辑，应该覆盖<code>findClass()</code>完成记载逻辑，这样就可以保证双亲委派,到最后调用<code>defineClass()</code>完成相关的操作。</p><ul><li>双亲委派模型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderA</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassLoaderA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">//自己的findClass逻辑，如果自己的发生异常就交给默认的findClass去处理</span></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return defineClass(b, off, len);</span></span><br><span class="line"><span class="comment">//&#125;catch(..) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>违反双亲委派模型</p><p> 见第一个代码片段</p></li><li><p>加载一个指定包下的所有类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ClassHalper,代码源于《架构探险-从零开始写JavaWeb框架》</span></span><br><span class="line"><span class="comment">//类原型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtil</span> </span>&#123;</span><br><span class="line"><span class="comment">//ClassUtil需要的类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用该函数加载package下面的Class文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className,<span class="keyword">boolean</span> isInitailized)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取Package下所有的Class文件并加载到Set中去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClassSet(String packageName)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体实现</span></span><br><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtil</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Class.forName的形式来加载类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className,<span class="keyword">boolean</span> isInitailized)&#123;</span><br><span class="line">Class&lt;?&gt; cls;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">cls = Class.forName(className,isInitailized,getClassLoader());</span><br><span class="line">&#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClassSet(String packageName)&#123;</span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = getClassLoader().getResources(packageName.replace(<span class="string">'.'</span>, <span class="string">'/'</span>));</span><br><span class="line"><span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line"><span class="keyword">if</span>(url!=<span class="keyword">null</span>) &#123;</span><br><span class="line">String protocal = url.getProtocol();</span><br><span class="line"><span class="comment">//如果协议名称是file的时候就将%20转义为空格</span></span><br><span class="line"><span class="keyword">if</span>(protocal.equals(<span class="string">"file"</span>))&#123;</span><br><span class="line">String packagePath = url.getPath().replaceAll(<span class="string">"%20"</span>,<span class="string">""</span>);</span><br><span class="line"><span class="comment">//调用真正执行递归添加类的方法</span></span><br><span class="line">addClass(classSet,packagePath,packageName);</span><br><span class="line"><span class="comment">//如果协议名称是jar的时候就用jar特有的方式读取</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(protocal.equals(<span class="string">"jar"</span>)) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">"get class set failure"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> classSet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行根据包下路径</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addClass</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; classSet,String packagePath,String packageName)</span> </span>&#123;</span><br><span class="line">File[] files = <span class="keyword">new</span> File(packagePath).listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果是目录，或者是以class为末尾的文件就返回true</span></span><br><span class="line"><span class="keyword">return</span> (file.isFile()&amp;&amp;file.getName().endsWith(<span class="string">".class"</span>)||file.isDirectory());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(File file:files) &#123;</span><br><span class="line"><span class="comment">//如果是一个文件，就直接做处理将XXX.class的名字解析出来,组合成全类名之后加载</span></span><br><span class="line">String fileName = file.getName();</span><br><span class="line"><span class="keyword">if</span>(file.isFile()) &#123;</span><br><span class="line">String className = fileName.substring(<span class="number">0</span>, fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">doAddClass(classSet,className);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果是一个目录就进一步组合成进一步目录</span></span><br><span class="line">String subPackagePath = fileName;</span><br><span class="line">subPackagePath = packagePath+<span class="string">"/"</span>+subPackagePath;</span><br><span class="line"><span class="comment">//这个时候的全类名就深入了一步</span></span><br><span class="line">String subPackageName = packageName+<span class="string">"."</span>+fileName;</span><br><span class="line"><span class="comment">//递归的进行添加</span></span><br><span class="line">addClass(classSet,subPackagePath,subPackageName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加到具体的Set中去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doAddClass</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; classSet,String className)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; cls = loadClass(className,<span class="keyword">false</span>);</span><br><span class="line">classSet.add(cls);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类文件的加密与解密</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对ClassLoader的学习暂时到这里，后续会不断的补充。</p><blockquote><p>参考文章</p><p><a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/54973413</a> 超详细java中的ClassLoader详解</p><p><a href="https://blog.csdn.net/zhangzeyuaaa/article/details/42499839" target="_blank" rel="noopener">https://blog.csdn.net/zhangzeyuaaa/article/details/42499839</a>  全盘负责和双亲委托</p><p>《码农翻身》 刘欣  电子工业出版社 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> ClassLoader </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蛋疼的JavaScript(一)：作用域与闭包</title>
      <link href="/2018/08/01/js-1/"/>
      <url>/2018/08/01/js-1/</url>
      
        <content type="html"><![CDATA[<p>在使用JavaScript的时候各种奇葩的结果真的让人头大，于是系统的学习一下JavaScript的一些知识。深入了解下JavaScript。（注：以下均为浅尝则止）<br><a id="more"></a></p><h2 id="JavaScript-的坑"><a href="#JavaScript-的坑" class="headerlink" title="JavaScript 的坑"></a>JavaScript 的坑</h2><p>创建变量的时候，我们一般用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>JS引擎在看到上述代码的时候会做两步操作</p><ul><li>创建符号a对应的内存空间（解释阶段）</li><li>将基本类型2放置到a对应的内存空间当中（执行阶段）</li></ul><p>也就是说var 带有声明变量的作用，如果有以下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>JS解释器先发现了符号a，试图去找a的内存地址在哪，没有找到，它不会返回给程序员什么错误，而是自作主张在顶层作用域内创建了a的符号，再执行a=2的操作，其他语言不是这样的，不了解这个过程使用JS就是噩梦的开始。。(处理不好就会导致符号的泄漏)</p><p>注意到上面的a都是被赋值的对象。如果a作为右值呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = a;</span><br></pre></td></tr></table></figure><p>这个时候JS引擎就不能自作主张的生成全局变量a，因为a的值不确定，这个时候它查找a符号没有找到，就乖乖的告诉你<code>a is not defined</code> </p><p>这是作为左值和右值的区别，我们应该将左和右概念更泛化一下。</p><ul><li>左值就是符号被赋值的过程</li><li>右值就是符号内容取得的过程</li></ul><p>那么很快就能反应过来函数调用的函数参数的传入是一个符号作为右值传入的过程，这就够了。</p><p>换个角度讲，作为左值符号未声明的时候自动创建也可以叫一个特性，如果我们指定其在哪个作用域中查找符号，这样就可以动态的添加属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A=&#123;</span><br><span class="line">    name:<span class="string">"Maoxin"</span></span><br><span class="line">&#125;;</span><br><span class="line">A.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.dir(A)</span><br></pre></td></tr></table></figure><h3 id="符号作用域"><a href="#符号作用域" class="headerlink" title="符号作用域"></a>符号作用域</h3><p>前面就提到全局作用域，这相当于一个全局变量，而有其他语言经验的我们也知道局部变量。在重名情况下符号是就近原则，内部的能访问到外部的定义的变量，而这一切的原因其实就是压栈，函数调用的时候栈的提升，之前的变量在栈底，新的局部变量在栈提升的这部分中，所以子函数作用域能够访问到外部的作用域是合情合理的，这JavaScript也一样，但是唯一不一样的是对类似if分支，循环等等的处理。我们在使用类似C/C++/Java中，这么用是不可以的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);<span class="comment">//错！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为循环这个东西内部创建的变量就像一个函数的作用域一样，但是JS不是这样的。在JS中允许如下代码是可以的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br></pre></td></tr></table></figure><p>原因在于循环变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是创建在这个块作用域之外的。。</p><p>这样显然对于从其他语言迁移过来的很不好使，怎么创建一个就像之前语言的变量一样的东西呢？其实可以使用ES6引入的let</p><h3 id="let-const-与-var"><a href="#let-const-与-var" class="headerlink" title="let const 与 var"></a>let const 与 var</h3><ul><li>let 可以创建一个块作用域的变量</li><li>const 也是块作用域的变量，不过就像其他语言的const一样，赋值之后不可修改</li><li>var 。。略</li></ul><p>等下，let是ES6引入的，难道，之前用JS要时时刻刻被这个问题困扰？他们是怎么解决的。</p><p>下面是一个实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.write(i+<span class="string">'&lt;br&gt;'</span>)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个实例，刚开始会和惊讶，怎么输出的都是6？</p><p>只要知道setTimeout是异步的，不会立即执行</p><p>，在结合上面的内容就清楚了原因。原因就是，for都执行完了之后i=6，那么我们怎么让他正常一些？问题的根源就在于其i的作用域，我们<strong>引用了外部的i</strong>，这个i的值已经是6了。JS和其他语言的不同之处就是在块作用域的表现不同。函数作用域还是可以的，于是我们可以尝试这么改进，每次传入的i值都将其拷贝一份放在一个更小的作用域中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> j = i;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.write(j+<span class="string">'&lt;br&gt;'</span>)</span><br><span class="line">        &#125;,i*<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>猛地看挺奇怪的，但要是说明白了（函数）(参数)这种形式就是将一个参数传入即将执行的函数中去就会好明白一些，我们就是强行再加了一个函数作用域将这个i当前的值保护起来放置在j中。</p><p>当然现在不用这么麻烦：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.write(i+<span class="string">'&lt;br&gt;'</span>)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们之前说了很多都是作用域从大到小，内部的能看到外部的。但是回顾上面的过程，我们发现一个很有趣的现象，尽管块内的函数已经执行完了，setTimeout函数却记得它内部需要引用外部的值。这表示那些看似执行完的块的某些值并没有随着执行完毕而被垃圾回收，这就是闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p>当函数可以记住并访问所在词法作用域的时，就产生了闭包，及时函数是在当前词法作用域之外进行的。–《你不知道的JavaScript上》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java验证码图片创建</title>
      <link href="/2018/07/29/Java%E9%AA%8C%E8%AF%81%E7%A0%81%E5%9B%BE%E7%89%87%E5%88%9B%E5%BB%BA/"/>
      <url>/2018/07/29/Java%E9%AA%8C%E8%AF%81%E7%A0%81%E5%9B%BE%E7%89%87%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>最近需要实现一个验证码生成工具类，之前完全没有接触过Java图形方面的知识，临时上网查阅资料，总结下自己学到的内容，到最后学习实现一个自己可以用的上的工具类,所有参阅的资料都在文末的引用部分。<br><a id="more"></a></p><h3 id="java-awt下的Image类与BufferedImage"><a href="#java-awt下的Image类与BufferedImage" class="headerlink" title="java.awt下的Image类与BufferedImage"></a>java.awt下的Image类与BufferedImage</h3><ul><li>java.awt.Image ：抽象类Image是表示图形图像的所有类的超类</li><li>java.awt.image.BufferedImage 是Image的子类，描述具有可访问图像数据缓冲区的Image</li></ul><p>总得来说，Image通常用来获取图片，BufferedImage做图片修改操作如大小变换等 </p><h3 id="Graphics-与Graphics2D"><a href="#Graphics-与Graphics2D" class="headerlink" title="Graphics 与Graphics2D"></a>Graphics 与Graphics2D</h3><p>Graphics类是所有的图像上下文类的抽象基类，这些图形上下文允许应用程序绘制在各种设备上实现的组件以及屏幕外的图像上。 </p><p>图形对象封装了Java支持的基本呈现操作所需的状态信息。</p><p>Graphics2D 类扩展 Graphics 类，以提供对几何形状、坐标转换、颜色管理和文本布局更为复杂的控制。它是用于在 Java(tm) 平台上呈现二维形状、文本和图像的基础类</p><p><strong>获取Graphics对象</strong></p><ul><li>通过继承BufferedImage对象实例获得：BufferedImage.createGraphics()/getGraphics();</li><li>继承Swing组建的paintComponent(Graphics g)方法</li></ul><p><strong>转型为Graphics2D 对象</strong></p><p>Graphics2D可以通过<code>setRenderingHint(RenderingHints.key,RenderingHints.value)</code>方法是否设置图形反锯齿、文字反锯齿、设置图像的插入方法、绘制方法、是否支持抖动等属性。 </p><p><strong>stroke 属性</strong></p><p>stroke属性用于控制线条的宽度、笔形样式、线段连接方式或短划线图案。</p><p>如果我们要设置stroke属性，则应当先创建Stroke引用的对象，但由于Stroke为接口类型，所以我们要创建对象，可以创建其已知实现类BasicStroke的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g2d.setStroke(<span class="keyword">new</span> BasicStroke(<span class="keyword">float</span> width,<span class="keyword">int</span> cap,<span class="keyword">int</span> join));</span><br></pre></td></tr></table></figure><ul><li>width 笔画的宽度</li><li>cap 端点的样式</li><li>join是两线段交汇的连接方式</li></ul><p>（具体详细解释请查看文末引用原博主博客）</p><p><strong>clip属性</strong></p><p>clip属性用于实现剪裁效果。设置剪裁属性可调用如下方法确定剪裁区的Shape</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setClip</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br></pre></td></tr></table></figure><p><strong>paint属性</strong></p><p>paint属性控制填充效果，通过调用setPaint()方法设置： 其函数传入对应的Paint对象</p><p>注意：</p><ul><li>paint可以同时作用在边线和填充上，可以是单色，渐变和图案，任何paint都需要实现java.awt.Paint接口 </li><li>因为Color类实现了java.awt.Paint接口，所有的Color对象都是Paint对象。 </li></ul><p>一些特殊的Paint类：</p><ul><li><p>GradientPaint类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GradientPaint</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> y1, Color color1,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">float</span> x2, <span class="keyword">float</span> y2, Color color2)</span></span></span><br></pre></td></tr></table></figure><p>这个类用颜色渐变填充一个区域，构造函数指定定比例和颜色。图形引擎会从第一个点到第二个点之间线性变化两个颜色：从(x1,y1)到(x2,y2)颜色从c1渐变到c2。我们还可以指定颜色图案是否允许重复。 </p></li><li><p>TexturePaint类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TexturePaint</span><span class="params">(BufferedImage txtr, Rectangle2D anchor)</span></span></span><br></pre></td></tr></table></figure><p>这个类平铺一个图像来填充图形，构造函数接收一个java.awt.image.BufferedImage和一个Rectangle2D，把图像影射到矩形里，然后平铺矩形。</p><p>我们可以先创建GradientPaint类或TexturePaint类的对象，再调用Graphics2D的setPaint()方法设置填充效果。</p></li></ul><p><strong>Font属性</strong></p><p>所有的文本都使用能表现文字的样式图形渲染。当前的字体决定了字体的形状。使用继承自java.awt.Graphics的getFont()方法和setFont()方法来操纵字体。 </p><p><strong>Transform属性</strong></p><p>transform属性用来实现常用的图形平移、缩放和斜切等变换操作。我们可以调用setTransform()来设置transform属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setTransform</span><span class="params">(AffineTransform Tx)</span></span></span><br></pre></td></tr></table></figure><p>该方法需要一个AffineTransform对象的参数，所以首先创建AffineTransform对象，然后调用setTransform()方法设置transform属性。最后，用具有指定属性的Graphics2D对象绘制图形。</p><p>创建AffineTransform对象的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旋转变换，旋转theta弧度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AffineTransform <span class="title">getRotateInstance</span><span class="params">(<span class="keyword">double</span> theta)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 绕旋转中心(anchorx, anchory)旋转</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AffineTransform <span class="title">getRotateInstance</span><span class="params">(<span class="keyword">double</span> theta, <span class="keyword">double</span> anchorx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">double</span> anchory)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 缩放变换，x和y方向分别按sx,sy比例变换</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AffineTransform <span class="title">getScaleInstance</span><span class="params">(<span class="keyword">double</span> sx, <span class="keyword">double</span> sy)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 错切变换，shx和shy指定斜拉度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AffineTransform <span class="title">getShearInstance</span><span class="params">(<span class="keyword">double</span> shx, <span class="keyword">double</span> shy)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 平移变换，tx和ty表示x和y方向平移距离</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AffineTransform <span class="title">getTranslateInstance</span><span class="params">(<span class="keyword">double</span> tx, <span class="keyword">double</span> ty)</span></span></span><br></pre></td></tr></table></figure><p>当然，也可以先创建一个没有transform属性的AffineTransform对象，然后用以下方法指定图形平移、旋转、缩放变换属性： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将图形在x轴方向平移tx像素，y轴方向平移ty像素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">translate</span><span class="params">(<span class="keyword">double</span> tx, <span class="keyword">double</span> ty)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 旋转theta弧度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">double</span> theta)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 图形以点(anchorx, anchory)为轴点，旋转theta弧度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">double</span> theta, <span class="keyword">double</span> anchorx, <span class="keyword">double</span> anchory)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 图形在x轴方向缩放sx倍，纵向缩放sy倍</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scale</span><span class="params">(<span class="keyword">double</span> sx, <span class="keyword">double</span> sy)</span></span></span><br></pre></td></tr></table></figure><p><strong>composit属性</strong></p><p>composit属性设置图形重叠区域的效果。可通过调用setComposite()方法设置该属性： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setComposite</span><span class="params">(Composite comp)</span></span></span><br></pre></td></tr></table></figure><p>例如先用方法AlphaComposite.getInstance(int rule, float alpha)得到AlphaComposite对象，再通过setComposite()方法设置混合效果。AlphaComposite在图形和图像中实现混合和透明效果，Alpha值的范围为0.0f(完全透明)-1.0f(完全不透明)。 </p><hr><h3 id="使用Graphics2D绘图"><a href="#使用Graphics2D绘图" class="headerlink" title="使用Graphics2D绘图"></a>使用Graphics2D绘图</h3><p>Graphics2D类仍然保留Graphics类的绘图方法，同时增加了许多新方法。新方法将几何图形(线段、圆等)作为一个对象来绘制。在java.awt.geom包中声明的一系列类，分别用于创建各种身体图形对象。常用的主要有：</p><ul><li>Line2D - 线段类</li><li>RoundRectangle2D - 圆角矩形类</li><li>Ellipse2D - 椭圆类</li><li>Arc2D - 圆弧类</li><li>QuadCurve2D - 二次曲线类</li><li>CubicCurve2D - 三次曲线类。</li></ul><p>要用Graphics2D类的新方法画一个图形。先在重画方法paintComponent()或paint()中，把参数对象g强制转换成Graphics2D对象；然后，用上述图形类提供的静态内部类构造方法Double()或Float()创建该图形的对象；最后，以图形对象为参数调用Graphics2D对象的draw()方法绘制这个图形。</p><p>画一条线段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 画线 */</span></span><br><span class="line">Stroke s = <span class="keyword">new</span> BasicStroke(<span class="number">20</span>, BasicStroke.CAP_ROUND, BasicStroke.JOIN_MITER);</span><br><span class="line">g2d.setStroke(s);       </span><br><span class="line">Line2D line = <span class="keyword">new</span> Line2D.Double(<span class="number">30</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">g2d.draw(line);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>画一个圆角矩形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 画圆角矩形 */</span></span><br><span class="line">g2d.setColor(Color.BLUE);</span><br><span class="line">RoundRectangle2D rect = <span class="keyword">new</span> RoundRectangle2D.Double(<span class="number">100</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">50</span>,</span><br><span class="line">            <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">g2d.draw(rect);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>画一个旋转一定角度的矩形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 画旋转一定角度的矩形 */</span></span><br><span class="line">Rectangle2D rect2 = <span class="keyword">new</span> Rectangle2D.Double(<span class="number">60</span>, <span class="number">160</span>, <span class="number">60</span>, <span class="number">90</span>);</span><br><span class="line">AffineTransform transform = <span class="keyword">new</span> AffineTransform();</span><br><span class="line">transform.rotate(<span class="number">45</span> * Math.PI / <span class="number">180</span>, <span class="number">90</span>, <span class="number">200</span>); <span class="comment">// 围绕(90,200)点旋转图形45度</span></span><br><span class="line">g2d.setTransform(transform);</span><br><span class="line">g2d.draw(rect2);</span><br></pre></td></tr></table></figure><p><strong>消除锯齿</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line">g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_DEFAULT);</span><br></pre></td></tr></table></figure></p><p>注意：绘制完图像后记得用dispose()方法释放资源</p><h3 id="验证码生成的实现"><a href="#验证码生成的实现" class="headerlink" title="验证码生成的实现"></a>验证码生成的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证码原实现博主是CSDN的The...Exception的大佬，在这里做了简单的修改以及添加了大量的注释来巩固上面的知识。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics2D;</span><br><span class="line"><span class="keyword">import</span> java.awt.LinearGradientPaint;</span><br><span class="line"><span class="keyword">import</span> java.awt.Paint;</span><br><span class="line"><span class="keyword">import</span> java.awt.RenderingHints;</span><br><span class="line"><span class="keyword">import</span> java.awt.geom.AffineTransform;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyCodeUtils</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用到Algerian字体，系统里没有的话需要安装字体，字体只显示大写，去掉了1,0,i,o几个容易混淆的字符</span></span><br><span class="line"><span class="comment">//这个也是默认的字符源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERIFY_CODES = <span class="string">"23456789ABCDEFGHJKLMNPQRSTUVWXYZ"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用系统默认字符源生成验证码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> verifySize验证码长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateVerifyCode</span><span class="params">(<span class="keyword">int</span> verifySize)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> generateVerifyCode(verifySize, VERIFY_CODES);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定源生成验证码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> verifySize验证码长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sources验证码字符源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateVerifyCode</span><span class="params">(<span class="keyword">int</span> verifySize, String sources)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sources == <span class="keyword">null</span> || sources.length() == <span class="number">0</span>)&#123;</span><br><span class="line">sources = VERIFY_CODES;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> codesLen = sources.length();</span><br><span class="line"><span class="comment">//用当前时间作为随机生成种子在一定程度上达到了真随机</span></span><br><span class="line">Random rand = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"><span class="comment">//使用StringBuilder做到不断的附加随机字符</span></span><br><span class="line">StringBuilder verifyCode = <span class="keyword">new</span> StringBuilder(verifySize);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; verifySize; i++)&#123;</span><br><span class="line">verifyCode.append(sources.charAt(rand.nextInt(codesLen-<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> verifyCode.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成随机验证码文件,并返回验证码值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outputFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> verifySize</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">outputVerifyImage</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, File outputFile, <span class="keyword">int</span> verifySize)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">String verifyCode = generateVerifyCode(verifySize);</span><br><span class="line">outputImage(w, h, outputFile, verifyCode);</span><br><span class="line"><span class="keyword">return</span> verifyCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出随机验证码图片流,并返回验证码值</span></span><br><span class="line"><span class="comment"> * 先生成具体的随机验证码，再去生成对应的图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> os</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> verifySize</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">outputVerifyImage</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, OutputStream os, <span class="keyword">int</span> verifySize)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">String verifyCode = generateVerifyCode(verifySize);</span><br><span class="line">outputImage(w, h, os, verifyCode);</span><br><span class="line"><span class="keyword">return</span> verifyCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成指定验证码图像文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outputFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//生成图片保存的位置,抛出异常通知上层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outputImage</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, File outputFile, String code)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//没有输出文件的情况下先退出</span></span><br><span class="line"><span class="keyword">if</span>(outputFile == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于File中的路径直接使用mkDir生成的都是文件夹，因此需要先找到父文件夹先判断生成文件夹</span></span><br><span class="line">File dir = outputFile.getParentFile();</span><br><span class="line"><span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">dir.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再去生成具体的文件</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">outputFile.createNewFile();</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(outputFile);</span><br><span class="line">outputImage(w, h, fos, code);</span><br><span class="line">fos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出指定验证码图片流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> os</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outputImage</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, OutputStream os, String code)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="keyword">int</span> verifySize = code.length();</span><br><span class="line"><span class="comment">//创建BufferedImage</span></span><br><span class="line">BufferedImage image = <span class="keyword">new</span> BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//获取Graphics2D对象</span></span><br><span class="line">Graphics2D g2 = image.createGraphics();</span><br><span class="line"><span class="comment">//设置抗锯齿</span></span><br><span class="line">g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line"><span class="comment">//Colors数组</span></span><br><span class="line">Color[] colors = <span class="keyword">new</span> Color[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//ColorSpaces数组</span></span><br><span class="line">Color[] colorSpaces = <span class="keyword">new</span> Color[] &#123; Color.WHITE, Color.CYAN,</span><br><span class="line">Color.GRAY, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,</span><br><span class="line">Color.PINK, Color.YELLOW &#125;;</span><br><span class="line"><span class="keyword">float</span>[] fractions = <span class="keyword">new</span> <span class="keyword">float</span>[colors.length];</span><br><span class="line"><span class="comment">//随机从ColorSpace找到五种颜色和五个</span></span><br><span class="line"><span class="comment">//TODO </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colors.length; i++)&#123;</span><br><span class="line">colors[i] = colorSpaces[rand.nextInt(colorSpaces.length)];</span><br><span class="line">fractions[i] = rand.nextFloat();</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(fractions);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制背景，之后只保留一部分，所以是绘制边框</span></span><br><span class="line">g2.setColor(Color.GRAY);<span class="comment">// 设置边框色</span></span><br><span class="line">g2.fillRect(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line"></span><br><span class="line">Color c = getRandColor(<span class="number">200</span>, <span class="number">250</span>);</span><br><span class="line">g2.setColor(c);<span class="comment">// 设置背景色</span></span><br><span class="line">g2.fillRect(<span class="number">0</span>, <span class="number">2</span>, w, h-<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制干扰线</span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">g2.setColor(getRandColor(<span class="number">160</span>, <span class="number">200</span>));<span class="comment">// 设置线条的颜色</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = random.nextInt(w - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> y = random.nextInt(h - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> xl = random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> yl = random.nextInt(<span class="number">12</span>) + <span class="number">1</span>;</span><br><span class="line">g2.drawLine(x, y, x + xl + <span class="number">40</span>, y + yl + <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加噪点</span></span><br><span class="line"><span class="keyword">float</span> yawpRate = <span class="number">0.05f</span>;<span class="comment">// 噪声率</span></span><br><span class="line"><span class="keyword">int</span> area = (<span class="keyword">int</span>) (yawpRate * w * h);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; area; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = random.nextInt(w);</span><br><span class="line"><span class="keyword">int</span> y = random.nextInt(h);</span><br><span class="line"><span class="keyword">int</span> rgb = getRandomIntColor();</span><br><span class="line">image.setRGB(x, y, rgb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shear(g2, w, h, c);<span class="comment">// 使图片扭曲</span></span><br><span class="line"><span class="comment">//设置字体颜色</span></span><br><span class="line">g2.setColor(getRandColor(<span class="number">100</span>, <span class="number">160</span>));</span><br><span class="line"><span class="keyword">int</span> fontSize = h-<span class="number">4</span>;</span><br><span class="line">Font font = <span class="keyword">new</span> Font(<span class="string">"Algerian"</span>, Font.ITALIC, fontSize);</span><br><span class="line">g2.setFont(font);</span><br><span class="line"><span class="keyword">char</span>[] chars = code.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; verifySize; i++)&#123;</span><br><span class="line">AffineTransform affine = <span class="keyword">new</span> AffineTransform();</span><br><span class="line">affine.setToRotation(Math.PI / <span class="number">4</span> * rand.nextDouble() * (rand.nextBoolean() ? <span class="number">1</span> : -<span class="number">1</span>), (w / verifySize) * i + fontSize/<span class="number">2</span>, h/<span class="number">2</span>);</span><br><span class="line">g2.setTransform(affine);</span><br><span class="line">g2.drawChars(chars, i, <span class="number">1</span>, ((w-<span class="number">10</span>) / verifySize) * i + <span class="number">5</span>, h/<span class="number">2</span> + fontSize/<span class="number">2</span> - <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除</span></span><br><span class="line">g2.dispose();</span><br><span class="line">ImageIO.write(image, <span class="string">"jpg"</span>, os);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成一个随机的颜色，在bc-fc是其RGB分量的范围</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Color <span class="title">getRandColor</span><span class="params">(<span class="keyword">int</span> fc, <span class="keyword">int</span> bc)</span> </span>&#123;</span><br><span class="line"><span class="comment">//对输入参数进行过滤</span></span><br><span class="line"><span class="keyword">if</span> (fc &gt; <span class="number">255</span>)</span><br><span class="line">fc = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">if</span> (bc &gt; <span class="number">255</span>)</span><br><span class="line">bc = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> r = fc + random.nextInt(bc - fc);</span><br><span class="line"><span class="keyword">int</span> g = fc + random.nextInt(bc - fc);</span><br><span class="line"><span class="keyword">int</span> b = fc + random.nextInt(bc - fc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Color(r, g, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用int类型值去保存RGB三个分量，这里用到左移，之后用逻辑加进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomIntColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] rgb = getRandomRgb();</span><br><span class="line"><span class="keyword">int</span> color = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c : rgb) &#123;</span><br><span class="line">color = color &lt;&lt; <span class="number">8</span>;</span><br><span class="line">color = color | c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成随机颜色，RGB分量由数组保存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getRandomRgb() &#123;</span><br><span class="line"><span class="keyword">int</span>[] rgb = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">rgb[i] = random.nextInt(<span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rgb;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shear</span><span class="params">(Graphics g, <span class="keyword">int</span> w1, <span class="keyword">int</span> h1, Color color)</span> </span>&#123;</span><br><span class="line">shearX(g, w1, h1, color);</span><br><span class="line">shearY(g, w1, h1, color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shearX</span><span class="params">(Graphics g, <span class="keyword">int</span> w1, <span class="keyword">int</span> h1, Color color)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> period = random.nextInt(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">boolean</span> borderGap = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> frames = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> phase = random.nextInt(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h1; i++) &#123;</span><br><span class="line"><span class="keyword">double</span> d = (<span class="keyword">double</span>) (period &gt;&gt; <span class="number">1</span>)</span><br><span class="line">* Math.sin((<span class="keyword">double</span>) i / (<span class="keyword">double</span>) period</span><br><span class="line">+ (<span class="number">6.2831853071795862</span>D * (<span class="keyword">double</span>) phase)</span><br><span class="line">/ (<span class="keyword">double</span>) frames);</span><br><span class="line">g.copyArea(<span class="number">0</span>, i, w1, <span class="number">1</span>, (<span class="keyword">int</span>) d, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (borderGap) &#123;</span><br><span class="line">g.setColor(color);</span><br><span class="line">g.drawLine((<span class="keyword">int</span>) d, i, <span class="number">0</span>, i);</span><br><span class="line">g.drawLine((<span class="keyword">int</span>) d + w1, i, w1, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shearY</span><span class="params">(Graphics g, <span class="keyword">int</span> w1, <span class="keyword">int</span> h1, Color color)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> period = random.nextInt(<span class="number">40</span>) + <span class="number">10</span>; <span class="comment">// 50;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">boolean</span> borderGap = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> frames = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> phase = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w1; i++) &#123;</span><br><span class="line"><span class="keyword">double</span> d = (<span class="keyword">double</span>) (period &gt;&gt; <span class="number">1</span>)</span><br><span class="line">* Math.sin((<span class="keyword">double</span>) i / (<span class="keyword">double</span>) period</span><br><span class="line">+ (<span class="number">6.2831853071795862</span>D * (<span class="keyword">double</span>) phase)</span><br><span class="line">/ (<span class="keyword">double</span>) frames);</span><br><span class="line">g.copyArea(i, <span class="number">0</span>, <span class="number">1</span>, h1, <span class="number">0</span>, (<span class="keyword">int</span>) d);</span><br><span class="line"><span class="keyword">if</span> (borderGap) &#123;</span><br><span class="line">g.setColor(color);</span><br><span class="line">g.drawLine(i, (<span class="keyword">int</span>) d, i, <span class="number">0</span>);</span><br><span class="line">g.drawLine(i, (<span class="keyword">int</span>) d + h1, i, h1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"verifies"</span>);</span><br><span class="line"><span class="keyword">int</span> w = <span class="number">200</span>, h = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">String verifyCode = generateVerifyCode(<span class="number">4</span>);</span><br><span class="line">File file = <span class="keyword">new</span> File(dir, verifyCode + <span class="string">".jpg"</span>);</span><br><span class="line">outputImage(w, h, file, verifyCode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：</p><p><a href="https://bbs.csdn.net/topics/250022320" target="_blank" rel="noopener">https://bbs.csdn.net/topics/250022320</a> </p><p>BufferedImage与Buffer的区别</p><p><a href="https://docs.oracle.com/javase/7/docs/api/java/awt/Graphics.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/java/awt/Graphics.html</a></p><p>Graphics文档</p><p><a href="https://blog.csdn.net/zlxtk/article/details/53995049" target="_blank" rel="noopener">https://blog.csdn.net/zlxtk/article/details/53995049</a></p><p>Java Graphics初探</p><p><a href="https://blog.csdn.net/zhliro/article/details/45645569" target="_blank" rel="noopener">https://blog.csdn.net/zhliro/article/details/45645569</a></p><p>Java Graphics2D类的绘图方法</p><p><a href="https://blog.csdn.net/ruixue0117/article/details/22829557" target="_blank" rel="noopener">https://blog.csdn.net/ruixue0117/article/details/22829557</a></p><p>Java生成验证码</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划入门</title>
      <link href="/2018/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
      <url>/2018/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><strong>参考邓俊辉老师《数据结构》的MOOC</strong></p><p><strong>理解问题</strong></p><p>两个序列的子序列指的是，由序列中的若干字符，按照原来的相对次序组成的。其中有几个注意事项</p><ul><li>可能同时有多个最长公共子序列，同时有多个意味着在不影响最长的前提下，在某个部分可能由不同的匹配结果，而几个 不同的匹配结果却不能合并，顺序是交叉的。用邓俊辉老师的例子是这样的：<ul><li>educational</li><li>advantage</li><li>前面匹配da没问题，倒着看匹配a没问题，中间可以匹配t也可以匹配n，不能同时匹配因为其出现次序不同</li></ul></li><li>可能有歧义，某一个字符同时出现两次<ul><li>didactical</li><li>advantage</li><li>data</li></ul></li></ul><p><strong>减而治之的思想得到递归程序</strong></p><ul><li>最简单最一般的情况就是其中有一个序列已经被减到空了，那么就不可能对应的序列了</li><li>在减小规模的过程中<ul><li>最后两个相等，就直接得到这个公共字符</li><li>最后两个不等<ul><li>分情况递归查找</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="comment">//最长公共子序列的递归算法</span></span><br><span class="line"><span class="comment">//递归算法整体采用减而治之的思想</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">LCS</span><span class="params">(String str1,String str2,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//递归基，当其中有一个串已经完成的时候结束</span></span><br><span class="line"><span class="keyword">if</span>(index1==-<span class="number">1</span>||index2==-<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一种情况，当末尾字符匹配的时候</span></span><br><span class="line"><span class="keyword">if</span>(str1.charAt(index1)==str2.charAt(index2)) &#123;</span><br><span class="line"><span class="keyword">return</span> LCS(str1,str2,index1-<span class="number">1</span>,index2-<span class="number">1</span>)+String.valueOf(str1.charAt(index1));</span><br><span class="line"><span class="comment">//当不匹配的时候分成两种情况讨论，(分而治之)取其中最长的</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">String a = LCS(str1,str2,index1-<span class="number">1</span>,index2);</span><br><span class="line">String b = LCS(str1,str2,index1,index2-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> a.length()&gt;=b.length()?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">LCS</span><span class="params">(String str1,String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> LCS(str1,str2,str1.length()-<span class="number">1</span>,str2.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(LCS(<span class="string">"program"</span>, <span class="string">"algorithm"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归存在的问题</strong></p><p>减而治之已经带有大量重复计算的过程了，但是它又来了一个分而治之。。</p><p><strong>改进的策略</strong></p><p>类比斐波那契数列，斐波那契数列只用减而治之，改为迭代算法一方面可以对每一个计算结果进行保存，另一方面其计算结果依赖于前两项，对这两项从前到后的迭代也可以解决。LCS问题稍有不同的是，它有了分而治之，假设其所有的子问题都可以用M[A,B]A,B分别为子序列的长度。这些子问题构成的是一个二维的视图，求解M[A,B]在不能直接缩小问题规模的情况下（所谓直接缩小就是最后一个比对字符相等的情况下）就会比较M[A-1,B]和M[A,B-1]这两个问题的解谁大。</p><p>既然所有的子问题都可以用M[A,B]表示，设A的长度为m，B的长度为N，那么解决这些子问题远远比通过递归解决效率高得多。时间复杂度也是0(m*n)</p><p>这个表示解的二维数组的生成过程就是一个问题从最简单到复杂的过程。最简单的问题就是递归基表示的，其中有个序列为空了。之后就从左到右，从上到下扩展问题的规模。在下面的实现算法只表示LCS的字符的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LCS</span><span class="params">(String str1,String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] solve = <span class="keyword">new</span> <span class="keyword">int</span>[str1.length()+<span class="number">1</span>][str2.length()+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.length();i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str2.length();j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(str1.charAt(i)==str2.charAt(j))</span><br><span class="line">solve[i+<span class="number">1</span>][j+<span class="number">1</span>]=solve[i][j]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> a = solve[i][j+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> b = solve[i+<span class="number">1</span>][j];</span><br><span class="line">solve[i+<span class="number">1</span>][j+<span class="number">1</span>]=a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> solve[str1.length()][str2.length()];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在牛客网中查询相应的习题，对代码在其规定的环境中略作修改即可通过。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows进程的创建过程</title>
      <link href="/2018/07/28/Windows%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/07/28/Windows%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h3><p>进程是空间上的概念，程序在内存中的一个抽象，包含程序的数据代码等等具体的内容。而线程是一个时间上的概念，我们在创建一个进程的时候一般同时创建一个线程，所以很容易在进程和线程的含义上区分不清楚。<br><a id="more"></a></p><h3 id="Windows进程创建过程"><a href="#Windows进程创建过程" class="headerlink" title="Windows进程创建过程"></a>Windows进程创建过程</h3><p>内存中的程序是其本身文件的映射。Windows的PE文件格式和Linux的ELF文件格式都是源于COFF文件格式，该格式是分段划分的，以满足对动态链接的要求以及对每个段数据的管理与保护，在32位操作系统下，windows 的PE文件格式会映射到一个2GB（低地址，高2G是操作系统占用的）大小的虚拟地址空间，这些地址空间由PE文件映射而来，同时加载许多动态库文件。对虚拟内存地址空间大致是如下的分布：</p><table><thead><tr><th>分区</th><th>32位windows</th></tr></thead><tbody><tr><td>空指针赋值区域</td><td>0x00000000-0x0000FFFF</td></tr><tr><td>用户模式区</td><td>0x00010000-0x7FFEFFFF</td></tr><tr><td>64KB禁入区</td><td>0x7FFF000-0x7FFFFFFF</td></tr><tr><td>内核</td><td>0x80000000-0xFFFFFFFF</td></tr><tr><td></td></tr></tbody></table><p>下面是进程具体的创建过程：</p><ul><li>映射EXE文件</li><li>创建内核对象EPROCESS</li><li>映射系统DLL(ntdll.dll)</li><li>创建线程内核对象ETHREAD</li><li>系统启动线程<ul><li>映射DLL（ntdll.LdrlnitializeThunk）</li><li>线程开始执行</li></ul></li></ul><p>从大的方面来讲，分为两步，创建进程，创建线程</p><p>这两方面也都有共同点</p><ul><li>都对应着内核对象，分别是EPROCESS和ETHREAD，这些都是由操作系统管理，在OS的高2G当中</li><li>都需要映射dll，只不过进程是映射ntdll，线程启动时映射的是PE文件需要的dll，是递归加入的</li></ul><p>不同点在于</p><ul><li>线程需要操作系统启动。</li></ul><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ul><li>进程都是由其他的进程创建的！第一个进程是由OS启动创建的。</li></ul><h3 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h3><p>在这里暂时不贴具体的API参数，而是先去大致学习明白它需要什么。</p><ul><li><p>子进程的概念</p><ul><li>由于进程都是由父进程创建（除了第一个创建的进程），所以引出子进程的概念</li></ul></li><li><p>创建子进程类似运行一个程序，类比命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir files/</span><br></pre></td></tr></table></figure><p>一个是这个程序路径和名字（得到程序在哪里，文件名对具体的文件索引是有一个映射的,文件名是对具体文件位置的抽象表示）</p><p>第二个是命令行参数，执行前的附加参数</p><p>第三个比较隐含，就是父进程的部分信息，这个“部分信息”包含以下内容：</p><ul><li>父进程的环境变量 -&gt;是否继承？</li><li>父进程信息 STARTUPINFO结构体（创建进程的时候由父进程填充），子进程通过GetStartupInfo来获取</li></ul></li><li><p>其次，我们应该去指明，创建这个进程的方式是什么？如何去创建。主要包含以下内容</p></li><li><p>最后，我们应该返回创建的进程和线程的标识信息，方便之后的程序步骤进行处理</p><ul><li>进程句柄，进程ID</li><li>线程句柄，线程ID</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux学习（命令）</title>
      <link href="/2018/07/27/Linux%20%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%91%BD%E4%BB%A4%EF%BC%89/"/>
      <url>/2018/07/27/Linux%20%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%91%BD%E4%BB%A4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Linux常用命令的学习，不间断更新，逐渐让它完整</p><h2 id="Shell-操作"><a href="#Shell-操作" class="headerlink" title="Shell 操作"></a>Shell 操作</h2><ul><li>history<ul><li>显示之前输入过的命令</li><li>Ctrl+P 一直向上遍历（从下向上）  Previous</li><li>Ctrl+N 向下遍历 （也可以向上向下）Next</li></ul></li><li>光标控制<ul><li>Ctrl + B （Back Forward）</li><li>Ctrl + F（Forward）</li><li>Ctrl +D （Delete）删除光标盖住的（之后的）一个字符</li><li>Ctrl + U 删除光标前面的字符串</li><li>Ctrl + K 删除光标后面的字符串</li></ul></li><li>Tab 自动补全</li></ul><h2 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h2><ul><li>/<ul><li>/bin ：二进制文件,包含命令等等可执行程序（其中绿色的代表可执行程序，浅蓝色是软链接（快捷方式），红色是，要想显示颜色实际上执行的指令是ls –color=auto ）</li><li>/dev: device 在Linux下一切皆文件，里面包含了CPU，显卡，内存，显示器等设备的抽象</li><li>/lib：Linux运行的时候需要加载的一些动态库</li><li>/mnt: 手动挂载目录</li><li>/media: 自动挂载目录</li><li>/root ：Linux超级用户的家目录</li><li>/usr: unix system resource Unix系统资源目录<ul><li>/include 头文件</li><li>/game 游戏</li><li>/local 用户安装的应用程序目录</li></ul></li><li>/etc 配置文件<ul><li>/passed 存储的不是密码，是用户的信息</li><li>/group 存储用户组信息</li></ul></li><li>/opt: 安装第三方应用程序</li><li>/home 用户的家目录（宿主目录）</li><li>/tmp:   存放临时文件 重启清空</li></ul></li></ul><h2 id="命令学习（基本操作）"><a href="#命令学习（基本操作）" class="headerlink" title="命令学习（基本操作）"></a>命令学习（基本操作）</h2><h3 id="tree-gt-查看目录"><a href="#tree-gt-查看目录" class="headerlink" title="tree -&gt;(查看目录)"></a>tree -&gt;(查看目录)</h3><ul><li>查看一个目录的内容</li><li>tree 查看当前目录</li><li>tree dir 查看指定目录</li></ul><h3 id="ls-gt-（查看文件和目录）"><a href="#ls-gt-（查看文件和目录）" class="headerlink" title="ls  -&gt;（查看文件和目录）"></a>ls  -&gt;（查看文件和目录）</h3><ul><li>查看文件和目录</li></ul><p><strong>参数</strong></p><ul><li>-a   显示所有文件和目录，包括隐藏文件（以.开头的）</li><li>-l    列出详细信息<ul><li>-rwxrw-r– 1 kevin kevin 321145 11月 23 23:08 hello.txt</li><li>第一个字符：文件的类型<ul><li>7种</li><li>普通文件：-<ul><li>.txt 压缩包 可执行程序</li></ul></li><li>目录：d</li><li>符号链接：I</li><li>管道:p</li><li>套接字：s</li><li>字符设备：c<ul><li>键盘，鼠标</li></ul></li><li>块设备：b<ul><li>U盘，硬盘</li></ul></li></ul></li><li>之后就是文件所有者，文件所有组，其他人的权限</li><li>再之后的1是硬连接计数</li><li>在后来的用户名是文件所有者</li><li>再后来的名字是文件所属组的文字</li><li>后面的文字是文件的大小<ul><li>如果是目录，看到的大小永远是4K （ls -lh）是目录本身的大小</li></ul></li><li>日期</li><li>文件名</li></ul></li><li>-f 格式化，如果是目录就加/</li></ul><h3 id="alias-gt-（查看命令别名）"><a href="#alias-gt-（查看命令别名）" class="headerlink" title="alias -&gt;（查看命令别名）"></a>alias -&gt;（查看命令别名）</h3><p>常用的命令比如</p><p>ls =’ls –color=auto’</p><p>ll =’ls -alF’</p><h3 id="pwd-gt-（查看当前目录）"><a href="#pwd-gt-（查看当前目录）" class="headerlink" title="pwd -&gt;（查看当前目录）"></a>pwd -&gt;（查看当前目录）</h3><p>Print Work Dictionary</p><h3 id="cd-gt-（切换目录）"><a href="#cd-gt-（切换目录）" class="headerlink" title="cd -&gt;（切换目录）"></a>cd -&gt;（切换目录）</h3><ul><li>cd ~ 切换到家目录</li><li>cd 退出目录</li><li>cd - 最后两个相邻的，目录特别长的时候适用</li></ul><h3 id="mkdir-gt-创建目录"><a href="#mkdir-gt-创建目录" class="headerlink" title="mkdir -&gt;(创建目录)"></a>mkdir -&gt;(创建目录)</h3><ul><li>mkdir 文件名 ：直接创建路径</li><li>mkdir 路径/文件名 创建子目录</li><li>mkdir 路径/文件名 -p  可以一次性创建多级目录</li></ul><h3 id="touch-gt-（创建文件）"><a href="#touch-gt-（创建文件）" class="headerlink" title="touch -&gt;（创建文件）"></a>touch -&gt;（创建文件）</h3><ul><li>touch 文件名 如果文件不存在，创建新文件，如果存在，则会更新时间而不做任何操作</li></ul><h3 id="rmdir-gt-（删除空目录）"><a href="#rmdir-gt-（删除空目录）" class="headerlink" title="rmdir -&gt;（删除空目录）"></a>rmdir -&gt;（删除空目录）</h3><p>注意只能删除空目录，功能比较弱</p><h3 id="rm-gt-删除命令"><a href="#rm-gt-删除命令" class="headerlink" title="rm -&gt;(删除命令)"></a>rm -&gt;(删除命令)</h3><ul><li>删除目录<ul><li>直接删除也会提示’无法删除，是一个目录’</li><li>树形结构需要递归删除，因此需要加上参数-r</li></ul></li><li>删除文件<ul><li>rm 文件名 -i</li></ul></li><li><p>删除的时候给提示 -I</p></li><li><p>注意问题</p><ul><li>删除之后，很难恢复</li></ul></li></ul><h3 id="cp-gt-（拷贝）"><a href="#cp-gt-（拷贝）" class="headerlink" title="cp -&gt;（拷贝）"></a>cp -&gt;（拷贝）</h3><ul><li>cp 要拷贝的文件  拷贝目的  如果拷贝目的不存在则会创建这个文件并拷贝</li><li>cp file1 file2（存在）则会覆盖文件的内容</li><li>cp file dir（存在）<ul><li>拷贝file到dir<ul><li>cp dir dir1（存在）</li><li>将dir拷贝到dir1，直接使用会提示略过，拷贝时候需要递归的拷贝，所以应该加-r</li><li>cp dir dir1（不存在）</li><li>将dir里面的内容copy到新创建的目录中，注意不包括源dir名字</li></ul></li></ul></li></ul><h3 id="mv-gt-改名或者移动文件"><a href="#mv-gt-改名或者移动文件" class="headerlink" title="mv -&gt;(改名或者移动文件)"></a>mv -&gt;(改名或者移动文件)</h3><ul><li>改名<ul><li>mv file（存在）file1（不存在）</li><li>mv dir（存在）dir1（不存在）</li></ul></li><li>移动<ul><li>mv file（文件） dir（存在） 将file移动到目录中去</li><li>mv dir1（存在）dir2(存在) 将dir1移动到dir2中</li><li>mv file（存在）file2 覅了文件会覆盖file2文件</li></ul></li></ul><h3 id="cat-gt-（将内容打印到终端）"><a href="#cat-gt-（将内容打印到终端）" class="headerlink" title="cat -&gt;（将内容打印到终端）"></a>cat -&gt;（将内容打印到终端）</h3><p>文件特别多，大于终端显示上限，只能显示一部分</p><h3 id="more-gt-（查看更多）"><a href="#more-gt-（查看更多）" class="headerlink" title="more-&gt;（查看更多）"></a>more-&gt;（查看更多）</h3><ul><li>回车向下</li><li>空格翻页</li><li>不能回去</li><li>按下q退出</li></ul><h3 id="less-gt-（可以向上）"><a href="#less-gt-（可以向上）" class="headerlink" title="less-&gt;（可以向上）"></a>less-&gt;（可以向上）</h3><p>与more相同，但是可以向上翻页，可以用page up键也可以用Ctrl +P，向下Ctrl+N</p><h3 id="head-gt-（显示前？行）"><a href="#head-gt-（显示前？行）" class="headerlink" title="head -&gt;（显示前？行）"></a>head -&gt;（显示前？行）</h3><p>可以通过加入参数来设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head -5 stdio.h</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认是10行</span></span><br></pre></td></tr></table></figure><h3 id="tail-gt-显示后？行"><a href="#tail-gt-显示后？行" class="headerlink" title="tail -&gt;(显示后？行)"></a>tail -&gt;(显示后？行)</h3><p>同上</p><h3 id="ln-gt-（创建快捷方式）"><a href="#ln-gt-（创建快捷方式）" class="headerlink" title="ln -&gt;（创建快捷方式）"></a>ln -&gt;（创建快捷方式）</h3><ul><li>软链接 –快捷方式<ul><li>ln -s </li><li>它的大小对应的是其字节数</li><li>当移动之后或许会发生快捷方式失效的，这是因为是相对路径</li><li>在创建的时候使用绝对路径就可以防止移动之后的快捷方式失效</li><li>目录也可以创建软链接</li></ul></li><li>硬连接 <ul><li>ln 文件名</li><li>相对路径或者绝对路径没有关系</li><li>认识inode结点<ul><li>磁盘上的数据块是由索引节点号inode来表示</li><li>OS并不对文件名感兴趣，每个文件是由其inode决定的</li><li>因此inode不占用磁盘空间</li><li>创建一个文件，硬链接计数为1</li><li>给文件创建了硬连接，链接+1，删除一个-1</li><li>如果inode为0，那么标识为废弃，再写入新文件的时候会覆盖，如果非0会进行保护</li></ul></li><li>使用场景<ul><li>磁盘上有一个文件</li><li>需要再其他多个目录管理这个文件，并且能够实时同步</li><li>硬连接是直接对应inode号，软链接是对应文件路径</li></ul></li></ul></li></ul><blockquote><p>参考资料：</p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html</a></p><p>理解 Linux 的硬链接与软链接</p></blockquote><h2 id="命令学习（用户权限，用户和用户组）"><a href="#命令学习（用户权限，用户和用户组）" class="headerlink" title="命令学习（用户权限，用户和用户组）"></a>命令学习（用户权限，用户和用户组）</h2><h3 id="chmod-gt-（修改文件或者目录的权限）"><a href="#chmod-gt-（修改文件或者目录的权限）" class="headerlink" title="chmod-&gt;（修改文件或者目录的权限）"></a>chmod-&gt;（修改文件或者目录的权限）</h3><ul><li><p>文字设定法</p><ul><li>chmod who[+|-|=]mode 文件名<ul><li>Who：<ul><li>u -User 文件所有者</li><li>g-group 文件所属组</li><li>o-other 其他人</li><li>a -all 所有人</li></ul></li><li>+|-|=</li><li>mode<ul><li>r:读</li><li>w:写</li><li>x:执行</li><li>-：没有任何权限</li></ul></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有者添加读权限，同组用户减去执行权限</span></span><br><span class="line">chmod u+r,g-x file.c</span><br></pre></td></tr></table></figure></li><li><p>数字设定法</p><ul><li>chmod [+|-|=] mode 文件名<ul><li>mode：<ul><li>r: 100-&gt; 4</li><li>w:010-&gt;2</li><li>x:001-&gt;1</li><li>-:0</li></ul></li></ul></li></ul></li></ul><h3 id="chown-gt-修改文件所有者或者所属组"><a href="#chown-gt-修改文件所有者或者所属组" class="headerlink" title="chown-&gt;(修改文件所有者或者所属组)"></a>chown-&gt;(修改文件所有者或者所属组)</h3><ul><li>chown 新的所有者 文件名</li><li>chown 新的所有者：新的组 文件名</li><li>如何查看用户和组？<ul><li>/etc/passwd 用户</li><li>/etc/group 组</li></ul></li><li>也可以修改组</li></ul><h3 id="chgrp-gt-（修改文件所有组）"><a href="#chgrp-gt-（修改文件所有组）" class="headerlink" title="chgrp-&gt;（修改文件所有组）"></a>chgrp-&gt;（修改文件所有组）</h3><p>只能修改对应的组</p><ul><li>chgrp 新的组 文件名</li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>一个目录必须有可执行权限才能打开，否则就无法打开</li></ul><h3 id="文件的查找和检索"><a href="#文件的查找和检索" class="headerlink" title="文件的查找和检索"></a>文件的查找和检索</h3><h3 id="find-gt-根据文件属性查找"><a href="#find-gt-根据文件属性查找" class="headerlink" title="find-&gt;(根据文件属性查找)"></a>find-&gt;(根据文件属性查找)</h3><ul><li>文件名<ul><li>find 查找的目录 -name “查找的文件名”</li></ul></li><li>文件类型<ul><li>find 查找到目录 -type 文件类型<ul><li>Linux 下的七种文件类型<ul><li>普通文件（-），目录（d），磁盘链接（l），管道（p pipeline），套接字（s），字符设备（c），块设备（b）</li></ul></li></ul></li></ul></li><li><p>文件大小</p><ul><li>find 查找的目录 -size +10k      （查看大于10k的文件）</li><li>+:大于</li><li>-：小于</li><li>等于：直接写</li><li>单位：<ul><li>k - 小写</li><li>M-大写</li></ul></li><li>大于10k小于100k：find . -size +10k -size -100k</li></ul></li><li><p>按照日期</p><ul><li>创建日期： -ctime -n/+n<ul><li>-n:n天以内</li><li>+n：n天以外</li></ul></li><li>修改日期：-mtime</li><li>访问日期：-atime</li></ul></li><li>深度<ul><li>-maxdepth n(层数)搜索n层已下的目录</li><li>-mindepth n(层数)表示搜索n层以上的目录</li><li>-name 制定名字</li><li>find itcast/ -maxdepth 3 -name programer</li></ul></li><li>高级查找<ul><li>例，查找制定目录，并列出该目录中文件的详细信息<ul><li>find ./ -type d -exec ls -l {} \;</li><li>find ./ -type d -ok ls -l {} \;<ul><li>OK比较安全</li></ul></li><li>find ./-type d | xargs ls -l<ul><li>管道一端是Read端，一端是Write端</li></ul></li></ul></li></ul></li></ul><h3 id="grep-gt-根据文件内容查找"><a href="#grep-gt-根据文件内容查找" class="headerlink" title="grep -&gt;(根据文件内容查找)"></a>grep -&gt;(根据文件内容查找)</h3><ul><li>搜索目录有子目录的时候需要加上-r</li><li>grep -r “查找的内容” 搜索的路径</li><li>搜索家目录中带有helloword字符串的文件</li><li>grep -r “helloworld” ~</li><li>显示在第几行 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r <span class="string">"stdio.h"</span> ~ -n</span><br></pre></td></tr></table></figure><hr><h3 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h3><ul><li><p>Linux下常见的压缩格式</p><ul><li>.gz –gzip<ul><li>压缩：gzip 文件1，文件2… -k(保留源文件)</li><li>解压缩：gunzip *.gz</li><li>不能压缩目录</li></ul></li><li>.bz2 -bzip</li></ul></li><li><p>常用压缩命令：</p><ul><li><p>tar -打包</p><ul><li><p>参数：</p><ul><li>c-创建压缩文件</li><li>x-释放压缩文件</li><li>v-打印提示信息</li><li>f-制定压缩包的名字</li><li>z-使用gzip压缩文件-&gt;xxx.tar.gz</li><li>j -使用bzip2的方式压缩文件-&gt;xxx.tar.bz2</li></ul></li><li><p>压缩</p><ul><li>tar 参数 压缩包名字 原材料。。。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf test.tar.gz file1...</span><br></pre></td></tr></table></figure></li><li><p>解压缩</p><ul><li>tar 参数 要解压包的名字</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf test.tar.gz</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>rar</p><ul><li>rar需要安装</li><li>压缩<ul><li>rar a 压缩包名（不需要指定后缀） 压缩的内容</li><li>注意压缩的时候是不压缩子目录的</li><li>所以就需要再后面加上-r</li></ul></li><li>解压缩<ul><li>rar x 压缩包名 解压的目录</li></ul></li></ul></li><li><p>zip/unzip</p><ul><li>压缩：<ul><li>zip 参数  压缩包名 原材料</li><li>如果有目录就是-r</li></ul></li><li>解压缩<ul><li>unzip 压缩包的名字 -d 解压目录</li><li>-O 制定编码 </li></ul></li></ul></li></ul><h3 id="软件的安装与卸载（Ubnutu"><a href="#软件的安装与卸载（Ubnutu" class="headerlink" title="软件的安装与卸载（Ubnutu)"></a>软件的安装与卸载（Ubnutu)</h3><h3 id="apt-get在线安装"><a href="#apt-get在线安装" class="headerlink" title="apt-get在线安装"></a>apt-get在线安装</h3><ul><li>16.04版本之上就可以直接apt就可以</li><li>安装<ul><li>sudo apt-get install tree</li></ul></li><li>卸载<ul><li>sudo apt-get remove tree</li></ul></li><li>软件列表的更新<ul><li>sudo apt-get update</li><li>注意只是更新列表，列表是所有可安装程序的URL</li></ul></li><li>清空缓存<ul><li>sudo apt-get clean</li><li>对应的目录在var/cache/apt/archives</li><li>存储的是deb包</li></ul></li></ul><h3 id="deb软件包安装方式"><a href="#deb软件包安装方式" class="headerlink" title="deb软件包安装方式"></a>deb软件包安装方式</h3><ul><li>安装<ul><li>sudo dpkg -i  xxx.deb</li><li>sudp dpkg -r 软件名</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系统函数学习</title>
      <link href="/2018/07/27/Linux%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
      <url>/2018/07/27/Linux%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Linux系统函数的学习，不间断更新，直到完整</p><h3 id="从fopen看文件FILE结构体"><a href="#从fopen看文件FILE结构体" class="headerlink" title="从fopen看文件FILE结构体"></a>从fopen看文件FILE结构体</h3><p>​    在使用fopen打开文件返回的是FILE结构体，之前并不了解其内部，只是大致会用而已，在这里首先剖析FILE结构体。</p><p>FILE结构体的内容很多，主要分为以下部分</p><p>FILE</p><ul><li><p>文件描述符（整形值）FD</p><ul><li>文件描述符内部有inode信息，再通过inode找到具体的文件</li></ul></li><li><p>文件读写指针位置  FP_POS</p><ul><li><p>首先读写指针是一个指针，因此在切换读写文件的时候需要fseek来移动文件指针</p></li><li><p>对于文件读写是对应的二进制读取，文本文件读取信息的资料补充</p><blockquote><p>知乎：fopen 为什么要区分文本模式和二进制模式？</p><p><a href="https://www.zhihu.com/question/24662572" target="_blank" rel="noopener">https://www.zhihu.com/question/24662572</a></p><p>牵扯到了BOM，下面为总结：</p><p>BOM（byte-order mark）它用来标识该字节流的字节序，是高位在前还是低位在前。从Unicode3.2开始，BOM只能位于流的开头，只能用于标识字节序。</p><p>UTF-8: 若为UTF-8有BOM格式，则文件开头为 EF BB BF； 若为UTF-8无BOM格式，则不能依据上述规则；此时需要依据UTF-8编码格式来判断</p></blockquote></li></ul></li><li><p>I/O缓冲区（内存地址）BUFFER<br><img src="https://upload-images.jianshu.io/upload_images/8852615-0539b579f780a484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ScreenShot_20180720193704.png"></p><ul><li>C标准函数都有Buffer</li><li>I/O缓存区域，根据存储器层次结构，硬盘会比内存慢100万倍，因此要增设缓存，默认是8K，同样需要注意的是IO的形式除了默认的，还有以下形式：<ul><li>直接IO<ul><li>内存映射文件的形式</li></ul></li></ul></li></ul></li></ul><p>读写过程：</p><ul><li>例如Printf(“Hello World”);</li><li>调用write函数将文件描述符传入（系统API write(fd,”hello”,5)）完成将”hello”用户空间到内核空间的传递</li><li>系统调用sys_write 使用设备驱动，通过设备驱动函数写入到驱动操作硬件</li><li>显示器显示</li></ul><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>32位操作系统当一个可执行文件允许起来成为一个进程的时候操作系统会为其分配一个4G的地址空间，虚拟内存是分段的，而其根据局部性原理也不是一次性加载的，而是分页的</p><p>下面是对虚拟地址空间做一个详细的总结，虚拟地址空间的引出和计算机的发展历程是离不开的的。</p><p>在早期的计算机中，程序是直接运行在物理内存上的，程序直接访问的是物理地址，这种模式的限制在于，只要程序要求的内存空间不要超过超过物理内存的大小，就不会有问题，但是为了提高CPU的使用效率，我们更期望的是同时运行多个程序，现在关键的问题在于，能运行的程序受限于物理内存的大小以及运行程序本身的大小。所以一个需要关键解决的问题就是如何将有限的物理内存分配给多个程序使用，也就是内存分配问题，但除了内存分配问题，传统的方式还存在许多问题。</p><ul><li>地址空间不隔离导致程序的安全性不足，一个程序的崩溃会影响到其他程序，恶意程序可以轻松修改其他程序的数据，总而言之，缺乏安全稳定性</li><li>内存地址分配随机就让程序内部的重定位工作（运行地址不确定）变得异常麻烦</li><li>内存使用效率低下</li><li><p>内存切换过程（将完整程序换入到硬盘或者将完整换出）效率十分低下</p><p>如果引入一个中间层，在外部忽视内存地址的差异，在内部执行一个转换到真实地址的过程，就可以轻松解决第一第二点，这就是虚拟内存。虚拟内存使得应用程序不需要考虑自己加载到什么地方。相互之间也起到了隔离的作用，程序与程序之间安全性得到了一定的保障。但是第三个第四个仍然没有解决。内存毕竟是有限的。为了能让在内存的程序尽可能的多，当然是程序占用内存越小越好，但是程序变小不可能的。但这个思路得以运用，将程序加载到内存的粒度缩小，采用分页模式就有效的解决的这个问题。</p><p>在以上的描述中，并没有深入研究CPU如何做到将虚拟内存映射到实际内存的过程，也没有研究页是如何被操作系统管理，缺页的时候怎么办等等，这个在之后学习。</p></li></ul><p>程序都是按照一定格式存储的，由操作系统统一加载。在内存中映射为4GB的虚拟内存空间（32位）这样的文件格式是分段的，很好的解决了一些资源共享的问题，比如动态库的共享，也为每一个应用程序提供了一个统一的视图，完成功能，下面是Linux的ELF文件在内存的映射</p><ul><li>内核区：内存管理，进程管理，设备驱动管理，VFS虚拟文件系统（4G-3G linux）</li><li>环境变量 env</li><li>命令行参数  <ul><li>int main(int argc,char* argv[])中的参数</li></ul></li><li>栈空间（小）向下增长</li><li>共享库</li><li>堆空间（大）向上增长</li><li>.bass（未初始化的全局变量）全局变量=0</li><li>.data（已初始化全局变量）</li><li>.text（代码段 二进制机器指令）</li><li>受保护的地址（0-4K）其中0是收保护的地址，这也就是NULL的作用</li></ul><h3 id="文件描述符表"><a href="#文件描述符表" class="headerlink" title="文件描述符表"></a>文件描述符表</h3><p>内核进程管理里面由一个叫做PCB(进程控制块)每个进程都在其PCB中保存着一份文件描述符表，而文件描述符作为这个表的索引可以让我们快速的查到每个表项对应的打开文件的指针，文件描述符表最多可以存储1024个文件描述符</p><p><strong>用户不能直接访问具体的文件描述符，就只能通过文件描述符表的下标由内核函数访问。</strong></p><p>文件描述符前3个分别是STDIN_FILENO 标准输入 STDOUT_FILENO 标准输出 STDERR_FILENO 标准错误默认是打开状态，根据该文件描述符可以读写当前终端，每打开一个新文件，则占用一个文件描述符，而且是空闲的最小的一个文件描述符</p><p>文件描述符内含有inode信息，具体的介绍查看:</p><blockquote><p><a href="http://www.docin.com/p-941544538.html" target="_blank" rel="noopener">http://www.docin.com/p-941544538.html</a></p><p>豆丁网-inode,文件描述符</p></blockquote><p>Linux的open函数返回的int类型就是文件描述符表对新创建文件的下标，也就是文件描述符</p><p>而系统函数read传入文件描述符，就可以清楚的知道要操作哪一个文件。</p><h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><p>系统函数在man帮助文档的第二章</p><h3 id="Open函数"><a href="#Open函数" class="headerlink" title="Open函数"></a>Open函数</h3><p>查看文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 open</span><br></pre></td></tr></table></figure><p>头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt; //宏定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>open函数看起来是函数重载的原因是使用了变长参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathnamae,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//第三个参数是在第二个参数有效的情况下才有意义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname,<span class="keyword">int</span> flags,<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：文件描述符，失败返回-1</p><p><strong>参数</strong></p><ul><li>flags<ul><li>必选项目 O_RDONLY,O_WRONLY,O_RDWR</li><li>可选项目<ul><li>创建文件：O_CREATE<ul><li>创建文件时检测文件是否存在：O_EXCL</li><li>如果文件存在，返回-1</li><li>必须与O_CREAT一起使用</li></ul></li><li>追加文件：O_APPEND:文件指针移动到末尾</li><li>文件截断：O_TRUNC ：做文件清空的情况</li><li>设置非阻塞：O_NONBLOCK</li></ul></li></ul></li><li>mode 八进制文件权限<ul><li>注意设置的权限不等于最终的权限值</li><li>（mode&amp;~umask）</li><li>umask是0002</li></ul></li></ul><h3 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h3><p>关闭文件描述符</p><h3 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h3><h3 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h3>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射基础</title>
      <link href="/2018/07/27/Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/27/Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Java反射机制的学习</p><h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><blockquote><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 –百度百科<br><a id="more"></a></p></blockquote><h2 id="Class类-反射的根源"><a href="#Class类-反射的根源" class="headerlink" title="Class类 - 反射的根源"></a>Class类 - 反射的根源</h2><h3 id="Class类描述"><a href="#Class类描述" class="headerlink" title="Class类描述"></a>Class类描述</h3><p>Class类是对应类文件的描述，可以说是class字节码的抽象，这种描述包含：类名、构造函数以及成员函数、属性，它是对应对象的模板，用它可以去实例化类类对象。</p><h3 id="得到Class类的三种方法"><a href="#得到Class类的三种方法" class="headerlink" title="得到Class类的三种方法"></a>得到Class类的三种方法</h3><ul><li>Object中有getClass方法。</li><li>一个具体的类.class</li><li>通过Class类中的静态方法forName。<h3 id="使用Class来实例化对象"><a href="#使用Class来实例化对象" class="headerlink" title="使用Class来实例化对象"></a>使用Class来实例化对象</h3></li><li>使用newInstance来实例化，该对象调用的是无参数的构造方法，如果没有默认的构造方法就会报错！因此在使用反射框架的时候注意尽量保留默认构造方法。</li><li><p>使用getConstructors用有参的方式来进行实例化<br>该方法返回所有的构造方法。返回的是一个Constructor对象的数组,Constructor对象包含函数名信息，参数个数等等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ref</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;Dog&gt; dogClass = Dog.class;</span><br><span class="line">        Constructor[] constructors = dogClass.getConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor constructor:constructors)&#123;</span><br><span class="line">            System.out.println(constructor.getName());<span class="comment">//名字</span></span><br><span class="line">            System.out.println(constructor.getParameterCount());<span class="comment">//参数个数</span></span><br><span class="line">            Class[] classes = constructor.getParameterTypes();<span class="comment">//参数类型</span></span><br><span class="line">            <span class="keyword">for</span>(Class _class:classes)&#123;</span><br><span class="line">                System.out.println(_class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用getConstructor来获取制定的构造器。</p></li><li>获取构造器中可以使用newInstance来进行初始化。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = (Dog)constructor.newInstance(<span class="number">1</span>,<span class="string">"Hello"</span>);</span><br><span class="line">System.out.println(dog);</span><br></pre></td></tr></table></figure></li></ul><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p> 通过getFiled属性来得到属性，返回Filed[]对象，注意这样得到的只能是共有的属性。如果是想得到全部的属性值需要使用getDeclaredFileds方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dog类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> id,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name=<span class="string">"NULL"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ref</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Field[] fields = Dog.class.getFields();</span><br><span class="line">        Field[] fields1 = Dog.class.getDeclaredFields();</span><br><span class="line">        System.out.println(fields.length);</span><br><span class="line">        System.out.println(fields1.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到Field对象之后可以得到相应的属性与方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Field[] fields = Dog.class.getFields();</span><br><span class="line">       Field[] fields1 = Dog.class.getDeclaredFields();</span><br><span class="line">       <span class="keyword">for</span>(Field field:fields1)&#123;</span><br><span class="line">           System.out.println(field.getName());<span class="comment">//得到名字</span></span><br><span class="line">           System.out.println(field.getDeclaringClass());<span class="comment">//得到类</span></span><br><span class="line">           System.out.println(field.getModifiers());<span class="comment">//得到修饰符，返回是int</span></span><br><span class="line">           System.out.println(Modifier.toString(field.getModifiers()));<span class="comment">//通过Modifier的静态方法转换</span></span><br><span class="line">          <span class="comment">// System.out.println(field.);</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h3 id="获取包的信息"><a href="#获取包的信息" class="headerlink" title="获取包的信息"></a>获取包的信息</h3><p>得到包需要使用到Class类中的getPackage的方法，返回一个Package对象可以通过Package对象的方法得到其中的具体信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Dog&gt; dogClass = Dog.class;</span><br><span class="line">Package pack = dogClass.getPackage();</span><br><span class="line">System.out.println(pack.getName());</span><br></pre></td></tr></table></figure></p><h3 id="获得方法"><a href="#获得方法" class="headerlink" title="获得方法"></a>获得方法</h3><p>对应Method对象，通过getMethods方法可以得到所有的公共的方法，包括继承的公有方法，如果想要获取私有方法，就通过getDeclaredMethods方法，但是直接执行是不行的，由于是private的限制，但是这个总是有办法去解决的，就是对Method执行setAccessible函数来设置为true（暴力执行）。方法的到之后我们需要执行，执行函数是invoke方法的作用，执行函数是依赖与具体对象的，除了传入对象当然还有具体的参数。上面都是得到方法的数组，得到具体的方法就把后面的s去掉即可。<br>下面是一个简单的Demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayByebye</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ByeBye:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ref</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;Test&gt; test = Test.class;</span><br><span class="line">        Test obj =(Test) test.newInstance();</span><br><span class="line">        Method[] methods = test.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            method.invoke(obj,<span class="string">"HelloWorld!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>### </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Servlet 执行过程笔记</title>
      <link href="/2018/07/27/Servlet%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/07/27/Servlet%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>首先必须明确，Servlet是JavaEE一个规范，包括JDBC，都是提供了一个规范，而Servlet的具体实现以及运行过程是Tomcat来具体进行的。Servlet本身就是一个接口。HttpServlet只是它的一个具体的实现。</p><h2 id="Web容器"><a href="#Web容器" class="headerlink" title="Web容器"></a>Web容器</h2><p>Web容器说白了就是Web服务器，Tomcat在收到客户端发来的请求之后，创建HttpServletRequest，HttpServletResponse等，它得到请求信息封装起来，交给Servlet去处理。</p><h2 id="Servlet容器"><a href="#Servlet容器" class="headerlink" title="Servlet容器"></a>Servlet容器</h2><p>在Tomcat启动之后也会初始化一个Servlet容器，其会检索web.xml或者是注解来生成ServletConfig对象，ServletConfig本身也是接口，其定义了获取在web.xml或者注解中指明的参数。其接口的具体方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletConfig</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Servlet 接口则指明了Servlet生命期的几个关键的函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span><span class="keyword">throws</span> ServletExection</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span><span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，Tomcat规定了如何调用整个Servlet过程，这就是具体的算法。</p><ul><li>init 方法在Servlet生命周期中的初始化阶段被调用</li><li>servlet初始化后，有了新的请求调用service方法，进行处理，如HttpServlet 进行doGet和doPost方法的判断。</li><li>当销毁servlet对象的时候，调用distory方法释放被占用的资源 </li></ul><p>ServletConfig和Servlet封装了这个过程中容易变化的部分。再定义一个抽象类将算法封装起来，这就是所谓的模板方法模式，封装算法的抽象类是GenericServlet，我们查看GenericServlet的具体内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>,</span></span><br><span class="line"><span class="class">        <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//这里组合了一个ServletConfig对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getServletConfig().getInitParameter(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getServletConfig().getInitParameterNames();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getServletConfig().getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP by default</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        getServletContext().log(getServletName() + <span class="string">": "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message, Throwable t)</span> </span>&#123;</span><br><span class="line">        getServletContext().log(getServletName() + <span class="string">": "</span> + message, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config.getServletName();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个封装算法的抽象类描述的是什么？<br>首先它实现了 Servlet, ServletConfig,Serializable，自然封装了Servlet和ServletConfig所描述的算法，这里实现ServletConfig的实现比较有意思，它是组合了一个ServletConfig对象，然后间接调用这个对象的方法来实现具体ServletConfig接口指明的方法。</p><h2 id="整个调用过程"><a href="#整个调用过程" class="headerlink" title="整个调用过程"></a>整个调用过程</h2><ul><li>Web服务器接受到HTTP请求</li><li>web容器生成对象，将请求转发给Servlet容器</li><li>如果容器中不存在对应的Servlet，那么Servlet容器就会去检索，加载，调用init方法，如果有直接进行下一步。</li><li>容器调用Servlet的service方法来处理HTTP请求</li><li>Web服务器返回信息给客户</li></ul><h2 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h2><p>loadonstartup指明是否在Servlet容器启动的时候就进行初始化，其值代表一个优先级顺序。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Servlet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java注解学习</title>
      <link href="/2018/07/27/Java%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/07/27/Java%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Java注解的学习<br><a id="more"></a></p><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>Java注解提供了关于代码的一些信息，但并不直接作用于它所注解的代码内容，在使用注解之前，程序源数据只是通过java注释和javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>自定义注解的语法稍微特殊，现在将创建一般的注解的形式以代码的形式给出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnoutation&#123;</span><br><span class="line">    <span class="comment">//设定所有的数据成员都需要后面加上括号</span></span><br><span class="line">    <span class="comment">//设定变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//设定变量由默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line">    <span class="comment">//设定数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>[] grades();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而在一个类中去使用该注解的格式为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(name = <span class="string">"Maoxin"</span>,age = <span class="number">19</span>,grades = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Retention-和-RetentionPolicy"><a href="#Retention-和-RetentionPolicy" class="headerlink" title="@Retention 和 RetentionPolicy"></a>@Retention 和 RetentionPolicy</h3><p>Annotation要想决定其作用范围，则通过@Retention指定，而Retention制定的范围由RetentiontPolicy（枚举）决定，RetentionPolicy指定三种范围：</p><table><thead><tr><th>范围</th><th>描述</th></tr></thead><tbody><tr><td>public static final RetentionPolicy SOURCE</td><td>在Java源程序中存在</td></tr><tr><td>Public static final RetentionPolicy CLASS</td><td>在Java生成的类文件中存在</td></tr><tr><td>Public static final RetentionPolicy SOURCE</td><td>在Java运行的时候存在</td></tr></tbody></table><p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="document"><a href="#document" class="headerlink" title="@document"></a>@document</h3><p> 指明拥有这个注解的元素可以被javadoc此类的工具文档化。</p><h3 id="target"><a href="#target" class="headerlink" title="@target"></a>@target</h3><p>target注解表示注解的使用范围，如果不定义的话表示可以在任何位置上去使用</p><table><thead><tr><th>范围</th><th>作用</th></tr></thead><tbody><tr><td>public static final ElementType TYPE</td><td>只能在类或者接口或者枚举上去使用</td></tr><tr><td>public static final ElementType FIELD</td><td>在成员变量中使用</td></tr><tr><td>public static final ElementType METHOD</td><td>在方法中使用</td></tr><tr><td>public static final ElementType PARAMETER</td><td>在参数上使用</td></tr><tr><td>public static final ElementType CONSTRUCTOR</td><td>在构造方法上去使用</td></tr><tr><td>public static final ElementType LOCAL_VARIABLE</td><td>在局部变量上使用</td></tr><tr><td>public static final ElementType ANNOTATION_TYPE</td><td>只能在Annotation中使用</td></tr><tr><td>public static final ElementType PACKAGE</td><td>只能在包中使用</td></tr></tbody></table><h3 id="inherited注解"><a href="#inherited注解" class="headerlink" title="@inherited注解"></a>@inherited注解</h3><p>表示注解能否继承下去</p><h2 id="反射与注解"><a href="#反射与注解" class="headerlink" title="反射与注解"></a>反射与注解</h2><p>在反射API中包含与注解相关的类与API，其中与注解有关的类是java.lang.reflect.AccessibleObject,相关的方法为：</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt;)</td><td>判断是否为制定的Annotation</td></tr><tr><td>public Annotation[] getAnnotations()</td><td>得到全部的Annotation</td></tr></tbody></table><p>例子：</p><p>用指定的元信息去初始化类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(value = ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">//设定变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//设定变量，有默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line">    <span class="comment">//设定数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span>[] grades();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//得到具体的注解实例</span></span><br><span class="line">        MyAnnotation cls = Demo.class.getAnnotation(MyAnnotation.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>判断方法上有无注解，有的话获取并处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设存在Test对象其中的setName方法被注解被MyAnnotation修饰</span></span><br><span class="line">Class&lt;?&gt;cls = Class.forName(<span class="string">"Test"</span>)；</span><br><span class="line">Method method = cls.getMethod(<span class="string">"setName"</span>);</span><br><span class="line"><span class="keyword">if</span>(met.isAnnotationPresent(MyAnnotation.class))&#123;</span><br><span class="line">    MyAnnotation my = (MyAnnotation) met.getAnnotation(MyAnnotation.class);</span><br><span class="line">    <span class="comment">//执行一些具体的操作，例如赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><ul><li>找到Class对象，找到目标注解，返回一个注解对象</li><li>对注解对象做一个操作</li></ul><h2 id="系统内建注解"><a href="#系统内建注解" class="headerlink" title="系统内建注解"></a>系统内建注解</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="comment">//只对方法有效，信息只保留到编译期</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line"><span class="comment">//生成文档信息，信息一直保留到运行期间，目标是全部</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet3-0的注解"><a href="#Servlet3-0的注解" class="headerlink" title="Servlet3.0的注解"></a>Servlet3.0的注解</h2><h3 id="WebServlet"><a href="#WebServlet" class="headerlink" title="WebServlet"></a>WebServlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebServlet &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] urlPatterns() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">loadOnStartup</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="comment">//WebInitParam也是注解</span></span><br><span class="line">    WebInitParam[] initParams() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">asyncSupported</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">smallIcon</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">largeIcon</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">displayName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java动态代理</title>
      <link href="/2018/07/27/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/27/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是动态代理？"><a href="#什么是动态代理？" class="headerlink" title="什么是动态代理？"></a>什么是动态代理？</h2><p>所谓动态代理买就是通过代理类让接口和实现类之间不直接发生联系，可以在运行期（Runtime）实现动态的关联，实现使用反射机制。</p><h3 id="回顾代理模式"><a href="#回顾代理模式" class="headerlink" title="回顾代理模式"></a>回顾代理模式</h3><p>代理模式(Proxy)：为其他对象提供一种代理以控制对这个对象的访问。代理模式说白了就是“真实”对象的代表，这样在访问对象的时候就引入了一定的间接性，这种间接性可以附加功能，在执行前或执行后增加类似检查，控制等功能。</p><h3 id="动态代理的优势"><a href="#动态代理的优势" class="headerlink" title="动态代理的优势"></a>动态代理的优势</h3><p>对比静态代理，静态代理模式一般代理类和具体实现类是一一对应的，这样如果需要使用代理的话需要创建的代理类就会变得繁多，而动态代理可以根据需要在运行时生成一个代理对象，一个类通过动态生成解决多个问题。</p><p>下面先概述一个静态代理的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生总会要考试的</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doExam</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStudent</span> <span class="keyword">implements</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteStudent</span><span class="params">(<span class="keyword">int</span> id,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学号为"</span>+id+<span class="string">"的"</span>+name+<span class="string">"正在考试。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代考中心</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExamProxy</span> <span class="keyword">implements</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    Student student;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExamProxy</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        student.doExam();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代考人员进行考试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> ConcreteStudent(<span class="number">201611</span>,<span class="string">"王二小"</span>);</span><br><span class="line">        Student proxy = <span class="keyword">new</span> ExamProxy(student);</span><br><span class="line">        proxy.doExam();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态代理的过程"><a href="#动态代理的过程" class="headerlink" title="动态代理的过程"></a>动态代理的过程</h2><p>动态代理在实现的时候并不去考虑去代理谁，而是在运行时制定代理哪一个对象，下面先描述在Java中构建动态代理的整个过程。</p><ul><li>事先得有代理对象的主题，也就是说要代理的对象的功能是什么</li><li>创建动态代理类，实现InvocationHandler接口，这一点是与静态代理不同的一点，这一点动态代理类就实现的不是具体的主题，而是一个完全不相干的InvocationHandler接口（说明动态代理动态生产的类还不是在这一步接收接口信息的），该接口有一个需要实现的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure></li></ul><p>接收代理的对象，方法，以及参数</p><ul><li>使用Proxy类的静态方法getInstance方法传入ClassLoader(),实现的接口类，以及InvokeHandler对象。之后指向相应的函数。<br>下面举例一个动态代理的应用场景：现在的代考中心变成了中介机构<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.maoxin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生总会要考试的</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doExam</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//白领要买房</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStudent</span> <span class="keyword">implements</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteStudent</span><span class="params">(<span class="keyword">int</span> id,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学号为"</span>+id+<span class="string">"的"</span>+name+<span class="string">"正在考试。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的工作人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteWorker</span> <span class="keyword">implements</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteWorker</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">"成功购买了一套房！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中介机构,承接各种例如代考和买房</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmallProxy</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">"doExam"</span>))&#123;</span><br><span class="line">            result = method.invoke(obj,args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">"buyHouse"</span>))&#123;</span><br><span class="line">            result = method.invoke(obj,args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> ConcreteStudent(<span class="number">201611</span>,<span class="string">"小红帽"</span>);</span><br><span class="line">        Worker worker = <span class="keyword">new</span> ConcreteWorker(<span class="string">"小白"</span>);</span><br><span class="line">        InvocationHandler proxy1 = <span class="keyword">new</span> SmallProxy(student);</span><br><span class="line">        InvocationHandler proxy2 = <span class="keyword">new</span> SmallProxy(worker);</span><br><span class="line">        Student studentProxy = (Student) Proxy.newProxyInstance(student.getClass().getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Student.class&#125;,proxy1);</span><br><span class="line">        Worker workerProxy = (Worker)Proxy.newProxyInstance(worker.getClass().getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Worker.class&#125;,proxy2);</span><br><span class="line">        studentProxy.doExam();</span><br><span class="line">        workerProxy.buyHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="为什么需要代理"><a href="#为什么需要代理" class="headerlink" title="为什么需要代理"></a>为什么需要代理</h2><p>在网上看到的一个很好的解答，这里引用一下：</p><blockquote><p>打个比喻，明星为什么需要经纪人来代理他呢？因为明星的专职是唱歌或演戏，如果把除此以外的其他事情比如演出费用谈判等等都揽在身上，他会累死。<br><strong>这就是体现一个思想：专业分工，用面向对象术语说：就是职责分明。</strong><br>所以，代理类一般是做些除原始类核心功能以外的其他功能，比如权限 事务等等都要专门的代理来实现。<br>当我们的代码每个类代表一个主要功能，而不是将所有功能混在一个类中，那么代码无疑清晰有条理的，易于维护，比如我要修改权限，就不必打开原始类代码，直接修改权限代理类就可以了。就很少发生修改一个BUG，带来一个新BUG的烦恼问题。<br><strong>No matter how slow you are writing clean code, you will always be slower if you make a mess 写干净的代码无论有多慢，总是快于把代码写得一团糟。</strong></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://wangjingxin.top/2016/11/16/proxy/" target="_blank" rel="noopener">https://wangjingxin.top/2016/11/16/proxy/</a><br>王镜鑫的个人博客<br><a href="http://www.jdon.com/43740" target="_blank" rel="noopener">http://www.jdon.com/43740</a><br>一个关于动态代理的提问</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>观察者模式</title>
      <link href="/2018/07/27/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer%20pattern%EF%BC%89/"/>
      <url>/2018/07/27/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer%20pattern%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们先预想一个这样的情景，有一个类负责监听随时随地都可能发生的事件，例如：天气的变化，用户在桌面上执行操作出发的事件。。有许多类对象需要接收这些信息并进行处理，而且这些类对象往往还不止一个，还需要动态的添加和替换，比如天气显示器，比如事件处理函数。我们需要将“通知”分发给多个对象。<br>假设负责监听的类一旦发现变化，便触发了changed函数，我们想要通知对象，最粗暴最干脆的做法就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> info = getChanged();</span><br><span class="line">    classA.update(info);</span><br><span class="line">    classB.update(info);</span><br><span class="line">    classC.update(info);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码主要有以下问题：</p><ul><li>大量使用update方法，可以用一个接口来处理</li><li>针对具体的实现编程，我们在添加或者删除对象的时候必须修改changed函数</li><li>上面几个问题结合起来的问题就是，对象与对象之间的联系太紧密了！</li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。</p><h3 id="如何解决问题？"><a href="#如何解决问题？" class="headerlink" title="如何解决问题？"></a>如何解决问题？</h3><p>从最简单的着手，既然出现了大量的update方法，我们首先用一个接口封装起来，既然描述的是观察者，我们就起名Observer接口，里面有一个update方法。观察者的管理者是前面提到的起到监听作用的类，对观察者对象的管理主要有几个内容：1.添加观察者2.删除观察者3.通知。我们将这些方法抽象一下，作为一个Subject接口。<br>具体的细节还有，多个观察者对象如何管理，我们可以利用Java内置的数据结构。<br>就这样，两个本来关系紧密的类现在只暴露出了几个来让两者建立联系的方法。这就是所谓的松耦合。</p><p>松耦合：两个对象之间松耦合指的是，他们仍然可以交互，但是不太清楚彼此的细节。</p><h3 id="JDK中应用到观察者模式的场景"><a href="#JDK中应用到观察者模式的场景" class="headerlink" title="JDK中应用到观察者模式的场景"></a>JDK中应用到观察者模式的场景</h3><p>Swing中注册事件处理函数的时候我们首先创建的类要实现ActionListener接口，之后将该对象通过addActionListener注册到相对应的控件中去。</p><p>Java内置了观察者模式的类和接口，内部数据结构是用Vector实现的。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>策略模式（strategy Pattern）</title>
      <link href="/2018/07/27/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy%20Pattern%EF%BC%89/"/>
      <url>/2018/07/27/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy%20Pattern%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="问题导入"><a href="#问题导入" class="headerlink" title="问题导入"></a>问题导入</h2><h3 id="继承的问题"><a href="#继承的问题" class="headerlink" title="继承的问题"></a>继承的问题</h3><p>当一类对象都具有相同的行为的时候，我们一般会通过继承来实现代码的复用，但是问题在于，继承太死板了，假设我们要对部分子类添加新的功能，我们需要在子类中写入实现方法，但是这样太啰嗦了，我们为了代码复用，就想在父类写这样一个方法，之后让子类去继承实现，可是有的类并不需要这样一个方法。这样牵一发而动全身。使用继承的效果并不好。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="用接口如何？"><a href="#用接口如何？" class="headerlink" title="用接口如何？"></a>用接口如何？</h3><p>用了接口就又想到了继承的好处了，接口没有包含具体的实现，我们如果用接口，解决了一部分问题，就是继承带来的死版，但是又陷入了另外一个问题，相同接口对象要写大量的重复代码（现在Java8就支持了接口的实现，解决这个问题）</p><h3 id="将容易改变的部分和不容易改变的部分分离"><a href="#将容易改变的部分和不容易改变的部分分离" class="headerlink" title="将容易改变的部分和不容易改变的部分分离"></a>将容易改变的部分和不容易改变的部分分离</h3><p>我们既想要接口为我们带来的弹性，又想要类给我们带来的代码复用。我们把这个容易改变的部分分离。创建一个接口，描述行为。创建一个类，封装具体的行为。我们创建接口对应的对象，然后组合在需要的类中。</p><h3 id="经验学习："><a href="#经验学习：" class="headerlink" title="经验学习："></a>经验学习：</h3><ul><li>有一个可能比是一个更好，多用组合，少用继承</li><li>分离变化和不变的，封装变化</li><li>对接口和类继承以及抽象类要有更深的理解</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>相同的行为而又可变的方法善用interface</li><li>Java8已经有了可实现的方法，接口已经可以独当一面</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组实现栈和队列</title>
      <link href="/2018/07/27/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2018/07/27/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>用数组实现简单线性结构，栈和队列</p><h2 id="实现栈"><a href="#实现栈" class="headerlink" title="实现栈"></a>实现栈</h2><ul><li>由于是数组，因此必然要明确栈的大小</li><li>实现相对简单，但是要注意条件检查，错误处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayToStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    ArrayToStack(<span class="keyword">int</span> initsize)&#123;</span><br><span class="line">        <span class="keyword">if</span>(initsize&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"初始化值小于0！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[initsize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"栈已空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == array.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(<span class="string">"栈已经满了！"</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">        array[index++]= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"栈已空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[--index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h2><p>实现队列有几个点关键：</p><ul><li>可以使用变量去指向队列头部和指向队列尾部</li><li>可以设置一个size去表示队列是否有空间去push以及是否为空</li><li>只要是在size不为0的情况下，执行push和pop的结果都会导致start和end的值的增加</li><li>当增加到数组最大值的时候注意可以将其置为0，置为0可以有许多方式，可以使用if直接设置也可以进行一个取余数，取余数可以让其在一定的值内循环。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayToQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayToQueue</span><span class="params">(<span class="keyword">int</span> init)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(init&lt;<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"不能为负数！"</span>);</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[init];</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>) <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"队列是空的"</span>);</span><br><span class="line">        <span class="keyword">if</span>(end==array.length) end = <span class="number">0</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> array[end++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==array.length) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"队列已满！"</span>);</span><br><span class="line">        <span class="keyword">if</span>(start==array.length) start = <span class="number">0</span>;</span><br><span class="line">        array[start++] = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayToQueue arrayToQueen = <span class="keyword">new</span> ArrayToQueue(<span class="number">3</span>);</span><br><span class="line">        arrayToQueen.push(<span class="number">1</span>);</span><br><span class="line">        arrayToQueen.push(<span class="number">2</span>);</span><br><span class="line">        arrayToQueen.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(arrayToQueen.pop());</span><br><span class="line">        arrayToQueen.push(<span class="number">4</span>);</span><br><span class="line">        System.out.println(arrayToQueen.pop());</span><br><span class="line">        System.out.println(arrayToQueen.pop());</span><br><span class="line">        System.out.println(arrayToQueen.pop());</span><br><span class="line">        <span class="comment">//为空的时候报错</span></span><br><span class="line">        System.out.println(arrayToQueen.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 队列 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>递归过程的复杂度计算</title>
      <link href="/2018/07/27/%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
      <url>/2018/07/27/%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="引入：一个简单的例子"><a href="#引入：一个简单的例子" class="headerlink" title="引入：一个简单的例子"></a>引入：一个简单的例子</h2><h3 id="求数组内最大值的递归算法"><a href="#求数组内最大值的递归算法" class="headerlink" title="求数组内最大值的递归算法"></a>求数组内最大值的递归算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetMax</span><span class="params">(<span class="keyword">int</span>[] arrays,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arrays==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(R-L&lt;=<span class="number">1</span>) <span class="keyword">return</span> Math.max(arrays[L],arrays[R]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = L+((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(GetMax(arrays,L,mid),GetMax(arrays,mid+<span class="number">1</span>,R));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] testArray = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(GetMax(testArray,<span class="number">0</span>,testArray.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Master-公式"><a href="#Master-公式" class="headerlink" title="Master 公式"></a>Master 公式</h3><p>在满足：T(N)=aT(n/b)+O(n^d) 的时间复杂度的递归行为统一可以使用Master公式来求，在用分治的思想去解决问题的时候，我们将问题分成的规模是n/b，而处理这个问题的规模所需要的次数是a，处理的过程是 O(n^d) </p><ul><li>以二分法查找我们一次将问题规模分为了两个部分，于是b就是2，而我们将我们关注的那一部分再进行分解。不需要处理另一部分，于是a就是1，之后我们对数据的处理是一个常数时间的，因此d就是0</li><li>如上进行一个最大值的查找过程使用了递归，将问题分成了两个规模，b=2，每次都进行处理a=2，处理的操作是常数时间，因此d = 0</li></ul><p>如果满足以上的通式就可以使用Master公式来求解：</p><ul><li>如果log(b,a)&gt;d -&gt;复杂度为O(N^log(b,a))</li><li>如果log(b,a)=d-&gt;复杂度为O(N^d*logN)</li><li>如果log(b,a)<d->复杂度为O(N^d)</d-></li></ul><p>那么上面两个问题的时间复杂度就可以快速计算</p><p>二分法查找是满足第二个条件，因此就是O(logN)<br>递归求最大值的程序满足第一个条件，因此结果就是O(N)</p><p>对于归并排序，首先将问题分成了两个规模，每个规模都要处理，其次处理规模是利用外排的方式进行处理，时间复杂度为O(n)，这样根据Master公式计算出来的结果是O(N*logN)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 递归 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
